{#
  Python File Template
  ====================
  Renders a complete Python file containing one or more dataclasses.
  
  Expected context (PythonFileContext):
    - containsAbstract: boolean
    - typings: string[]
    - imports: string[]
    - classes: PythonClassContext[]
    - typeMapper: Record<string, string>
#}
{%- import "_macros.njk" as py -%}
##########################################
# WARNING: This is an auto-generated file.
# DO NOT EDIT THIS FILE DIRECTLY
# ANY EDITS WILL BE LOST
##########################################
{% if containsAbstract %}
from abc import ABC
{%- endif %}
from dataclasses import dataclass, field
from typing import Any, Callable, Optional
{%- for import in imports %}
from ._{{ import }} import {{ import }}
{%- endfor %}

{% for classCtx in classes %}
{%- set node = classCtx.node -%}
{%- set typeMapper = classCtx.typeMapper -%}
{%- set alternates = classCtx.alternates -%}
{%- set polymorphicTypes = classCtx.polymorphicTypes -%}
{%- set collectionTypes = classCtx.collectionTypes %}

@dataclass
class {{ node.typeName.name }}{% if node.base %}({{ node.base.name }}){% endif %}{% if node.isAbstract %}(ABC){% endif %}:
    """{% for line in node.description.split('\n') %}{{ line }}
    {% endfor %}
    Attributes
    ----------
{%- for prop in node.properties %}
    {{ prop.name }} : {{ py.pythonType(prop, typeMapper) }}
        {{ prop.description }}
{%- endfor %}
    """
{% for prop in node.properties %}
    {{ prop.name }}: {{ py.pythonType(prop, typeMapper) }}{{ py.defaultValue(prop, typeMapper) }}
{%- endfor %}

    @staticmethod
    def load(data: Any, pre_process: Optional[Callable[[Any], Any]] = None) -> "{{ node.typeName.name }}":
        """Load a {{ node.typeName.name }} instance.
        Args:
            data (Any): The data to load the instance from.
            pre_process (Optional[Callable[[Any], Any]]): Optional pre-processing function to apply to the data before loading.
        Returns:
            {{ node.typeName.name }}: The loaded {{ node.typeName.name }} instance.

        """
        
        if pre_process is not None:
            data = pre_process(data)
        {% if alternates.length > 0 %}
        # handle alternate representations
{%- for alt in alternates %}
        if isinstance(data, {{ alt.scalar }}):
            data = {{ alt.alternate }}
{%- endfor %}
        {% endif %}
        if not isinstance(data, dict):
            raise ValueError(f"Invalid data for {{ node.typeName.name }}: {data}")
{% if polymorphicTypes %}
        # load polymorphic {{ node.typeName.name }} instance
        instance = {{ node.typeName.name }}.load_{{ node.discriminator }}(data, pre_process)
{% else %}
        # create new instance
        instance = {{ node.typeName.name }}()
{%- endif %}
{% for prop in node.properties %}
        if data is not None and "{{ prop.name }}" in data:
            {{ py.setInstance(prop, "instance", "data", node.typeName.name) }}
{%- endfor %}
        return instance
{% for collection in collectionTypes %}

    @staticmethod
    def load_{{ collection.prop.name }}(data: dict | list, pre_process: Optional[Callable[[Any], Any]]) -> list[{{ collection.prop.typeName.name }}]:
        if isinstance(data, dict):
            # convert simple named {{ collection.prop.name }} to list of {{ collection.prop.typeName.name }}
            if(len(data.keys()) == 1):
                data = [ {"name": k, "{{collection.type[0]}}": v} for k, v in data.items() ]
            else:
                data = [ {"name": k, **v} for k, v in data.items() ]
        return [{{ collection.prop.typeName.name }}.load(item, pre_process) for item in data]
{%- endfor %}
{% if polymorphicTypes %}

    @staticmethod
    def load_{{ node.discriminator }}(data: dict, pre_process: Optional[Callable[[Any], Any]]) -> "{{ node.typeName.name }}":
        # load polymorphic {{ node.typeName.name }} instance
        if data is not None and "{{ node.discriminator }}" in data:
            discriminator_value = str(data["{{ node.discriminator }}"]).lower()
{%- for type in polymorphicTypes.types %}
            {% if loop.first %}if{% else %}elif{% endif %} discriminator_value == "{{ type.value }}":
                return {{ type.instance.typeName.name }}.load(data, pre_process)
{%- endfor %}
{% if polymorphicTypes.default %}
            else:
{% if polymorphicTypes.default.instance.typeName.name == node.typeName.name %}
                # create new instance (stop recursion)
                return {{ node.typeName.name }}()
{% else %}
                # load default instance
                return {{ polymorphicTypes.default.instance.typeName.name }}.load(data, pre_process)
{%- endif %}
{% else %}
            else:
                raise ValueError(f"Unknown {{ node.typeName.name }} discriminator value: {discriminator_value}")
{%- endif %}
        else:
{% if node.isAbstract %}
            raise ValueError("Missing {{ node.typeName.name }} discriminator property: '{{ node.discriminator }}'")
{% else %}
            # create new instance
            return {{ node.typeName.name }}()
{%- endif %}
{%- endif %}
{% endfor %}
