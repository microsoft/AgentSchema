{#
  Go Test Template
  ================
  Renders Go test file for a type.
  
  Expected context (BaseTestContext):
    - node: TypeNode
    - package: string
    - examples: Array<{ json: string[], yaml: string[], validations: Array<{ key, value, delimiter, isOptional }> }>
    - alternates: Array<{ title, scalarType, value, validations: Array<{ key, value, delimiter, isOptional }> }>
#}
{% import "_macros.njk" as go %}
// Code generated by AgentSchema emitter; DO NOT EDIT.

package {{ package }}_test

import (
"encoding/json"
"testing"

"gopkg.in/yaml.v3"

"github.com/microsoft/agentschema-go/{{ package }}"
)

{% for sample in examples %}
// Test{{ node.typeName.name }}LoadJSON{% if not loop.first %}{{ loop.index - 1 }}{% endif %} tests loading {{ node.typeName.name }} from JSON
func Test{{ node.typeName.name }}LoadJSON{% if not loop.first %}{{ loop.index - 1 }}{% endif %}(t *testing.T) {
jsonData := `
{%- for line in sample.json %}
{{ line }}
{%- endfor %}
`
var data map[string]interface{}
if err := json.Unmarshal([]byte(jsonData), &data); err != nil {
t.Fatalf("Failed to parse JSON: %v", err)
}

ctx := {{ package }}.NewLoadContext()
instance, err := {{ package }}.Load{{ node.typeName.name }}(data, ctx)
if err != nil {
t.Fatalf("Failed to load {{ node.typeName.name }}: %v", err)
}

{%- if isAbstract %}
// Polymorphic types return interface{}, extract common fields via reflection or type-specific access
_ = instance // Load succeeded, exact type depends on discriminator
{%- if sample.validations.length > 0 %}
// Note: Validation skipped for polymorphic base types - test child types directly
{%- endif %}
{%- else %}
{%- if sample.validations.length > 0 %}
{%- for validation in sample.validations %}
{%- if validation.isOptional %}
if instance.{{ validation.key }} == nil || *instance.{{ validation.key }} != {{ validation.delimiter }}{{ validation.value }}{{ validation.delimiter }} {
t.Errorf(`Expected {{ validation.key }} to be {% if validation.delimiter == '"' %}"{% endif %}{{ validation.value }}{% if validation.delimiter == '"' %}"{% endif %}, got %v`, instance.{{ validation.key }})
}
{%- else %}
if instance.{{ validation.key }} != {{ validation.delimiter }}{{ validation.value }}{{ validation.delimiter }} {
t.Errorf(`Expected {{ validation.key }} to be {% if validation.delimiter == '"' %}"{% endif %}{{ validation.value }}{% if validation.delimiter == '"' %}"{% endif %}, got %v`, instance.{{ validation.key }})
}
{%- endif %}
{%- endfor %}
{%- else %}
_ = instance // No scalar properties to validate
{%- endif %}
{%- endif %}
}

// Test{{ node.typeName.name }}LoadYAML{% if not loop.first %}{{ loop.index - 1 }}{% endif %} tests loading {{ node.typeName.name }} from YAML
func Test{{ node.typeName.name }}LoadYAML{% if not loop.first %}{{ loop.index - 1 }}{% endif %}(t *testing.T) {
yamlData := `
{%- for line in sample.yaml %}
{{ line }}
{%- endfor %}
`
var data map[string]interface{}
if err := yaml.Unmarshal([]byte(yamlData), &data); err != nil {
t.Fatalf("Failed to parse YAML: %v", err)
}

ctx := {{ package }}.NewLoadContext()
instance, err := {{ package }}.Load{{ node.typeName.name }}(data, ctx)
if err != nil {
t.Fatalf("Failed to load {{ node.typeName.name }}: %v", err)
}

{%- if isAbstract %}
// Polymorphic types return interface{}, extract common fields via reflection or type-specific access
_ = instance // Load succeeded, exact type depends on discriminator
{%- if sample.validations.length > 0 %}
// Note: Validation skipped for polymorphic base types - test child types directly
{%- endif %}
{%- else %}
{%- if sample.validations.length > 0 %}
{%- for validation in sample.validations %}
{%- if validation.isOptional %}
if instance.{{ validation.key }} == nil || *instance.{{ validation.key }} != {{ validation.delimiter }}{{ validation.value }}{{ validation.delimiter }} {
t.Errorf(`Expected {{ validation.key }} to be {% if validation.delimiter == '"' %}"{% endif %}{{ validation.value }}{% if validation.delimiter == '"' %}"{% endif %}, got %v`, instance.{{ validation.key }})
}
{%- else %}
if instance.{{ validation.key }} != {{ validation.delimiter }}{{ validation.value }}{{ validation.delimiter }} {
t.Errorf(`Expected {{ validation.key }} to be {% if validation.delimiter == '"' %}"{% endif %}{{ validation.value }}{% if validation.delimiter == '"' %}"{% endif %}, got %v`, instance.{{ validation.key }})
}
{%- endif %}
{%- endfor %}
{%- else %}
_ = instance // No scalar properties to validate
{%- endif %}
{%- endif %}
}

// Test{{ node.typeName.name }}Roundtrip{% if not loop.first %}{{ loop.index - 1 }}{% endif %} tests load -> save -> load produces equivalent data
func Test{{ node.typeName.name }}Roundtrip{% if not loop.first %}{{ loop.index - 1 }}{% endif %}(t *testing.T) {
jsonData := `
{%- for line in sample.json %}
{{ line }}
{%- endfor %}
`
var data map[string]interface{}
if err := json.Unmarshal([]byte(jsonData), &data); err != nil {
t.Fatalf("Failed to parse JSON: %v", err)
}

loadCtx := {{ package }}.NewLoadContext()
instance, err := {{ package }}.Load{{ node.typeName.name }}(data, loadCtx)
if err != nil {
t.Fatalf("Failed to load {{ node.typeName.name }}: %v", err)
}

{%- if isAbstract %}
// Polymorphic roundtrip testing requires type-specific handling
_ = instance // Load succeeded, exact type depends on discriminator
// Note: Roundtrip test skipped for polymorphic base types - test child types directly
{%- else %}
saveCtx := {{ package }}.NewSaveContext()
savedData := instance.Save(saveCtx)

reloaded, err := {{ package }}.Load{{ node.typeName.name }}(savedData, loadCtx)
if err != nil {
t.Fatalf("Failed to reload {{ node.typeName.name }}: %v", err)
}

{%- if sample.validations.length > 0 %}
{%- for validation in sample.validations %}
{%- if validation.isOptional %}
if reloaded.{{ validation.key }} == nil || *reloaded.{{ validation.key }} != {{ validation.delimiter }}{{ validation.value }}{{ validation.delimiter }} {
t.Errorf(`Expected {{ validation.key }} to be {% if validation.delimiter == '"' %}"{% endif %}{{ validation.value }}{% if validation.delimiter == '"' %}"{% endif %}, got %v`, reloaded.{{ validation.key }})
}
{%- else %}
if reloaded.{{ validation.key }} != {{ validation.delimiter }}{{ validation.value }}{{ validation.delimiter }} {
t.Errorf(`Expected {{ validation.key }} to be {% if validation.delimiter == '"' %}"{% endif %}{{ validation.value }}{% if validation.delimiter == '"' %}"{% endif %}, got %v`, reloaded.{{ validation.key }})
}
{%- endif %}
{%- endfor %}
{%- else %}
_ = reloaded // No scalar properties to validate
{%- endif %}
{%- endif %}
}

// Test{{ node.typeName.name }}ToJSON{% if not loop.first %}{{ loop.index - 1 }}{% endif %} tests that ToJSON produces valid JSON
func Test{{ node.typeName.name }}ToJSON{% if not loop.first %}{{ loop.index - 1 }}{% endif %}(t *testing.T) {
jsonData := `
{%- for line in sample.json %}
{{ line }}
{%- endfor %}
`
var data map[string]interface{}
if err := json.Unmarshal([]byte(jsonData), &data); err != nil {
t.Fatalf("Failed to parse JSON: %v", err)
}

ctx := {{ package }}.NewLoadContext()
instance, err := {{ package }}.Load{{ node.typeName.name }}(data, ctx)
if err != nil {
t.Fatalf("Failed to load {{ node.typeName.name }}: %v", err)
}

{%- if isAbstract %}
// Polymorphic ToJSON requires type-specific handling
_ = instance // Load succeeded, exact type depends on discriminator
// Note: ToJSON test skipped for polymorphic base types - test child types directly
{%- else %}
jsonOutput, err := instance.ToJSON()
if err != nil {
t.Fatalf("Failed to convert to JSON: %v", err)
}

var parsed map[string]interface{}
if err := json.Unmarshal([]byte(jsonOutput), &parsed); err != nil {
t.Fatalf("Failed to parse generated JSON: %v", err)
}
{%- endif %}
}

// Test{{ node.typeName.name }}ToYAML{% if not loop.first %}{{ loop.index - 1 }}{% endif %} tests that ToYAML produces valid YAML
func Test{{ node.typeName.name }}ToYAML{% if not loop.first %}{{ loop.index - 1 }}{% endif %}(t *testing.T) {
jsonData := `
{%- for line in sample.json %}
{{ line }}
{%- endfor %}
`
var data map[string]interface{}
if err := json.Unmarshal([]byte(jsonData), &data); err != nil {
t.Fatalf("Failed to parse JSON: %v", err)
}

ctx := {{ package }}.NewLoadContext()
instance, err := {{ package }}.Load{{ node.typeName.name }}(data, ctx)
if err != nil {
t.Fatalf("Failed to load {{ node.typeName.name }}: %v", err)
}

{%- if isAbstract %}
// Polymorphic ToYAML requires type-specific handling
_ = instance // Load succeeded, exact type depends on discriminator
// Note: ToYAML test skipped for polymorphic base types - test child types directly
{%- else %}
yamlOutput, err := instance.ToYAML()
if err != nil {
t.Fatalf("Failed to convert to YAML: %v", err)
}

var parsed map[string]interface{}
if err := yaml.Unmarshal([]byte(yamlOutput), &parsed); err != nil {
t.Fatalf("Failed to parse generated YAML: %v", err)
}
{%- endif %}
}

{% endfor %}
{% if alternates.length > 0 %}
{% for alt in alternates %}
// Test{{ node.typeName.name }}From{{ alt.title | capitalize }}{% if not loop.first %}{{ loop.index }}{% endif %} tests loading {{ node.typeName.name }} from {{ alt.scalarType }}
func Test{{ node.typeName.name }}From{{ alt.title | capitalize }}{% if not loop.first %}{{ loop.index }}{% endif %}(t *testing.T) {
ctx := {{ package }}.NewLoadContext()
instance, err := {{ package }}.Load{{ node.typeName.name }}({{ alt.value }}, ctx)
if err != nil {
t.Fatalf("Failed to load {{ node.typeName.name }} from {{ alt.scalarType }}: %v", err)
}

{%- if isAbstract %}
// Polymorphic alternate loading requires type-specific handling
_ = instance // Load succeeded, exact type depends on discriminator
{%- if alt.validations.length > 0 %}
// Note: Validation skipped for polymorphic base types - test child types directly
{%- endif %}
{%- else %}
{%- if alt.validations.length > 0 %}
{%- for item in alt.validations %}
{%- if item.isOptional %}
if instance.{{ item.key }} == nil || *instance.{{ item.key }} != {{ item.delimiter }}{{ item.value }}{{ item.delimiter }} {
t.Errorf(`Expected {{ item.key }} to be {% if item.delimiter == '"' %}"{% endif %}{{ item.value }}{% if item.delimiter == '"' %}"{% endif %}, got %v`, instance.{{ item.key }})
}
{%- else %}
if instance.{{ item.key }} != {{ item.delimiter }}{{ item.value }}{{ item.delimiter }} {
t.Errorf(`Expected {{ item.key }} to be {% if item.delimiter == '"' %}"{% endif %}{{ item.value }}{% if item.delimiter == '"' %}"{% endif %}, got %v`, instance.{{ item.key }})
}
{%- endif %}
{%- endfor %}
{%- else %}
_ = instance // No scalar properties to validate
{%- endif %}
{%- endif %}
}

{% endfor %}
{% endif %}
