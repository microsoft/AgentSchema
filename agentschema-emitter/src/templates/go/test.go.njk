{#
  Go Test Template
  ================
  Renders Go test file for a type.
  
  Expected context (GoTestContext):
    - node: TypeNode
    - packageName: string
    - examples: Array<{ json: string[], yaml: string[], validation: Array<{ key, value, delimeter }> }>
    - alternates: Array<{ title, scalar, value, validation: Array<{ key, value, delimeter }> }>
#}
{% import "_macros.njk" as go %}
// Code generated by AgentSchema emitter; DO NOT EDIT.

package {{ packageName }}_test

import (
"encoding/json"
"testing"

"gopkg.in/yaml.v3"

"github.com/microsoft/agentschema-go/{{ packageName }}"
)

{% for sample in examples %}
// Test{{ node.typeName.name }}LoadJSON{% if not loop.first %}{{ loop.index - 1 }}{% endif %} tests loading {{ node.typeName.name }} from JSON
func Test{{ node.typeName.name }}LoadJSON{% if not loop.first %}{{ loop.index - 1 }}{% endif %}(t *testing.T) {
jsonData := `
{%- for line in sample.json %}
{{ line }}
{%- endfor %}
`
var data map[string]interface{}
if err := json.Unmarshal([]byte(jsonData), &data); err != nil {
t.Fatalf("Failed to parse JSON: %v", err)
}

ctx := {{ packageName }}.NewLoadContext()
instance, err := {{ packageName }}.Load{{ node.typeName.name }}(data, ctx)
if err != nil {
t.Fatalf("Failed to load {{ node.typeName.name }}: %v", err)
}

{%- if isPolymorphic %}
// Polymorphic types return interface{}, extract common fields via reflection or type-specific access
_ = instance // Load succeeded, exact type depends on discriminator
{%- if sample.validation.length > 0 %}
// Note: Validation skipped for polymorphic base types - test child types directly
{%- endif %}
{%- else %}
{%- if sample.validation.length > 0 %}
{%- for validation in sample.validation %}
{%- if validation.isPointer %}
if instance.{{ validation.key }} == nil || *instance.{{ validation.key }} != {{ validation.delimeter }}{{ validation.value }}{{ validation.delimeter }} {
t.Errorf(`Expected {{ validation.key }} to be {% if validation.delimeter == '"' %}"{% endif %}{{ validation.value }}{% if validation.delimeter == '"' %}"{% endif %}, got %v`, instance.{{ validation.key }})
}
{%- else %}
if instance.{{ validation.key }} != {{ validation.delimeter }}{{ validation.value }}{{ validation.delimeter }} {
t.Errorf(`Expected {{ validation.key }} to be {% if validation.delimeter == '"' %}"{% endif %}{{ validation.value }}{% if validation.delimeter == '"' %}"{% endif %}, got %v`, instance.{{ validation.key }})
}
{%- endif %}
{%- endfor %}
{%- else %}
_ = instance // No scalar properties to validate
{%- endif %}
{%- endif %}
}

// Test{{ node.typeName.name }}LoadYAML{% if not loop.first %}{{ loop.index - 1 }}{% endif %} tests loading {{ node.typeName.name }} from YAML
func Test{{ node.typeName.name }}LoadYAML{% if not loop.first %}{{ loop.index - 1 }}{% endif %}(t *testing.T) {
yamlData := `
{%- for line in sample.yaml %}
{{ line }}
{%- endfor %}
`
var data map[string]interface{}
if err := yaml.Unmarshal([]byte(yamlData), &data); err != nil {
t.Fatalf("Failed to parse YAML: %v", err)
}

ctx := {{ packageName }}.NewLoadContext()
instance, err := {{ packageName }}.Load{{ node.typeName.name }}(data, ctx)
if err != nil {
t.Fatalf("Failed to load {{ node.typeName.name }}: %v", err)
}

{%- if isPolymorphic %}
// Polymorphic types return interface{}, extract common fields via reflection or type-specific access
_ = instance // Load succeeded, exact type depends on discriminator
{%- if sample.validation.length > 0 %}
// Note: Validation skipped for polymorphic base types - test child types directly
{%- endif %}
{%- else %}
{%- if sample.validation.length > 0 %}
{%- for validation in sample.validation %}
{%- if validation.isPointer %}
if instance.{{ validation.key }} == nil || *instance.{{ validation.key }} != {{ validation.delimeter }}{{ validation.value }}{{ validation.delimeter }} {
t.Errorf(`Expected {{ validation.key }} to be {% if validation.delimeter == '"' %}"{% endif %}{{ validation.value }}{% if validation.delimeter == '"' %}"{% endif %}, got %v`, instance.{{ validation.key }})
}
{%- else %}
if instance.{{ validation.key }} != {{ validation.delimeter }}{{ validation.value }}{{ validation.delimeter }} {
t.Errorf(`Expected {{ validation.key }} to be {% if validation.delimeter == '"' %}"{% endif %}{{ validation.value }}{% if validation.delimeter == '"' %}"{% endif %}, got %v`, instance.{{ validation.key }})
}
{%- endif %}
{%- endfor %}
{%- else %}
_ = instance // No scalar properties to validate
{%- endif %}
{%- endif %}
}

// Test{{ node.typeName.name }}Roundtrip{% if not loop.first %}{{ loop.index - 1 }}{% endif %} tests load -> save -> load produces equivalent data
func Test{{ node.typeName.name }}Roundtrip{% if not loop.first %}{{ loop.index - 1 }}{% endif %}(t *testing.T) {
jsonData := `
{%- for line in sample.json %}
{{ line }}
{%- endfor %}
`
var data map[string]interface{}
if err := json.Unmarshal([]byte(jsonData), &data); err != nil {
t.Fatalf("Failed to parse JSON: %v", err)
}

loadCtx := {{ packageName }}.NewLoadContext()
instance, err := {{ packageName }}.Load{{ node.typeName.name }}(data, loadCtx)
if err != nil {
t.Fatalf("Failed to load {{ node.typeName.name }}: %v", err)
}

{%- if isPolymorphic %}
// Polymorphic roundtrip testing requires type-specific handling
_ = instance // Load succeeded, exact type depends on discriminator
// Note: Roundtrip test skipped for polymorphic base types - test child types directly
{%- else %}
saveCtx := {{ packageName }}.NewSaveContext()
savedData := instance.Save(saveCtx)

reloaded, err := {{ packageName }}.Load{{ node.typeName.name }}(savedData, loadCtx)
if err != nil {
t.Fatalf("Failed to reload {{ node.typeName.name }}: %v", err)
}

{%- if sample.validation.length > 0 %}
{%- for validation in sample.validation %}
{%- if validation.isPointer %}
if reloaded.{{ validation.key }} == nil || *reloaded.{{ validation.key }} != {{ validation.delimeter }}{{ validation.value }}{{ validation.delimeter }} {
t.Errorf(`Expected {{ validation.key }} to be {% if validation.delimeter == '"' %}"{% endif %}{{ validation.value }}{% if validation.delimeter == '"' %}"{% endif %}, got %v`, reloaded.{{ validation.key }})
}
{%- else %}
if reloaded.{{ validation.key }} != {{ validation.delimeter }}{{ validation.value }}{{ validation.delimeter }} {
t.Errorf(`Expected {{ validation.key }} to be {% if validation.delimeter == '"' %}"{% endif %}{{ validation.value }}{% if validation.delimeter == '"' %}"{% endif %}, got %v`, reloaded.{{ validation.key }})
}
{%- endif %}
{%- endfor %}
{%- else %}
_ = reloaded // No scalar properties to validate
{%- endif %}
{%- endif %}
}

// Test{{ node.typeName.name }}ToJSON{% if not loop.first %}{{ loop.index - 1 }}{% endif %} tests that ToJSON produces valid JSON
func Test{{ node.typeName.name }}ToJSON{% if not loop.first %}{{ loop.index - 1 }}{% endif %}(t *testing.T) {
jsonData := `
{%- for line in sample.json %}
{{ line }}
{%- endfor %}
`
var data map[string]interface{}
if err := json.Unmarshal([]byte(jsonData), &data); err != nil {
t.Fatalf("Failed to parse JSON: %v", err)
}

ctx := {{ packageName }}.NewLoadContext()
instance, err := {{ packageName }}.Load{{ node.typeName.name }}(data, ctx)
if err != nil {
t.Fatalf("Failed to load {{ node.typeName.name }}: %v", err)
}

{%- if isPolymorphic %}
// Polymorphic ToJSON requires type-specific handling
_ = instance // Load succeeded, exact type depends on discriminator
// Note: ToJSON test skipped for polymorphic base types - test child types directly
{%- else %}
jsonOutput, err := instance.ToJSON()
if err != nil {
t.Fatalf("Failed to convert to JSON: %v", err)
}

var parsed map[string]interface{}
if err := json.Unmarshal([]byte(jsonOutput), &parsed); err != nil {
t.Fatalf("Failed to parse generated JSON: %v", err)
}
{%- endif %}
}

// Test{{ node.typeName.name }}ToYAML{% if not loop.first %}{{ loop.index - 1 }}{% endif %} tests that ToYAML produces valid YAML
func Test{{ node.typeName.name }}ToYAML{% if not loop.first %}{{ loop.index - 1 }}{% endif %}(t *testing.T) {
jsonData := `
{%- for line in sample.json %}
{{ line }}
{%- endfor %}
`
var data map[string]interface{}
if err := json.Unmarshal([]byte(jsonData), &data); err != nil {
t.Fatalf("Failed to parse JSON: %v", err)
}

ctx := {{ packageName }}.NewLoadContext()
instance, err := {{ packageName }}.Load{{ node.typeName.name }}(data, ctx)
if err != nil {
t.Fatalf("Failed to load {{ node.typeName.name }}: %v", err)
}

{%- if isPolymorphic %}
// Polymorphic ToYAML requires type-specific handling
_ = instance // Load succeeded, exact type depends on discriminator
// Note: ToYAML test skipped for polymorphic base types - test child types directly
{%- else %}
yamlOutput, err := instance.ToYAML()
if err != nil {
t.Fatalf("Failed to convert to YAML: %v", err)
}

var parsed map[string]interface{}
if err := yaml.Unmarshal([]byte(yamlOutput), &parsed); err != nil {
t.Fatalf("Failed to parse generated YAML: %v", err)
}
{%- endif %}
}

{% endfor %}
{% if alternates.length > 0 %}
{% for alt in alternates %}
// Test{{ node.typeName.name }}From{{ alt.title | capitalize }}{% if not loop.first %}{{ loop.index }}{% endif %} tests loading {{ node.typeName.name }} from {{ alt.scalar }}
func Test{{ node.typeName.name }}From{{ alt.title | capitalize }}{% if not loop.first %}{{ loop.index }}{% endif %}(t *testing.T) {
ctx := {{ packageName }}.NewLoadContext()
instance, err := {{ packageName }}.Load{{ node.typeName.name }}({{ alt.value }}, ctx)
if err != nil {
t.Fatalf("Failed to load {{ node.typeName.name }} from {{ alt.scalar }}: %v", err)
}

{%- if isPolymorphic %}
// Polymorphic alternate loading requires type-specific handling
_ = instance // Load succeeded, exact type depends on discriminator
{%- if alt.validation.length > 0 %}
// Note: Validation skipped for polymorphic base types - test child types directly
{%- endif %}
{%- else %}
{%- if alt.validation.length > 0 %}
{%- for item in alt.validation %}
{%- if item.isPointer %}
if instance.{{ item.key }} == nil || *instance.{{ item.key }} != {{ item.delimeter }}{{ item.value }}{{ item.delimeter }} {
t.Errorf(`Expected {{ item.key }} to be {% if item.delimeter == '"' %}"{% endif %}{{ item.value }}{% if item.delimeter == '"' %}"{% endif %}, got %v`, instance.{{ item.key }})
}
{%- else %}
if instance.{{ item.key }} != {{ item.delimeter }}{{ item.value }}{{ item.delimeter }} {
t.Errorf(`Expected {{ item.key }} to be {% if item.delimeter == '"' %}"{% endif %}{{ item.value }}{% if item.delimeter == '"' %}"{% endif %}, got %v`, instance.{{ item.key }})
}
{%- endif %}
{%- endfor %}
{%- else %}
_ = instance // No scalar properties to validate
{%- endif %}
{%- endif %}
}

{% endfor %}
{% endif %}
