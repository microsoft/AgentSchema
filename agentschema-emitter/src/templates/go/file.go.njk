{#
  Go Struct File Template
  =======================
  Renders Go struct definitions with JSON/YAML serialization.
  
  Expected context (GoFileContext):
    - packageName: string
    - containsAbstract: boolean
    - imports: string[]
    - classes: GoClassContext[]
    - typeMapper: Record<string, string>
#}
{% import "_macros.njk" as go %}
// Code generated by AgentSchema emitter; DO NOT EDIT.

package {{ packageName }}

import (
	"encoding/json"
	
	"gopkg.in/yaml.v3"
)

{% for class in classes %}
{%- if class.node.description %}
{{ go.goComment(class.node.typeName.name + " represents " + class.node.description) -}}
{%- else %}
// {{ class.node.typeName.name }} represents a schema type
{%- endif %}
type {{ class.node.typeName.name }} struct {
{%- for prop in class.node.properties %}
	{{ go.propName(prop.name) }} {{ go.goType(prop, typeMapper, polymorphicTypeNames) }} {{ go.structTags(prop) }}
{%- endfor %}
}

// Load{{ class.node.typeName.name }} creates a {{ class.node.typeName.name }} from a map[string]interface{}
{% if class.polymorphicTypes -%}
// Returns interface{} because this is a polymorphic base type that can resolve to different child types
func Load{{ class.node.typeName.name }}(data interface{}, ctx *LoadContext) (interface{}, error) {
{%- else -%}
func Load{{ class.node.typeName.name }}(data interface{}, ctx *LoadContext) ({{ class.node.typeName.name }}, error) {
{%- endif %}
	result := {{ class.node.typeName.name }}{}
	
	{% if class.polymorphicTypes -%}
	// Handle polymorphic types based on discriminator
	if m, ok := data.(map[string]interface{}); ok {
		if discriminator, ok := m["{{ class.node.discriminator }}"]; ok {
			switch discriminator {
			{%- for polyType in class.polymorphicTypes.types %}
			case "{{ polyType.value }}":
				return Load{{ polyType.instance.typeName.name }}(data, ctx)
			{%- endfor %}
			{%- if class.polymorphicTypes.default %}
			default:
				return Load{{ class.polymorphicTypes.default.instance.typeName.name }}(data, ctx)
			{%- endif %}
			}
		}
	}
	{% endif -%}
	
	{% if class.alternates.length > 0 -%}
	// Handle alternate scalar representations
	switch v := data.(type) {
	{%- for alt in class.alternates %}
	case {{ alt.scalar }}:
		// Shorthand: {{ alt.scalar }} -> {{ class.node.typeName.name }}
		expansion := map[string]interface{}{{ alt.alternate }}
		return Load{{ class.node.typeName.name }}(expansion, ctx)
	{%- endfor %}
	}
	{% endif -%}
	
	// Load from map
	if m, ok := data.(map[string]interface{}); ok {
{%- for prop in class.node.properties %}
		{{ go.loadProperty(prop, "m", typeMapper, polymorphicTypeNames) }}
{%- endfor %}
	}
	
	return result, nil
}

// Save serializes {{ class.node.typeName.name }} to map[string]interface{}
func (obj *{{ class.node.typeName.name }}) Save(ctx *SaveContext) map[string]interface{} {
	result := make(map[string]interface{})
{%- for prop in class.node.properties %}
	{{ go.saveProperty(prop, polymorphicTypeNames) }}
{%- endfor %}
	
	return result
}

// ToJSON serializes {{ class.node.typeName.name }} to JSON string
func (obj *{{ class.node.typeName.name }}) ToJSON() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := json.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// ToYAML serializes {{ class.node.typeName.name }} to YAML string
func (obj *{{ class.node.typeName.name }}) ToYAML() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := yaml.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// FromJSON creates {{ class.node.typeName.name }} from JSON string
{% if class.polymorphicTypes -%}
// Returns interface{} because this is a polymorphic base type that can resolve to different child types
func {{ class.node.typeName.name }}FromJSON(jsonStr string) (interface{}, error) {
	var data map[string]interface{}
	if err := json.Unmarshal([]byte(jsonStr), &data); err != nil {
		return nil, err
	}
	ctx := NewLoadContext()
	return Load{{ class.node.typeName.name }}(data, ctx)
}

// FromYAML creates {{ class.node.typeName.name }} from YAML string
// Returns interface{} because this is a polymorphic base type that can resolve to different child types
func {{ class.node.typeName.name }}FromYAML(yamlStr string) (interface{}, error) {
	var data map[string]interface{}
	if err := yaml.Unmarshal([]byte(yamlStr), &data); err != nil {
		return nil, err
	}
	ctx := NewLoadContext()
	return Load{{ class.node.typeName.name }}(data, ctx)
}
{%- else -%}
func {{ class.node.typeName.name }}FromJSON(jsonStr string) ({{ class.node.typeName.name }}, error) {
	var data map[string]interface{}
	if err := json.Unmarshal([]byte(jsonStr), &data); err != nil {
		return {{ class.node.typeName.name }}{}, err
	}
	ctx := NewLoadContext()
	return Load{{ class.node.typeName.name }}(data, ctx)
}

// FromYAML creates {{ class.node.typeName.name }} from YAML string
func {{ class.node.typeName.name }}FromYAML(yamlStr string) ({{ class.node.typeName.name }}, error) {
	var data map[string]interface{}
	if err := yaml.Unmarshal([]byte(yamlStr), &data); err != nil {
		return {{ class.node.typeName.name }}{}, err
	}
	ctx := NewLoadContext()
	return Load{{ class.node.typeName.name }}(data, ctx)
}
{%- endif %}

{% endfor %}
