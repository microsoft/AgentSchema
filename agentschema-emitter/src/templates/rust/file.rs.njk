{#
  Rust Struct File Template
  =========================
  Renders Rust struct definitions with JSON/YAML serialization.

  Expected context (RustFileContext):
    - containsAbstract: boolean
    - imports: string[]
    - classes: RustClassContext[]
    - typeMapper: Record<string, string>
    - polymorphicTypeNames: string[]
#}
{% import "_macros.njk" as rust %}
// Code generated by AgentSchema emitter; DO NOT EDIT.

use crate::context::{LoadContext, SaveContext};
{% for import in imports %}
use crate::{{ import | snakeCase }}::{{ import }};
{% endfor %}

{% for class in classes %}
{%- if class.node.description %}
/// {{ class.node.description | replace("\n", "\n/// ") }}
{%- else %}
/// {{ class.node.typeName.name }} schema type
{%- endif %}
#[derive(Debug, Clone)]
pub struct {{ class.node.typeName.name }} {
{%- for prop in class.node.properties %}
{%- if prop.description %}
    /// {{ prop.description | replace("\n", "\n    /// ") }}
{%- endif %}
    pub {{ prop.name | snakeCase }}: {{ rust.rustType(prop, typeMapper, polymorphicTypeNames) | trim }},
{%- endfor %}
}

impl Default for {{ class.node.typeName.name }} {
    fn default() -> Self {
        {{ class.node.typeName.name }} {
{%- for prop in class.node.properties %}
            {{ prop.name | snakeCase }}: {{ rust.defaultValue(prop, typeMapper, polymorphicTypeNames) | trim }},
{%- endfor %}
        }
    }
}

impl {{ class.node.typeName.name }} {
    /// Create a new {{ class.node.typeName.name }} with default values.
    pub fn new() -> Self {
        Self::default()
    }

    /// Load {{ class.node.typeName.name }} from a JSON string.
    pub fn from_json(json: &str) -> Result<Self, serde_json::Error> {
        let value: serde_json::Value = serde_json::from_str(json)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load {{ class.node.typeName.name }} from a YAML string.
    pub fn from_yaml(yaml: &str) -> Result<Self, serde_yaml::Error> {
        let value: serde_json::Value = serde_yaml::from_str(yaml)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load {{ class.node.typeName.name }} from a `serde_json::Value`.
    pub fn load_from_value(value: &serde_json::Value) -> Self {
        let mut result = Self::default();
        {%- if class.alternates.length > 0 %}
        {%- for alt in class.alternates %}
        {%- if alt.scalar == "String" %}
        if let Some(s) = value.as_str() {
            let value = s.to_string();
            let expansion = serde_json::json!({{ alt.alternate }});
            return Self::load_from_value(&expansion);
        }
        {%- elif alt.scalar == "bool" %}
        if let Some(value) = value.as_bool() {
            let expansion = serde_json::json!({{ alt.alternate }});
            return Self::load_from_value(&expansion);
        }
        {%- elif alt.scalar in ["i64", "i32"] %}
        if let Some(value) = value.as_i64() {
            let expansion = serde_json::json!({{ alt.alternate }});
            return Self::load_from_value(&expansion);
        }
        {%- elif alt.scalar in ["f64", "f32"] %}
        if let Some(value) = value.as_f64() {
            let expansion = serde_json::json!({{ alt.alternate }});
            return Self::load_from_value(&expansion);
        }
        {%- endif %}
        {%- endfor %}
        {%- endif %}
        // Load fields from JSON object
{%- for prop in class.node.properties %}
        {{ rust.loadProperty(prop, "value", typeMapper, polymorphicTypeNames) | trim }}
{%- endfor %}
        result
    }

    /// Serialize {{ class.node.typeName.name }} to a `serde_json::Value`.
    pub fn to_value(&self) -> serde_json::Value {
        let mut result = serde_json::Map::new();
{%- for prop in class.node.properties %}
        {{ rust.saveProperty(prop, polymorphicTypeNames) | trim }}
{%- endfor %}
        serde_json::Value::Object(result)
    }

    /// Serialize {{ class.node.typeName.name }} to a JSON string.
    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string_pretty(&self.to_value())
    }

    /// Serialize {{ class.node.typeName.name }} to a YAML string.
    pub fn to_yaml(&self) -> Result<String, serde_yaml::Error> {
        serde_yaml::to_string(&self.to_value())
    }

{%- for prop in class.node.properties %}
{%- if (prop.isCollection and not prop.isScalar and not prop.isDict) or prop.isDict %}
    {{ rust.typedAccessor(prop) | trim }}

{%- endif %}
{%- endfor %}
}

{% endfor %}
