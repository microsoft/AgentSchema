{#
  Rust Struct File Template
  =========================
  Renders Rust struct definitions with JSON/YAML serialization.

  Expected context (RustFileContext):
    - packageName: string
    - containsAbstract: boolean
    - classes: RustClassContext[]
    - typeMapper: Record<string, string>
    - polymorphicTypeNames: string[]
#}
{% import "_macros.njk" as rust %}
// Code generated by AgentSchema emitter; DO NOT EDIT.

#[allow(unused_imports)]
use crate::*;

{% for class in classes %}
{%- if class.hasAlternates %}
{# Types with shorthand/alternate representations need custom Deserialize #}

{# ---- Helper structs for deserialization ---- #}
#[doc(hidden)]
#[derive(serde::Deserialize)]
struct _{{ class.node.typeName.name }}Fields {
{%- for prop in class.node.properties %}
    {{ rust.helperSerdeAttr(prop) }}
    {{ prop.name | snakeCase }}: {{ rust.rustType(prop, typeMapper, polymorphicTypeNames) }},
{%- endfor %}
}

#[doc(hidden)]
#[derive(serde::Deserialize)]
#[serde(untagged)]
enum _{{ class.node.typeName.name }}Repr {
{%- for alt in class.alternates %}
    {{ alt.variantName }}({{ alt.rustScalar }}),
{%- endfor %}
    Full(_{{ class.node.typeName.name }}Fields),
}
{% endif -%}

{%- if class.node.description %}
{{ rust.rustComment(class.node.typeName.name + " represents " + class.node.description) -}}
{%- else %}
/// {{ class.node.typeName.name }} represents a schema type
{%- endif %}
{%- if class.hasAlternates %}
#[derive(Debug, Clone, Default, serde::Serialize)]
{%- else %}
#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
{%- endif %}
pub struct {{ class.node.typeName.name }} {
{%- for prop in class.node.properties %}
    {{ rust.serdeAttr(prop) }}
    pub {{ prop.name | snakeCase }}: {{ rust.rustType(prop, typeMapper, polymorphicTypeNames) }},
{%- endfor %}
}

{% if class.hasAlternates -%}
impl<'de> serde::Deserialize<'de> for {{ class.node.typeName.name }} {
    fn deserialize<D: serde::Deserializer<'de>>(d: D) -> Result<Self, D::Error> {
        let repr = _{{ class.node.typeName.name }}Repr::deserialize(d)?;
        match repr {
{%- for alt in class.alternates %}
            _{{ class.node.typeName.name }}Repr::{{ alt.variantName }}(v) => {
                let expanded = serde_json::json!({
{%- for field in alt.fields %}
{%- if field.isValue %}
                    "{{ field.jsonKey }}": v{% if not loop.last %},{% endif %}
{%- else %}
                    "{{ field.jsonKey }}": "{{ field.literalValue }}"{% if not loop.last %},{% endif %}
{%- endif %}
{%- endfor %}
                });
                let fields: _{{ class.node.typeName.name }}Fields = serde_json::from_value(expanded)
                    .map_err(|e| serde::de::Error::custom(e.to_string()))?;
                Ok({{ class.node.typeName.name }} {
{%- for prop in class.node.properties %}
                    {{ prop.name | snakeCase }}: fields.{{ prop.name | snakeCase }},
{%- endfor %}
                })
            }
{%- endfor %}
            _{{ class.node.typeName.name }}Repr::Full(f) => Ok({{ class.node.typeName.name }} {
{%- for prop in class.node.properties %}
                {{ prop.name | snakeCase }}: f.{{ prop.name | snakeCase }},
{%- endfor %}
            }),
        }
    }
}

{% endif -%}
impl {{ class.node.typeName.name }} {
    /// Load from a JSON string.
    pub fn from_json(s: &str) -> Result<Self, String> {
        serde_json::from_str(s).map_err(|e| e.to_string())
    }

    /// Serialize to a JSON string.
    pub fn to_json(&self) -> Result<String, String> {
        serde_json::to_string(self).map_err(|e| e.to_string())
    }

    /// Load from a YAML string.
    pub fn from_yaml(s: &str) -> Result<Self, String> {
        serde_yaml::from_str(s).map_err(|e| e.to_string())
    }

    /// Serialize to a YAML string.
    pub fn to_yaml(&self) -> Result<String, String> {
        serde_yaml::to_string(self).map_err(|e| e.to_string())
    }
{% if class.polymorphicTypes %}
    /// Load from a JSON string, dispatching to the appropriate child type.
    /// Returns a `serde_json::Value` containing the deserialized child type.
    pub fn from_json_polymorphic(s: &str) -> Result<serde_json::Value, String> {
        let val: serde_json::Value = serde_json::from_str(s).map_err(|e| e.to_string())?;
        Self::load_polymorphic(val)
    }

    /// Load from a YAML string, dispatching to the appropriate child type.
    /// Returns a `serde_json::Value` containing the deserialized child type.
    pub fn from_yaml_polymorphic(s: &str) -> Result<serde_json::Value, String> {
        let val: serde_json::Value = serde_yaml::from_str(s).map_err(|e| e.to_string())?;
        Self::load_polymorphic(val)
    }

    /// Dispatch a `serde_json::Value` to the appropriate child type based on
    /// the `{{ class.node.discriminator }}` discriminator field.
    pub fn load_polymorphic(val: serde_json::Value) -> Result<serde_json::Value, String> {
        if let Some(disc) = val.get("{{ class.node.discriminator }}").and_then(|v| v.as_str()) {
            match disc {
{%- for polyType in class.polymorphicTypes.types %}
                "{{ polyType.value }}" => {
                    let typed = {{ polyType.instance.typeName.name }}::from_json(
                        &serde_json::to_string(&val).map_err(|e| e.to_string())?
                    )?;
                    serde_json::to_value(typed).map_err(|e| e.to_string())
                }
{%- endfor %}
{%- if class.polymorphicTypes.default and class.polymorphicTypes.default.instance.typeName.name != class.node.typeName.name %}
                _ => {
                    let typed = {{ class.polymorphicTypes.default.instance.typeName.name }}::from_json(
                        &serde_json::to_string(&val).map_err(|e| e.to_string())?
                    )?;
                    serde_json::to_value(typed).map_err(|e| e.to_string())
                }
{%- else %}
                _ => serde_json::to_value(
                    serde_json::from_value::<{{ class.node.typeName.name }}>(val).map_err(|e| e.to_string())?
                ).map_err(|e| e.to_string()),
{%- endif %}
            }
        } else {
            Ok(val)
        }
    }
{% endif %}
}

{% endfor %}
