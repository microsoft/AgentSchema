{#
  C# File Template
  ================
  Renders a complete C# file containing a class with JSON/YAML serialization.
  
  Expected context (CSharpFileContext):
    - node: TypeNode
    - namespace: string
    - polymorphicTypes: Array
    - collectionTypes: Array
    - alternates: Array
    - shorthandProperty: string | null
#}
// Copyright (c) Microsoft. All rights reserved.
// WARNING: This is an auto-generated file. DO NOT EDIT THIS FILE DIRECTLY.

using System.Text.Json;
using YamlDotNet.Serialization;

#pragma warning disable IDE0130
namespace {{ namespace }};
#pragma warning restore IDE0130

/// <summary>
{%- for line in node.description.split('\n') %}
/// {{ line }}
{%- endfor %}
/// </summary>
public{% if node.isAbstract %} abstract{% endif %} class {{ node.typeName.name }}{% if node.base %} : {{ node.base.name }}{% endif %}
{
    /// <summary>
    /// The shorthand property name for this type, if any.
    /// </summary>
    public {% if node.base %}new {% endif %}static string? ShorthandProperty => {% if shorthandProperty %}"{{ shorthandProperty }}"{% else %}null{% endif %};

    /// <summary>
    /// Initializes a new instance of <see cref="{{ node.typeName.name }}"/>.
    /// </summary>
    #pragma warning disable CS8618
    {% if node.isAbstract %}protected{% else %}public{% endif %} {{ node.typeName.name }}()
    {
    }
    #pragma warning restore CS8618
    {% for prop in node.properties %}    
    {{ renderSummary(prop) | safe }}
    public {{ renderPropertyModifier(prop) }}{{ renderType(prop) | safe }} {{ renderPropertyName(prop) }} { get; set; }{{ renderDefault(prop) | safe }}
    {% endfor %}

    #region Load Methods

    /// <summary>
    /// Load a {{ node.typeName.name }} instance from a dictionary.
    /// </summary>
    /// <param name="data">The dictionary containing the data.</param>
    /// <param name="context">Optional context with pre/post processing callbacks.</param>
    /// <returns>The loaded {{ node.typeName.name }} instance.</returns>
    public {% if node.base %}new {% endif %}static {{ node.typeName.name }} Load(Dictionary<string, object?> data, LoadContext? context = null)
    {
        if (context is not null)
        {
            data = context.ProcessInput(data);
        }
        {% if alternates.length > 0 %}
        // Note: Alternate (shorthand) representations are handled by the converter
        {% endif %}
        {% if polymorphicTypes %}
        // Load polymorphic {{ node.typeName.name }} instance
        var instance = Load{{ renderPropertyName({ name: node.discriminator }) }}(data, context);
        {% else %}
        // Create new instance
        var instance = new {{ node.typeName.name }}();
        {% endif %}
        {% for prop in node.properties %}
        if (data.TryGetValue("{{ prop.name }}", out var {{ prop.name }}Value) && {{ prop.name }}Value is not null)
        {
            {{ renderLoadProperty(prop) | safe }}
        }
        {% endfor %}
        if (context is not null)
        {
            instance = context.ProcessOutput(instance);
        }
        return instance;
    }
    {% for collection in collectionTypes %}

    /// <summary>
    /// Load a list of {{ collection.prop.typeName.name }} from a dictionary or list.
    /// </summary>
    public static IList<{{ collection.prop.typeName.name }}> Load{{ renderPropertyName(collection.prop) }}(object data, LoadContext? context)
    {
        var result = new List<{{ collection.prop.typeName.name }}>();
        
        if (data is Dictionary<string, object?> dict)
        {
            // Convert named dictionary to list
            foreach (var kvp in dict)
            {
                if (kvp.Value is Dictionary<string, object?> itemDict)
                {
                    // Value is an object, add name to it
                    itemDict["name"] = kvp.Key;
                    result.Add({{ collection.prop.typeName.name }}.Load(itemDict, context));
                }
                else
                {
                    // Value is a scalar, use it as the primary property
                    var newDict = new Dictionary<string, object?>
                    {
                        ["name"] = kvp.Key,
                        ["{{ collection.type[0] }}"] = kvp.Value
                    };
                    result.Add({{ collection.prop.typeName.name }}.Load(newDict, context));
                }
            }
        }
        else if (data is IEnumerable<object> list)
        {
            foreach (var item in list)
            {
                if (item is Dictionary<string, object?> itemDict)
                {
                    result.Add({{ collection.prop.typeName.name }}.Load(itemDict, context));
                }
            }
        }
        
        return result;
    }
    {% endfor %}
    {% if polymorphicTypes %}

    /// <summary>
    /// Load polymorphic {{ node.typeName.name }} based on discriminator.
    /// </summary>
    private static {{ node.typeName.name }} Load{{ renderPropertyName({ name: node.discriminator }) }}(Dictionary<string, object?> data, LoadContext? context)
    {
        if (data.TryGetValue("{{ node.discriminator }}", out var discriminatorValue) && discriminatorValue is not null)
        {
            var discriminator = discriminatorValue.ToString()?.ToLowerInvariant();
            return discriminator switch
            {
                {%- for type in polymorphicTypes.types %}
                "{{ type.value }}" => {{ type.instance.typeName.name }}.Load(data, context),
                {%- endfor %}
                {%- if polymorphicTypes.default %}
                {%- if polymorphicTypes.default.instance.typeName.name == node.typeName.name %}
                _ => new {{ node.typeName.name }}(),
                {%- else %}
                _ => {{ polymorphicTypes.default.instance.typeName.name }}.Load(data, context),
                {%- endif %}
                {%- else %}
                _ => throw new ArgumentException($"Unknown {{ node.typeName.name }} discriminator value: {discriminator}"),
                {%- endif %}
            };
        }
        {% if node.isAbstract %}
        throw new ArgumentException("Missing {{ node.typeName.name }} discriminator property: '{{ node.discriminator }}'");
        {% else %}
        return new {{ node.typeName.name }}();
        {% endif %}
    }
    {% endif %}

    #endregion

    #region Save Methods

    /// <summary>
    /// Save the {{ node.typeName.name }} instance to a dictionary.
    /// </summary>
    /// <param name="context">Optional context with pre/post processing callbacks.</param>
    /// <returns>The dictionary representation of this instance.</returns>
    public {% if node.base %}override {% elif node.childTypes.length > 0 %}virtual {% endif %}Dictionary<string, object?> Save(SaveContext? context = null)
    {
        var obj = this;
        if (context is not null)
        {
            obj = context.ProcessObject(obj);
        }

        {% if node.base %}
        // Start with parent class properties
        var result = base.Save(context);
        {% else %}
        var result = new Dictionary<string, object?>();
        {% endif %}
        {% for prop in node.properties %}
        if (obj.{{ renderPropertyName(prop) }} is not null)
        {
            {{ renderSaveProperty(prop) | safe }}
        }
        {% endfor %}
        {% if not node.base %}
        if (context is not null)
        {
            result = context.ProcessDict(result);
        }
        {% endif %}
        return result;
    }
    {% for collection in collectionTypes %}

    /// <summary>
    /// Save a list of {{ collection.prop.typeName.name }} to object or array format.
    /// </summary>
    public static object Save{{ renderPropertyName(collection.prop) }}(IList<{{ collection.prop.typeName.name }}> items, SaveContext? context)
    {
        context ??= new SaveContext();
{% if collection.hasNameProperty %}
        if (context.CollectionFormat == "array")
        {
            return items.Select(item => item.Save(context)).ToList();
        }

        // Object format: use name as key
        var result = new Dictionary<string, object?>();
        foreach (var item in items)
        {
            var itemData = item.Save(context);
            if (itemData.TryGetValue("name", out var nameValue) && nameValue is string name)
            {
                itemData.Remove("name");
                
                // Check if we can use shorthand
                if (context.UseShorthand && {{ collection.prop.typeName.name }}.ShorthandProperty is string shorthandProp)
                {
                    if (itemData.Count == 1 && itemData.ContainsKey(shorthandProp))
                    {
                        result[name] = itemData[shorthandProp];
                        continue;
                    }
                }
                result[name] = itemData;
            }
            else
            {
                // No name, can't use object format for this item
                throw new InvalidOperationException("Cannot save item in object format: missing 'name' property");
            }
        }
        return result;
{% else %}
        // This collection type has no 'name' property, always use array format
        return items.Select(item => item.Save(context)).ToList();
{% endif %}
    }
    {% endfor %}

    /// <summary>
    /// Convert the {{ node.typeName.name }} instance to a YAML string.
    /// </summary>
    /// <param name="context">Optional context with pre/post processing callbacks.</param>
    /// <returns>The YAML string representation of this instance.</returns>
    public {% if node.base %}new {% endif %}string ToYaml(SaveContext? context = null)
    {
        context ??= new SaveContext();
        return context.ToYaml(Save(context));
    }

    /// <summary>
    /// Convert the {{ node.typeName.name }} instance to a JSON string.
    /// </summary>
    /// <param name="context">Optional context with pre/post processing callbacks.</param>
    /// <param name="indent">Whether to indent the output. Defaults to true.</param>
    /// <returns>The JSON string representation of this instance.</returns>
    public {% if node.base %}new {% endif %}string ToJson(SaveContext? context = null, bool indent = true)
    {
        context ??= new SaveContext();
        return context.ToJson(Save(context), indent);
    }

    /// <summary>
    /// Load a {{ node.typeName.name }} instance from a JSON string.
    /// </summary>
    /// <param name="json">The JSON string to parse.</param>
    /// <param name="context">Optional context with pre/post processing callbacks.</param>
    /// <returns>The loaded {{ node.typeName.name }} instance.</returns>
    public {% if node.base %}new {% endif %}static {{ node.typeName.name }} FromJson(string json, LoadContext? context = null)
    {
        using var doc = JsonDocument.Parse(json);
        Dictionary<string, object?> dict;
        
        {%- if alternates.length > 0 or numericAlternates.length > 0 %}
        // Handle alternate representations
        if (doc.RootElement.ValueKind != JsonValueKind.Object)
        {
            var value = JsonUtils.GetJsonElementValue(doc.RootElement);
            dict = value switch
            {
                {%- for alt in alternates %}
                {{ alt.scalar }} {{ alt.scalar | lower }}Value => new Dictionary<string, object?>
                {
                    {%- for item in alt.expansion %}
                    ["{{ item.property | lower | replace(".", "") }}"] = {{ item.value | safe }},
                    {%- endfor %}
                },
                {%- endfor %}
                {%- for alt in numericAlternates %}
                {{ alt.scalar }} {{ alt.scalar | lower }}Value => new Dictionary<string, object?>
                {
                    {%- for item in alt.expansion %}
                    ["{{ item.property | lower | replace(".", "") }}"] = {{ item.value | safe }},
                    {%- endfor %}
                },
                {%- endfor %}
                {%- if intAlternate %}
                long longValue => new Dictionary<string, object?>
                {
                    {%- for item in intAlternate.expansion %}
                    ["{{ item.property | lower | replace(".", "") }}"] = {% if "Value" in item.value %}longValue{% else %}{{ item.value | safe }}{% endif %},
                    {%- endfor %}
                },
                {%- endif %}
                {%- if floatAlternate %}
                double doubleValue => new Dictionary<string, object?>
                {
                    {%- for item in floatAlternate.expansion %}
                    ["{{ item.property | lower | replace(".", "") }}"] = {% if "Value" in item.value %}doubleValue{% else %}{{ item.value | safe }}{% endif %},
                    {%- endfor %}
                },
                {%- endif %}
                {%- if shorthandProperty %}
                _ => new Dictionary<string, object?>
                {
                    ["{{ shorthandProperty }}"] = value
                }
                {%- else %}
                _ => throw new ArgumentException($"Cannot convert value of type {value?.GetType().Name} to {{ node.typeName.name }}")
                {%- endif %}
            };
        }
        else
        {
            dict = JsonSerializer.Deserialize<Dictionary<string, object?>>(json, JsonUtils.Options)
                ?? throw new ArgumentException("Failed to parse JSON as dictionary");
        }
        {%- elif shorthandProperty %}
        // Handle shorthand representation
        if (doc.RootElement.ValueKind != JsonValueKind.Object)
        {
            dict = new Dictionary<string, object?>
            {
                ["{{ shorthandProperty }}"] = JsonUtils.GetJsonElementValue(doc.RootElement)
            };
        }
        else
        {
            dict = JsonSerializer.Deserialize<Dictionary<string, object?>>(json, JsonUtils.Options)
                ?? throw new ArgumentException("Failed to parse JSON as dictionary");
        }
        {%- else %}
        dict = JsonSerializer.Deserialize<Dictionary<string, object?>>(json, JsonUtils.Options)
            ?? throw new ArgumentException("Failed to parse JSON as dictionary");
        {%- endif %}
        
        return Load(dict, context);
    }

    /// <summary>
    /// Load a {{ node.typeName.name }} instance from a YAML string.
    /// </summary>
    /// <param name="yaml">The YAML string to parse.</param>
    /// <param name="context">Optional context with pre/post processing callbacks.</param>
    /// <returns>The loaded {{ node.typeName.name }} instance.</returns>
    public {% if node.base %}new {% endif %}static {{ node.typeName.name }} FromYaml(string yaml, LoadContext? context = null)
    {
        {%- if alternates.length > 0 or numericAlternates.length > 0 %}
        // Handle alternate representations - try object first, fall back to scalar
        Dictionary<string, object?>? dictResult = null;
        try
        {
            dictResult = YamlUtils.Deserializer.Deserialize<Dictionary<string, object?>>(yaml);
        }
        catch (YamlDotNet.Core.YamlException)
        {
            // Not a dictionary, will be handled as scalar below
        }
        
        Dictionary<string, object?> dict;
        if (dictResult is not null)
        {
            dict = dictResult;
        }
        else
        {
            // Parse as scalar with proper type inference
            var parsed = YamlUtils.ParseScalar(yaml);
            dict = parsed switch
            {
                {%- for alt in alternates %}
                {{ alt.scalar }} {{ alt.scalar | lower }}Value => new Dictionary<string, object?>
                {
                    {%- for item in alt.expansion %}
                    ["{{ item.property | lower | replace(".", "") }}"] = {{ item.value | safe }},
                    {%- endfor %}
                },
                {%- endfor %}
                {%- for alt in numericAlternates %}
                {{ alt.scalar }} {{ alt.scalar | lower }}Value => new Dictionary<string, object?>
                {
                    {%- for item in alt.expansion %}
                    ["{{ item.property | lower | replace(".", "") }}"] = {{ item.value | safe }},
                    {%- endfor %}
                },
                {%- endfor %}
                {%- if intAlternate %}
                long longValue => new Dictionary<string, object?>
                {
                    {%- for item in intAlternate.expansion %}
                    ["{{ item.property | lower | replace(".", "") }}"] = {% if "Value" in item.value %}longValue{% else %}{{ item.value | safe }}{% endif %},
                    {%- endfor %}
                },
                {%- endif %}
                {%- if floatAlternate %}
                double doubleValue => new Dictionary<string, object?>
                {
                    {%- for item in floatAlternate.expansion %}
                    ["{{ item.property | lower | replace(".", "") }}"] = {% if "Value" in item.value %}doubleValue{% else %}{{ item.value | safe }}{% endif %},
                    {%- endfor %}
                },
                {%- endif %}
                {%- if shorthandProperty %}
                _ => new Dictionary<string, object?>
                {
                    ["{{ shorthandProperty }}"] = parsed
                }
                {%- else %}
                _ => throw new ArgumentException($"Cannot convert value of type {parsed?.GetType().Name} to {{ node.typeName.name }}")
                {%- endif %}
            };
        }
        {%- elif shorthandProperty %}
        // Handle shorthand representation - try object first, fall back to scalar
        Dictionary<string, object?>? dictResult = null;
        try
        {
            dictResult = YamlUtils.Deserializer.Deserialize<Dictionary<string, object?>>(yaml);
        }
        catch (YamlDotNet.Core.YamlException)
        {
            // Not a dictionary, will be handled as scalar below
        }
        
        Dictionary<string, object?> dict;
        if (dictResult is not null)
        {
            dict = dictResult;
        }
        else
        {
            // Shorthand representation - wrap the value with proper type inference
            dict = new Dictionary<string, object?>
            {
                ["{{ shorthandProperty }}"] = YamlUtils.ParseScalar(yaml)
            };
        }
        {%- else %}
        var dict = YamlUtils.Deserializer.Deserialize<Dictionary<string, object?>>(yaml)
            ?? throw new ArgumentException("Failed to parse YAML as dictionary");
        {%- endif %}
        
        return Load(dict, context);
    }

    #endregion
}
