{#
  TypeScript File Template
  ========================
  Renders a complete TypeScript file containing one or more classes.
  
  Expected context (TypeScriptFileContext):
    - containsAbstract: boolean
    - imports: string[]
    - classes: TypeScriptClassContext[]
    - typeMapper: Record<string, string>
    - namespace: string
    - toKebabCase: function
#}
{%- import "_macros.njk" as ts -%}
// Copyright (c) Microsoft. All rights reserved.
// WARNING: This is an auto-generated file. DO NOT EDIT THIS FILE DIRECTLY.

import { LoadContext, SaveContext } from "./context";
{%- for import in imports %}
import { {{ import }} } from "./{{ toKebabCase(import) }}";
{%- endfor %}

{% for classCtx in classes %}
{%- set node = classCtx.node -%}
{%- set typeMapper = classCtx.typeMapper -%}
{%- set alternates = classCtx.alternates -%}
{%- set polymorphicTypes = classCtx.polymorphicTypes -%}
{%- set collectionTypes = classCtx.collectionTypes %}

/**
 * {% for line in node.description.split('\n') %}{{ line }}
 * {% endfor %}
 */
export {% if node.isAbstract %}abstract {% endif %}class {{ node.typeName.name }}{% if node.base %} extends {{ node.base.name }}{% endif %} {
  /**
   * The shorthand property name for this type, if any.
   */
  static readonly shorthandProperty: string | undefined = {% if classCtx.shorthandProperty %}"{{ classCtx.shorthandProperty }}"{% else %}undefined{% endif %};

  {% for prop in node.properties %}
  /**
   * {{ prop.description }}
   */
  {{ prop.name }}{% if prop.isOptional %}?{% endif %}: {{ ts.tsType(prop, typeMapper) }}{{ ts.defaultValue(prop, typeMapper) }};
  {% endfor %}

  /**
   * Initializes a new instance of {{ node.typeName.name }}.
   */
  constructor(init?: Partial<{{ node.typeName.name }}>) {
    {% if node.base %}super(init);{% endif %}
    {% for prop in node.properties %}
    {% if not prop.isOptional %}
    this.{{ prop.name }} = init?.{{ prop.name }} ?? {{ ts.defaultInitValue(prop, typeMapper) }};
    {% else %}
    if (init?.{{ prop.name }} !== undefined) {
      this.{{ prop.name }} = init.{{ prop.name }};
    }
    {% endif %}
    {%- endfor %}
  }

  //#region Load Methods

  /**
   * Load a {{ node.typeName.name }} instance from a dictionary.
   * @param data - The dictionary containing the data.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded {{ node.typeName.name }} instance.
   */
  static load(data: Record<string, unknown>, context?: LoadContext): {{ node.typeName.name }} {
    if (context) {
      data = context.processInput(data);
    }
    {% if alternates.length > 0 %}
    // Handle alternate representations
    if (typeof data === "string") {
      {%- for alt in alternates %}{% if alt.scalar == "string" %}
      data = {{ alt.alternate }};
      {%- endif %}{% endfor %}
    } else if (typeof data === "number") {
      {%- for alt in alternates %}{% if alt.scalar == "number" %}
      // Check if it's an integer or float
      if (Number.isInteger(data)) {
        {%- for intAlt in alternates %}{% if intAlt.scalar == "number" and "integer" in intAlt.alternate %}
        data = {{ intAlt.alternate }};
        {%- endif %}{% endfor %}
      } else {
        {%- for floatAlt in alternates %}{% if floatAlt.scalar == "number" and "float" in floatAlt.alternate %}
        data = {{ floatAlt.alternate }};
        {%- endif %}{% endfor %}
      }
      {%- endif %}{% endfor %}
    } else if (typeof data === "boolean") {
      {%- for alt in alternates %}{% if alt.scalar == "boolean" %}
      data = {{ alt.alternate }};
      {%- endif %}{% endfor %}
    }
    {% endif %}
    {% if polymorphicTypes %}
    // Load polymorphic {{ node.typeName.name }} instance
    const instance = {{ node.typeName.name }}.load{{ ts.pascalCase(node.discriminator) }}(data, context);
    {% else %}
    // Create new instance
    const instance = new {{ node.typeName.name }}();
    {% endif %}
    {% for prop in node.properties %}
    if (data["{{ prop.name }}"] !== undefined && data["{{ prop.name }}"] !== null) {
      {{ ts.loadProperty(prop, "instance", "data", classCtx) }}
    }
    {% endfor %}
    if (context) {
      return context.processOutput(instance) as {{ node.typeName.name }};
    }
    return instance;
  }
  {% for collection in collectionTypes %}

  /**
   * Load a collection of {{ collection.prop.typeName.name }} from a dictionary or array.
   * @param data - The data to load from.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded array of {{ collection.prop.typeName.name }}.
   */
  static load{{ ts.pascalCase(collection.prop.name) }}(data: unknown, context?: LoadContext): {{ collection.prop.typeName.name }}[] {
    const result: {{ collection.prop.typeName.name }}[] = [];

    if (data && typeof data === "object" && !Array.isArray(data)) {
      // Convert named dictionary to array
      for (const [key, value] of Object.entries(data as Record<string, unknown>)) {
        if (value && typeof value === "object" && !Array.isArray(value)) {
          // Value is an object, add name to it
          (value as Record<string, unknown>)["name"] = key;
          result.push({{ collection.prop.typeName.name }}.load(value as Record<string, unknown>, context));
        } else {
          // Value is a scalar, use it as the primary property
          const newObj: Record<string, unknown> = {
            name: key,
            {% if collection.type[0] %}"{{ collection.type[0] }}": value{% endif %}
          };
          result.push({{ collection.prop.typeName.name }}.load(newObj, context));
        }
      }
    } else if (Array.isArray(data)) {
      for (const item of data) {
        if (item && typeof item === "object") {
          result.push({{ collection.prop.typeName.name }}.load(item as Record<string, unknown>, context));
        }
      }
    }

    return result;
  }
  {% endfor %}
  {% if polymorphicTypes %}

  /**
   * Load polymorphic {{ node.typeName.name }} based on discriminator.
   * @param data - The dictionary containing the data.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded {{ node.typeName.name }} instance.
   */
  private static load{{ ts.pascalCase(node.discriminator) }}(data: Record<string, unknown>, context?: LoadContext): {{ node.typeName.name }} {
    const discriminatorValue = data["{{ node.discriminator }}"];
    if (discriminatorValue !== undefined && discriminatorValue !== null) {
      const discriminator = String(discriminatorValue).toLowerCase();
      switch (discriminator) {
        {%- for type in polymorphicTypes.types %}
        case "{{ type.value }}":
          return {{ type.instance.typeName.name }}.load(data, context);
        {%- endfor %}
        default:
          {%- if polymorphicTypes.default %}
          {%- if polymorphicTypes.default.instance.typeName.name == node.typeName.name %}
          return new {{ node.typeName.name }}();
          {%- else %}
          return {{ polymorphicTypes.default.instance.typeName.name }}.load(data, context);
          {%- endif %}
          {%- else %}
          throw new Error(`Unknown {{ node.typeName.name }} discriminator value: ${discriminator}`);
          {%- endif %}
      }
    }
    {% if node.isAbstract %}
    throw new Error("Missing {{ node.typeName.name }} discriminator property: '{{ node.discriminator }}'");
    {% else %}
    return new {{ node.typeName.name }}();
    {% endif %}
  }
  {% endif %}

  //#endregion

  //#region Save Methods

  /**
   * Save the {{ node.typeName.name }} instance to a dictionary.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The dictionary representation of this instance.
   */
  save(context?: SaveContext): Record<string, unknown> {
    const obj = context ? context.processObject(this) as {{ node.typeName.name }} : this;

    {% if node.base %}
    // Start with parent class properties
    const result = super.save(context);
    {% else %}
    const result: Record<string, unknown> = {};
    {% endif %}
    {% for prop in node.properties %}
    if (obj.{{ prop.name }} !== undefined && obj.{{ prop.name }} !== null) {
      {{ ts.saveProperty(prop, "obj", "result", classCtx) }}
    }
    {% endfor %}
    {% if not node.base %}
    if (context) {
      return context.processDict(result);
    }
    {% endif %}
    return result;
  }
  {% for collection in collectionTypes %}

  /**
   * Save a collection of {{ collection.prop.typeName.name }} to object or array format.
   * @param items - The items to save.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The saved collection in object or array format.
   */
  static save{{ ts.pascalCase(collection.prop.name) }}(items: {{ collection.prop.typeName.name }}[], context?: SaveContext): Record<string, unknown> | Record<string, unknown>[] {
    context = context ?? new SaveContext();
{% if collection.hasNameProperty %}
    if (context.collectionFormat === "array") {
      return items.map((item) => item.save(context));
    }

    // Object format: use name as key
    const result: Record<string, unknown> = {};
    for (const item of items) {
      const itemData = item.save(context);
      const name = itemData["name"] as string | undefined;
      if (name) {
        delete itemData["name"];

        // Check if we can use shorthand
        if (context.useShorthand && {{ collection.prop.typeName.name }}.shorthandProperty) {
          const shorthandProp = {{ collection.prop.typeName.name }}.shorthandProperty;
          const keys = Object.keys(itemData);
          if (keys.length === 1 && keys[0] === shorthandProp) {
            result[name] = itemData[shorthandProp];
            continue;
          }
        }
        result[name] = itemData;
      } else {
        throw new Error("Cannot save item in object format: missing 'name' property");
      }
    }
    return result;
{% else %}
    // This type doesn't have a 'name' property, so always use array format
    return items.map((item) => item.save(context));
{% endif %}
  }
  {% endfor %}

  /**
   * Convert the {{ node.typeName.name }} instance to a YAML string.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The YAML string representation of this instance.
   */
  toYaml(context?: SaveContext): string {
    context = context ?? new SaveContext();
    return context.toYaml(this.save(context));
  }

  /**
   * Convert the {{ node.typeName.name }} instance to a JSON string.
   * @param context - Optional context with pre/post processing callbacks.
   * @param indent - Number of spaces for indentation. Defaults to 2.
   * @returns The JSON string representation of this instance.
   */
  toJson(context?: SaveContext, indent: number = 2): string {
    context = context ?? new SaveContext();
    return context.toJson(this.save(context), indent);
  }

  /**
   * Load a {{ node.typeName.name }} instance from a JSON string.
   * @param json - The JSON string to parse.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded {{ node.typeName.name }} instance.
   */
  static fromJson(json: string, context?: LoadContext): {{ node.typeName.name }} {
    const data = JSON.parse(json);
    {% if alternates.length > 0 %}
    // Handle alternate representations
    if (typeof data !== "object" || data === null || Array.isArray(data)) {
      if (typeof data === "string") {
        {%- for alt in alternates %}{% if alt.scalar == "string" %}
        return {{ node.typeName.name }}.load({{ alt.alternate }}, context);
        {%- endif %}{% endfor %}
      } else if (typeof data === "number") {
        // Check if it's an integer or float
        if (Number.isInteger(data)) {
          {%- for intAlt in alternates %}{% if intAlt.scalar == "number" and "integer" in intAlt.alternate %}
          return {{ node.typeName.name }}.load({{ intAlt.alternate }}, context);
          {%- endif %}{% endfor %}
        } else {
          {%- for floatAlt in alternates %}{% if floatAlt.scalar == "number" and "float" in floatAlt.alternate %}
          return {{ node.typeName.name }}.load({{ floatAlt.alternate }}, context);
          {%- endif %}{% endfor %}
        }
      } else if (typeof data === "boolean") {
        {%- for alt in alternates %}{% if alt.scalar == "boolean" %}
        return {{ node.typeName.name }}.load({{ alt.alternate }}, context);
        {%- endif %}{% endfor %}
      }
      // Fallback - shouldn't reach here
      {%- for alt in alternates %}{% if loop.first %}
      return {{ node.typeName.name }}.load({{ alt.alternate }}, context);
      {%- endif %}{% endfor %}
    }
    {% endif %}
    return {{ node.typeName.name }}.load(data as Record<string, unknown>, context);
  }

  /**
   * Load a {{ node.typeName.name }} instance from a YAML string.
   * @param yaml - The YAML string to parse.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded {{ node.typeName.name }} instance.
   */
  static fromYaml(yaml: string, context?: LoadContext): {{ node.typeName.name }} {
    const { parse } = require("yaml");
    const data = parse(yaml);
    {% if alternates.length > 0 %}
    // Handle alternate representations
    if (typeof data !== "object" || data === null || Array.isArray(data)) {
      if (typeof data === "string") {
        {%- for alt in alternates %}{% if alt.scalar == "string" %}
        return {{ node.typeName.name }}.load({{ alt.alternate }}, context);
        {%- endif %}{% endfor %}
      } else if (typeof data === "number") {
        // Check if it's an integer or float
        if (Number.isInteger(data)) {
          {%- for intAlt in alternates %}{% if intAlt.scalar == "number" and "integer" in intAlt.alternate %}
          return {{ node.typeName.name }}.load({{ intAlt.alternate }}, context);
          {%- endif %}{% endfor %}
        } else {
          {%- for floatAlt in alternates %}{% if floatAlt.scalar == "number" and "float" in floatAlt.alternate %}
          return {{ node.typeName.name }}.load({{ floatAlt.alternate }}, context);
          {%- endif %}{% endfor %}
        }
      } else if (typeof data === "boolean") {
        {%- for alt in alternates %}{% if alt.scalar == "boolean" %}
        return {{ node.typeName.name }}.load({{ alt.alternate }}, context);
        {%- endif %}{% endfor %}
      }
      // Fallback - shouldn't reach here
      {%- for alt in alternates %}{% if loop.first %}
      return {{ node.typeName.name }}.load({{ alt.alternate }}, context);
      {%- endif %}{% endfor %}
    }
    {% endif %}
    return {{ node.typeName.name }}.load(data as Record<string, unknown>, context);
  }

  //#endregion
}
{% endfor %}
