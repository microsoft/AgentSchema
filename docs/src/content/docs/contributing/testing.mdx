---
title: Testing Guide
description: How to run and write tests for AgentSchema
sidebar:
  order: 5
---

import { Tabs, TabItem } from '@astrojs/starlight/components';

Tests are auto-generated for runtime libraries based on `@sample` decorators in TypeSpec. This guide covers running tests, test standards, and how to add new test coverage.

## Test Standards

**All AgentSchema runtimes must implement identical test coverage.** The test categories are universal across TypeScript, Python, C#, and Go—only the syntax differs.

### Required Test Categories

Every generated test file must include:

| Category | Description |
|----------|-------------|
| **JSON Load** | Parse JSON string into model instance |
| **YAML Load** | Parse YAML string into model instance |
| **JSON Round-trip** | Load → toJson → fromJson → compare |
| **YAML Round-trip** | Load → toYaml → fromYaml → compare |
| **JSON Output** | Verify `toJson()` produces valid JSON |
| **YAML Output** | Verify `toYaml()` produces valid YAML |
| **JSON Shorthand** | Load scalar via JSON (if `@shorthand` defined) |
| **YAML Shorthand** | Load scalar via YAML (if `@shorthand` defined) |
| **Dictionary Load** | Load from empty dict/map (tests defaults) |
| **Dictionary Save** | Save to dict/map |

### Context Tests

Each runtime also includes tests for `LoadContext` and `SaveContext` utility classes:

| Runtime | Test File |
|---------|-----------|
| TypeScript | `tests/context.test.ts` |
| Python | `tests/test_context.py` |
| C# | `AgentSchema.Tests/ContextTests.cs` |
| Go | `context_test.go` |

### Expected Test Counts

All runtimes should have similar test counts (within ~5% of each other):

- **~350 tests** per runtime
- **~37 type test files** + 1 context test file
- **~8-10 tests per type** (varies by samples/alternates)

## Running Tests

### All Runtimes

```bash
# Quick test script (from repo root)
./tests.ps1
```

### Individual Runtimes

<Tabs syncKey="language">
  <TabItem label=".NET" icon="seti:c-sharp">
    ```bash
    cd runtime/csharp
    dotnet test                           # All tests
    dotnet test --filter "ClassName"      # Specific class
    ```
  </TabItem>
  <TabItem label="Python" icon="seti:python">
    ```bash
    cd runtime/python/agentschema
    uv run pytest tests/                  # All tests
    uv run pytest tests/test_model.py     # Specific file
    uv run pytest -v                      # Verbose output
    ```
  </TabItem>
  <TabItem label="TypeScript" icon="seti:typescript">
    ```bash
    cd runtime/typescript/agentschema
    npm test                              # All tests
    npm test -- --grep "Model"            # Filter by name
    ```
  </TabItem>
  <TabItem label="Go" icon="seti:go">
    ```bash
    cd runtime/go/agentschema
    go test ./...                         # All tests
    go test -run "TestModel"              # Filter by name
    go test -v ./...                      # Verbose output
    ```
  </TabItem>
</Tabs>

## Test Architecture

Tests are generated from `@sample` decorators in TypeSpec files:

```mermaid
flowchart LR
    A["@sample decorator"] --> B[Emitter]
    B --> C[test_*.py]
    B --> D[*Tests.cs]
    B --> E[*.test.ts]
    B --> F[*_test.go]
    C --> G[pytest]
    D --> H[dotnet test]
    E --> I[jest]
    F --> J[go test]
```

### Test File Naming Convention

| Runtime | Pattern | Example |
|---------|---------|---------|
| TypeScript | `{type-name}.test.ts` | `binding.test.ts` |
| Python | `test_{typename}.py` | `test_binding.py` |
| C# | `{TypeName}Tests.cs` | `BindingTests.cs` |
| Go | `{type_name}_test.go` | `binding_test.go` |

### Example Generated Test (Python)

```python
def test_load_json_model():
    json_data = '''
    {
      "id": "gpt-4",
      "provider": "azure"
    }
    '''
    data = json.loads(json_data)
    instance = Model.load(data)
    assert instance is not None
    assert instance.id == "gpt-4"
    assert instance.provider == "azure"

def test_roundtrip_json_model():
    json_data = '''{"id": "gpt-4", "provider": "azure"}'''
    original = json.loads(json_data)
    instance = Model.load(original)
    saved = instance.save()
    reloaded = Model.load(saved)
    assert reloaded.id == instance.id
```

## Adding Test Coverage

### Via @sample Decorators

The best way to add test coverage is through `@sample` decorators:

```typespec
model MyModel {
  @doc("Name of the model")
  @sample(#{ name: "test-model" })      // Generates test with this value
  @sample(#{ name: "another-model" })   // Multiple samples = multiple tests
  name: string;
}
```

### Test Combinations

When a model has multiple properties with `@sample`, the emitter generates test combinations:

```typespec
model Example {
  @sample(#{ a: "value1" })
  @sample(#{ a: "value2" })
  a: string;
  
  @sample(#{ b: 1 })
  @sample(#{ b: 2 })
  b: int32;
}
// Generates 4 tests: (value1, 1), (value1, 2), (value2, 1), (value2, 2)
```

## Manual Test Files

Some tests are not auto-generated and can be edited:

| Runtime | Location | Notes |
|---------|----------|-------|
| C# | `runtime/csharp/AgentSchema.Tests/` | Project files are preserved |
| Python | `runtime/python/agentschema/tests/` | `conftest.py` is preserved |
| TypeScript | `runtime/typescript/agentschema/tests/` | Config files are preserved |
| Go | `runtime/go/agentschema/` | `go.mod` is preserved |

:::caution
Test files matching `test_*.py`, `*Tests.cs`, `*.test.ts`, or `*_test.go` patterns ARE regenerated. Add custom tests with different naming patterns.
:::

## Test Validation Patterns

### Property Assertions

Tests validate scalar properties from `@sample` values:

```python
# Python
assert instance.name == "expected-value"
assert instance.count == 42
assert instance.enabled == True

# TypeScript
expect(instance.name).toEqual("expected-value");

# C#
Assert.Equal("expected-value", instance.Name);

# Go
if instance.Name != "expected-value" {
    t.Errorf("Expected name to be 'expected-value', got %v", instance.Name)
}
```

### Type Checks

```python
# Python
assert isinstance(instance.items, list)

# TypeScript  
expect(Array.isArray(instance.items)).toBe(true);

# C#
Assert.IsType<List<string>>(instance.Items);

# Go
if len(instance.Items) == 0 {
    t.Error("Expected items to be non-empty")
}
```

## Debugging Test Failures

### 1. Check the Sample Values

Ensure `@sample` values in TypeSpec are valid:

```typespec
// ❌ Wrong - sample doesn't match property
@sample(#{ wrongName: "value" })
name: string;

// ✅ Correct
@sample(#{ name: "value" })
name: string;
```

### 2. Regenerate Tests

```bash
cd agentschema && npm run generate
```

### 3. Check Generated Test File

Look at the actual generated test to understand what's being tested:

```bash
# Python
cat runtime/python/agentschema/tests/test_load_model.py

# TypeScript
cat runtime/typescript/agentschema/tests/model.test.ts
```

### 4. Run Single Test with Verbose Output

```bash
# Python
uv run pytest tests/test_load_model.py::test_load_json_model -v

# TypeScript
npm test -- --grep "Model" --reporter verbose

# C#
dotnet test --filter "ModelConversionTests" --logger "console;verbosity=detailed"

# Go
go test -v -run "TestModel" ./...
```

## CI/CD

Tests run automatically on:

- Pull requests
- Pushes to main branch

See `.github/workflows/` for CI configuration.
