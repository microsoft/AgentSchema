// Copyright (c) Microsoft. All rights reserved.
// WARNING: This is an auto-generated file. DO NOT EDIT THIS FILE DIRECTLY.

import { LoadContext, SaveContext } from "./context";
import { Binding } from "./binding";
import { Connection } from "./connection";
import { McpServerApprovalMode } from "./mcp-server-approval-mode";
import { PropertySchema } from "./property-schema";

/**
 * Represents a tool that can be used in prompts.
 *
 */
export abstract class Tool {
  /**
   * The shorthand property name for this type, if any.
   */
  static readonly shorthandProperty: string | undefined = undefined;

  /**
   * Name of the tool. If a function tool, this is the function name, otherwise it is the type
   */
  name: string = "";

  /**
   * The kind identifier for the tool
   */
  kind: string = "";

  /**
   * A short description of the tool for metadata purposes
   */
  description?: string | undefined;

  /**
   * Tool argument bindings to input properties
   */
  bindings?: Binding[] = [];

  /**
   * Initializes a new instance of Tool.
   */
  constructor(init?: Partial<Tool>) {
    this.name = init?.name ?? "";

    this.kind = init?.kind ?? "";

    if (init?.description !== undefined) {
      this.description = init.description;
    }

    if (init?.bindings !== undefined) {
      this.bindings = init.bindings;
    }
  }

  //#region Load Methods

  /**
   * Load a Tool instance from a dictionary.
   * @param data - The dictionary containing the data.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded Tool instance.
   */
  static load(data: Record<string, unknown>, context?: LoadContext): Tool {
    if (context) {
      data = context.processInput(data);
    }

    // Load polymorphic Tool instance
    const instance = Tool.loadKind(data, context);

    if (data["name"] !== undefined && data["name"] !== null) {
      instance.name = String(data["name"]);
    }

    if (data["kind"] !== undefined && data["kind"] !== null) {
      instance.kind = String(data["kind"]);
    }

    if (data["description"] !== undefined && data["description"] !== null) {
      instance.description = String(data["description"]);
    }

    if (data["bindings"] !== undefined && data["bindings"] !== null) {
      instance.bindings = Tool.loadBindings(data["bindings"], context);
    }

    if (context) {
      return context.processOutput(instance) as Tool;
    }
    return instance;
  }

  /**
   * Load a collection of Binding from a dictionary or array.
   * @param data - The data to load from.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded array of Binding.
   */
  static loadBindings(data: unknown, context?: LoadContext): Binding[] {
    const result: Binding[] = [];

    if (data && typeof data === "object" && !Array.isArray(data)) {
      // Convert named dictionary to array
      for (const [key, value] of Object.entries(data as Record<string, unknown>)) {
        if (value && typeof value === "object" && !Array.isArray(value)) {
          // Value is an object, add name to it
          (value as Record<string, unknown>)["name"] = key;
          result.push(Binding.load(value as Record<string, unknown>, context));
        } else {
          // Value is a scalar, use it as the primary property
          const newObj: Record<string, unknown> = {
            name: key,
            input: value,
          };
          result.push(Binding.load(newObj, context));
        }
      }
    } else if (Array.isArray(data)) {
      for (const item of data) {
        if (item && typeof item === "object") {
          result.push(Binding.load(item as Record<string, unknown>, context));
        }
      }
    }

    return result;
  }

  /**
   * Load polymorphic Tool based on discriminator.
   * @param data - The dictionary containing the data.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded Tool instance.
   */
  private static loadKind(data: Record<string, unknown>, context?: LoadContext): Tool {
    const discriminatorValue = data["kind"];
    if (discriminatorValue !== undefined && discriminatorValue !== null) {
      const discriminator = String(discriminatorValue).toLowerCase();
      switch (discriminator) {
        case "function":
          return FunctionTool.load(data, context);
        case "bing_search":
          return WebSearchTool.load(data, context);
        case "file_search":
          return FileSearchTool.load(data, context);
        case "mcp":
          return McpTool.load(data, context);
        case "openapi":
          return OpenApiTool.load(data, context);
        case "code_interpreter":
          return CodeInterpreterTool.load(data, context);
        default:
          return CustomTool.load(data, context);
      }
    }

    throw new Error("Missing Tool discriminator property: 'kind'");
  }

  //#endregion

  //#region Save Methods

  /**
   * Save the Tool instance to a dictionary.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The dictionary representation of this instance.
   */
  save(context?: SaveContext): Record<string, unknown> {
    const obj = context ? (context.processObject(this) as Tool) : this;

    const result: Record<string, unknown> = {};

    if (obj.name !== undefined && obj.name !== null) {
      result["name"] = obj.name;
    }

    if (obj.kind !== undefined && obj.kind !== null) {
      result["kind"] = obj.kind;
    }

    if (obj.description !== undefined && obj.description !== null) {
      result["description"] = obj.description;
    }

    if (obj.bindings !== undefined && obj.bindings !== null) {
      result["bindings"] = Tool.saveBindings(obj.bindings, context);
    }

    if (context) {
      return context.processDict(result);
    }

    return result;
  }

  /**
   * Save a collection of Binding to object or array format.
   * @param items - The items to save.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The saved collection in object or array format.
   */
  static saveBindings(
    items: Binding[],
    context?: SaveContext
  ): Record<string, unknown> | Record<string, unknown>[] {
    context = context ?? new SaveContext();

    if (context.collectionFormat === "array") {
      return items.map((item) => item.save(context));
    }

    // Object format: use name as key
    const result: Record<string, unknown> = {};
    for (const item of items) {
      const itemData = item.save(context);
      const name = itemData["name"] as string | undefined;
      if (name) {
        delete itemData["name"];

        // Check if we can use shorthand
        if (context.useShorthand && Binding.shorthandProperty) {
          const shorthandProp = Binding.shorthandProperty;
          const keys = Object.keys(itemData);
          if (keys.length === 1 && keys[0] === shorthandProp) {
            result[name] = itemData[shorthandProp];
            continue;
          }
        }
        result[name] = itemData;
      } else {
        throw new Error("Cannot save item in object format: missing 'name' property");
      }
    }
    return result;
  }

  /**
   * Convert the Tool instance to a YAML string.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The YAML string representation of this instance.
   */
  toYaml(context?: SaveContext): string {
    context = context ?? new SaveContext();
    return context.toYaml(this.save(context));
  }

  /**
   * Convert the Tool instance to a JSON string.
   * @param context - Optional context with pre/post processing callbacks.
   * @param indent - Number of spaces for indentation. Defaults to 2.
   * @returns The JSON string representation of this instance.
   */
  toJson(context?: SaveContext, indent: number = 2): string {
    context = context ?? new SaveContext();
    return context.toJson(this.save(context), indent);
  }

  /**
   * Load a Tool instance from a JSON string.
   * @param json - The JSON string to parse.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded Tool instance.
   */
  static fromJson(json: string, context?: LoadContext): Tool {
    const data = JSON.parse(json);

    return Tool.load(data as Record<string, unknown>, context);
  }

  /**
   * Load a Tool instance from a YAML string.
   * @param yaml - The YAML string to parse.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded Tool instance.
   */
  static fromYaml(yaml: string, context?: LoadContext): Tool {
    const { parse } = require("yaml");
    const data = parse(yaml);

    return Tool.load(data as Record<string, unknown>, context);
  }

  //#endregion
}

/**
 * Represents a local function tool.
 *
 */
export class FunctionTool extends Tool {
  /**
   * The shorthand property name for this type, if any.
   */
  static readonly shorthandProperty: string | undefined = undefined;

  /**
   * The kind identifier for function tools
   */
  kind: string = "function";

  /**
   * Parameters accepted by the function tool
   */
  parameters: PropertySchema;

  /**
   * Indicates whether the function tool enforces strict validation on its parameters
   */
  strict?: boolean | undefined;

  /**
   * Initializes a new instance of FunctionTool.
   */
  constructor(init?: Partial<FunctionTool>) {
    super(init);

    this.kind = init?.kind ?? "function";

    this.parameters = init?.parameters ?? undefined!;

    if (init?.strict !== undefined) {
      this.strict = init.strict;
    }
  }

  //#region Load Methods

  /**
   * Load a FunctionTool instance from a dictionary.
   * @param data - The dictionary containing the data.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded FunctionTool instance.
   */
  static load(data: Record<string, unknown>, context?: LoadContext): FunctionTool {
    if (context) {
      data = context.processInput(data);
    }

    // Create new instance
    const instance = new FunctionTool();

    if (data["kind"] !== undefined && data["kind"] !== null) {
      instance.kind = String(data["kind"]);
    }

    if (data["parameters"] !== undefined && data["parameters"] !== null) {
      instance.parameters = PropertySchema.load(
        data["parameters"] as Record<string, unknown>,
        context
      );
    }

    if (data["strict"] !== undefined && data["strict"] !== null) {
      instance.strict = Boolean(data["strict"]);
    }

    if (context) {
      return context.processOutput(instance) as FunctionTool;
    }
    return instance;
  }

  //#endregion

  //#region Save Methods

  /**
   * Save the FunctionTool instance to a dictionary.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The dictionary representation of this instance.
   */
  save(context?: SaveContext): Record<string, unknown> {
    const obj = context ? (context.processObject(this) as FunctionTool) : this;

    // Start with parent class properties
    const result = super.save(context);

    if (obj.kind !== undefined && obj.kind !== null) {
      result["kind"] = obj.kind;
    }

    if (obj.parameters !== undefined && obj.parameters !== null) {
      result["parameters"] = obj.parameters?.save(context);
    }

    if (obj.strict !== undefined && obj.strict !== null) {
      result["strict"] = obj.strict;
    }

    return result;
  }

  /**
   * Convert the FunctionTool instance to a YAML string.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The YAML string representation of this instance.
   */
  toYaml(context?: SaveContext): string {
    context = context ?? new SaveContext();
    return context.toYaml(this.save(context));
  }

  /**
   * Convert the FunctionTool instance to a JSON string.
   * @param context - Optional context with pre/post processing callbacks.
   * @param indent - Number of spaces for indentation. Defaults to 2.
   * @returns The JSON string representation of this instance.
   */
  toJson(context?: SaveContext, indent: number = 2): string {
    context = context ?? new SaveContext();
    return context.toJson(this.save(context), indent);
  }

  /**
   * Load a FunctionTool instance from a JSON string.
   * @param json - The JSON string to parse.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded FunctionTool instance.
   */
  static fromJson(json: string, context?: LoadContext): FunctionTool {
    const data = JSON.parse(json);

    return FunctionTool.load(data as Record<string, unknown>, context);
  }

  /**
   * Load a FunctionTool instance from a YAML string.
   * @param yaml - The YAML string to parse.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded FunctionTool instance.
   */
  static fromYaml(yaml: string, context?: LoadContext): FunctionTool {
    const { parse } = require("yaml");
    const data = parse(yaml);

    return FunctionTool.load(data as Record<string, unknown>, context);
  }

  //#endregion
}

/**
 * Represents a generic server tool that runs on a server
 * This tool kind is designed for operations that require server-side execution
 * It may include features such as authentication, data storage, and long-running processes
 * This tool kind is ideal for tasks that involve complex computations or access to secure resources
 * Server tools can be used to offload heavy processing from client applications
 *
 */
export class CustomTool extends Tool {
  /**
   * The shorthand property name for this type, if any.
   */
  static readonly shorthandProperty: string | undefined = undefined;

  /**
   * The kind identifier for server tools. This is a wildcard and can represent any server tool type not explicitly defined.
   */
  kind: string = "*";

  /**
   * Connection configuration for the server tool
   */
  connection: Connection;

  /**
   * Configuration options for the server tool
   */
  options: Record<string, unknown> = {};

  /**
   * Initializes a new instance of CustomTool.
   */
  constructor(init?: Partial<CustomTool>) {
    super(init);

    this.kind = init?.kind ?? "*";

    this.connection = init?.connection ?? undefined!;

    this.options = init?.options ?? {};
  }

  //#region Load Methods

  /**
   * Load a CustomTool instance from a dictionary.
   * @param data - The dictionary containing the data.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded CustomTool instance.
   */
  static load(data: Record<string, unknown>, context?: LoadContext): CustomTool {
    if (context) {
      data = context.processInput(data);
    }

    // Create new instance
    const instance = new CustomTool();

    if (data["kind"] !== undefined && data["kind"] !== null) {
      instance.kind = String(data["kind"]);
    }

    if (data["connection"] !== undefined && data["connection"] !== null) {
      instance.connection = Connection.load(data["connection"] as Record<string, unknown>, context);
    }

    if (data["options"] !== undefined && data["options"] !== null) {
      instance.options = data["options"] as Record<string, unknown>;
    }

    if (context) {
      return context.processOutput(instance) as CustomTool;
    }
    return instance;
  }

  //#endregion

  //#region Save Methods

  /**
   * Save the CustomTool instance to a dictionary.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The dictionary representation of this instance.
   */
  save(context?: SaveContext): Record<string, unknown> {
    const obj = context ? (context.processObject(this) as CustomTool) : this;

    // Start with parent class properties
    const result = super.save(context);

    if (obj.kind !== undefined && obj.kind !== null) {
      result["kind"] = obj.kind;
    }

    if (obj.connection !== undefined && obj.connection !== null) {
      result["connection"] = obj.connection?.save(context);
    }

    if (obj.options !== undefined && obj.options !== null) {
      result["options"] = obj.options;
    }

    return result;
  }

  /**
   * Convert the CustomTool instance to a YAML string.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The YAML string representation of this instance.
   */
  toYaml(context?: SaveContext): string {
    context = context ?? new SaveContext();
    return context.toYaml(this.save(context));
  }

  /**
   * Convert the CustomTool instance to a JSON string.
   * @param context - Optional context with pre/post processing callbacks.
   * @param indent - Number of spaces for indentation. Defaults to 2.
   * @returns The JSON string representation of this instance.
   */
  toJson(context?: SaveContext, indent: number = 2): string {
    context = context ?? new SaveContext();
    return context.toJson(this.save(context), indent);
  }

  /**
   * Load a CustomTool instance from a JSON string.
   * @param json - The JSON string to parse.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded CustomTool instance.
   */
  static fromJson(json: string, context?: LoadContext): CustomTool {
    const data = JSON.parse(json);

    return CustomTool.load(data as Record<string, unknown>, context);
  }

  /**
   * Load a CustomTool instance from a YAML string.
   * @param yaml - The YAML string to parse.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded CustomTool instance.
   */
  static fromYaml(yaml: string, context?: LoadContext): CustomTool {
    const { parse } = require("yaml");
    const data = parse(yaml);

    return CustomTool.load(data as Record<string, unknown>, context);
  }

  //#endregion
}

/**
 * The Bing search tool.
 *
 */
export class WebSearchTool extends Tool {
  /**
   * The shorthand property name for this type, if any.
   */
  static readonly shorthandProperty: string | undefined = undefined;

  /**
   * The kind identifier for Bing search tools
   */
  kind: string = "bing_search";

  /**
   * The connection configuration for the Bing search tool
   */
  connection: Connection;

  /**
   * The configuration options for the Bing search tool
   */
  options?: Record<string, unknown> | undefined = {};

  /**
   * Initializes a new instance of WebSearchTool.
   */
  constructor(init?: Partial<WebSearchTool>) {
    super(init);

    this.kind = init?.kind ?? "bing_search";

    this.connection = init?.connection ?? undefined!;

    if (init?.options !== undefined) {
      this.options = init.options;
    }
  }

  //#region Load Methods

  /**
   * Load a WebSearchTool instance from a dictionary.
   * @param data - The dictionary containing the data.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded WebSearchTool instance.
   */
  static load(data: Record<string, unknown>, context?: LoadContext): WebSearchTool {
    if (context) {
      data = context.processInput(data);
    }

    // Create new instance
    const instance = new WebSearchTool();

    if (data["kind"] !== undefined && data["kind"] !== null) {
      instance.kind = String(data["kind"]);
    }

    if (data["connection"] !== undefined && data["connection"] !== null) {
      instance.connection = Connection.load(data["connection"] as Record<string, unknown>, context);
    }

    if (data["options"] !== undefined && data["options"] !== null) {
      instance.options = data["options"] as Record<string, unknown>;
    }

    if (context) {
      return context.processOutput(instance) as WebSearchTool;
    }
    return instance;
  }

  //#endregion

  //#region Save Methods

  /**
   * Save the WebSearchTool instance to a dictionary.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The dictionary representation of this instance.
   */
  save(context?: SaveContext): Record<string, unknown> {
    const obj = context ? (context.processObject(this) as WebSearchTool) : this;

    // Start with parent class properties
    const result = super.save(context);

    if (obj.kind !== undefined && obj.kind !== null) {
      result["kind"] = obj.kind;
    }

    if (obj.connection !== undefined && obj.connection !== null) {
      result["connection"] = obj.connection?.save(context);
    }

    if (obj.options !== undefined && obj.options !== null) {
      result["options"] = obj.options;
    }

    return result;
  }

  /**
   * Convert the WebSearchTool instance to a YAML string.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The YAML string representation of this instance.
   */
  toYaml(context?: SaveContext): string {
    context = context ?? new SaveContext();
    return context.toYaml(this.save(context));
  }

  /**
   * Convert the WebSearchTool instance to a JSON string.
   * @param context - Optional context with pre/post processing callbacks.
   * @param indent - Number of spaces for indentation. Defaults to 2.
   * @returns The JSON string representation of this instance.
   */
  toJson(context?: SaveContext, indent: number = 2): string {
    context = context ?? new SaveContext();
    return context.toJson(this.save(context), indent);
  }

  /**
   * Load a WebSearchTool instance from a JSON string.
   * @param json - The JSON string to parse.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded WebSearchTool instance.
   */
  static fromJson(json: string, context?: LoadContext): WebSearchTool {
    const data = JSON.parse(json);

    return WebSearchTool.load(data as Record<string, unknown>, context);
  }

  /**
   * Load a WebSearchTool instance from a YAML string.
   * @param yaml - The YAML string to parse.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded WebSearchTool instance.
   */
  static fromYaml(yaml: string, context?: LoadContext): WebSearchTool {
    const { parse } = require("yaml");
    const data = parse(yaml);

    return WebSearchTool.load(data as Record<string, unknown>, context);
  }

  //#endregion
}

/**
 * A tool for searching files.
 * This tool allows an AI agent to search for files based on a query.
 *
 */
export class FileSearchTool extends Tool {
  /**
   * The shorthand property name for this type, if any.
   */
  static readonly shorthandProperty: string | undefined = undefined;

  /**
   * The kind identifier for file search tools
   */
  kind: string = "file_search";

  /**
   * The connection configuration for the file search tool
   */
  connection: Connection;

  /**
   * The IDs of the vector stores to search within.
   */
  vectorStoreIds: string[] = [];

  /**
   * The maximum number of search results to return.
   */
  maximumResultCount?: number | undefined;

  /**
   * File search ranker.
   */
  ranker?: string | undefined;

  /**
   * Ranker search threshold.
   */
  scoreThreshold?: number | undefined;

  /**
   * Additional filters to apply during the file search.
   */
  filters?: Record<string, unknown> | undefined = {};

  /**
   * Initializes a new instance of FileSearchTool.
   */
  constructor(init?: Partial<FileSearchTool>) {
    super(init);

    this.kind = init?.kind ?? "file_search";

    this.connection = init?.connection ?? undefined!;

    this.vectorStoreIds = init?.vectorStoreIds ?? [];

    if (init?.maximumResultCount !== undefined) {
      this.maximumResultCount = init.maximumResultCount;
    }

    if (init?.ranker !== undefined) {
      this.ranker = init.ranker;
    }

    if (init?.scoreThreshold !== undefined) {
      this.scoreThreshold = init.scoreThreshold;
    }

    if (init?.filters !== undefined) {
      this.filters = init.filters;
    }
  }

  //#region Load Methods

  /**
   * Load a FileSearchTool instance from a dictionary.
   * @param data - The dictionary containing the data.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded FileSearchTool instance.
   */
  static load(data: Record<string, unknown>, context?: LoadContext): FileSearchTool {
    if (context) {
      data = context.processInput(data);
    }

    // Create new instance
    const instance = new FileSearchTool();

    if (data["kind"] !== undefined && data["kind"] !== null) {
      instance.kind = String(data["kind"]);
    }

    if (data["connection"] !== undefined && data["connection"] !== null) {
      instance.connection = Connection.load(data["connection"] as Record<string, unknown>, context);
    }

    if (data["vectorStoreIds"] !== undefined && data["vectorStoreIds"] !== null) {
      instance.vectorStoreIds = Array.isArray(data["vectorStoreIds"])
        ? (data["vectorStoreIds"] as unknown[]).map((v) => String(v))
        : [];
    }

    if (data["maximumResultCount"] !== undefined && data["maximumResultCount"] !== null) {
      instance.maximumResultCount = Number(data["maximumResultCount"]);
    }

    if (data["ranker"] !== undefined && data["ranker"] !== null) {
      instance.ranker = String(data["ranker"]);
    }

    if (data["scoreThreshold"] !== undefined && data["scoreThreshold"] !== null) {
      instance.scoreThreshold = Number(data["scoreThreshold"]);
    }

    if (data["filters"] !== undefined && data["filters"] !== null) {
      instance.filters = data["filters"] as Record<string, unknown>;
    }

    if (context) {
      return context.processOutput(instance) as FileSearchTool;
    }
    return instance;
  }

  //#endregion

  //#region Save Methods

  /**
   * Save the FileSearchTool instance to a dictionary.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The dictionary representation of this instance.
   */
  save(context?: SaveContext): Record<string, unknown> {
    const obj = context ? (context.processObject(this) as FileSearchTool) : this;

    // Start with parent class properties
    const result = super.save(context);

    if (obj.kind !== undefined && obj.kind !== null) {
      result["kind"] = obj.kind;
    }

    if (obj.connection !== undefined && obj.connection !== null) {
      result["connection"] = obj.connection?.save(context);
    }

    if (obj.vectorStoreIds !== undefined && obj.vectorStoreIds !== null) {
      result["vectorStoreIds"] = obj.vectorStoreIds;
    }

    if (obj.maximumResultCount !== undefined && obj.maximumResultCount !== null) {
      result["maximumResultCount"] = obj.maximumResultCount;
    }

    if (obj.ranker !== undefined && obj.ranker !== null) {
      result["ranker"] = obj.ranker;
    }

    if (obj.scoreThreshold !== undefined && obj.scoreThreshold !== null) {
      result["scoreThreshold"] = obj.scoreThreshold;
    }

    if (obj.filters !== undefined && obj.filters !== null) {
      result["filters"] = obj.filters;
    }

    return result;
  }

  /**
   * Convert the FileSearchTool instance to a YAML string.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The YAML string representation of this instance.
   */
  toYaml(context?: SaveContext): string {
    context = context ?? new SaveContext();
    return context.toYaml(this.save(context));
  }

  /**
   * Convert the FileSearchTool instance to a JSON string.
   * @param context - Optional context with pre/post processing callbacks.
   * @param indent - Number of spaces for indentation. Defaults to 2.
   * @returns The JSON string representation of this instance.
   */
  toJson(context?: SaveContext, indent: number = 2): string {
    context = context ?? new SaveContext();
    return context.toJson(this.save(context), indent);
  }

  /**
   * Load a FileSearchTool instance from a JSON string.
   * @param json - The JSON string to parse.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded FileSearchTool instance.
   */
  static fromJson(json: string, context?: LoadContext): FileSearchTool {
    const data = JSON.parse(json);

    return FileSearchTool.load(data as Record<string, unknown>, context);
  }

  /**
   * Load a FileSearchTool instance from a YAML string.
   * @param yaml - The YAML string to parse.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded FileSearchTool instance.
   */
  static fromYaml(yaml: string, context?: LoadContext): FileSearchTool {
    const { parse } = require("yaml");
    const data = parse(yaml);

    return FileSearchTool.load(data as Record<string, unknown>, context);
  }

  //#endregion
}

/**
 * The MCP Server tool.
 *
 */
export class McpTool extends Tool {
  /**
   * The shorthand property name for this type, if any.
   */
  static readonly shorthandProperty: string | undefined = undefined;

  /**
   * The kind identifier for MCP tools
   */
  kind: string = "mcp";

  /**
   * The connection configuration for the MCP tool
   */
  connection: Connection;

  /**
   * The server name of the MCP tool
   */
  serverName: string = "";

  /**
   * The description of the MCP tool
   */
  serverDescription?: string | undefined;

  /**
   * The approval mode for the MCP tool, either 'auto' or 'manual'
   */
  approvalMode: McpServerApprovalMode;

  /**
   * List of allowed operations or resources for the MCP tool
   */
  allowedTools?: string[] = [];

  /**
   * Initializes a new instance of McpTool.
   */
  constructor(init?: Partial<McpTool>) {
    super(init);

    this.kind = init?.kind ?? "mcp";

    this.connection = init?.connection ?? undefined!;

    this.serverName = init?.serverName ?? "";

    if (init?.serverDescription !== undefined) {
      this.serverDescription = init.serverDescription;
    }

    this.approvalMode = init?.approvalMode ?? undefined!;

    if (init?.allowedTools !== undefined) {
      this.allowedTools = init.allowedTools;
    }
  }

  //#region Load Methods

  /**
   * Load a McpTool instance from a dictionary.
   * @param data - The dictionary containing the data.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded McpTool instance.
   */
  static load(data: Record<string, unknown>, context?: LoadContext): McpTool {
    if (context) {
      data = context.processInput(data);
    }

    // Create new instance
    const instance = new McpTool();

    if (data["kind"] !== undefined && data["kind"] !== null) {
      instance.kind = String(data["kind"]);
    }

    if (data["connection"] !== undefined && data["connection"] !== null) {
      instance.connection = Connection.load(data["connection"] as Record<string, unknown>, context);
    }

    if (data["serverName"] !== undefined && data["serverName"] !== null) {
      instance.serverName = String(data["serverName"]);
    }

    if (data["serverDescription"] !== undefined && data["serverDescription"] !== null) {
      instance.serverDescription = String(data["serverDescription"]);
    }

    if (data["approvalMode"] !== undefined && data["approvalMode"] !== null) {
      instance.approvalMode = McpServerApprovalMode.load(
        data["approvalMode"] as Record<string, unknown>,
        context
      );
    }

    if (data["allowedTools"] !== undefined && data["allowedTools"] !== null) {
      instance.allowedTools = Array.isArray(data["allowedTools"])
        ? (data["allowedTools"] as unknown[]).map((v) => String(v))
        : [];
    }

    if (context) {
      return context.processOutput(instance) as McpTool;
    }
    return instance;
  }

  //#endregion

  //#region Save Methods

  /**
   * Save the McpTool instance to a dictionary.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The dictionary representation of this instance.
   */
  save(context?: SaveContext): Record<string, unknown> {
    const obj = context ? (context.processObject(this) as McpTool) : this;

    // Start with parent class properties
    const result = super.save(context);

    if (obj.kind !== undefined && obj.kind !== null) {
      result["kind"] = obj.kind;
    }

    if (obj.connection !== undefined && obj.connection !== null) {
      result["connection"] = obj.connection?.save(context);
    }

    if (obj.serverName !== undefined && obj.serverName !== null) {
      result["serverName"] = obj.serverName;
    }

    if (obj.serverDescription !== undefined && obj.serverDescription !== null) {
      result["serverDescription"] = obj.serverDescription;
    }

    if (obj.approvalMode !== undefined && obj.approvalMode !== null) {
      result["approvalMode"] = obj.approvalMode?.save(context);
    }

    if (obj.allowedTools !== undefined && obj.allowedTools !== null) {
      result["allowedTools"] = obj.allowedTools;
    }

    return result;
  }

  /**
   * Convert the McpTool instance to a YAML string.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The YAML string representation of this instance.
   */
  toYaml(context?: SaveContext): string {
    context = context ?? new SaveContext();
    return context.toYaml(this.save(context));
  }

  /**
   * Convert the McpTool instance to a JSON string.
   * @param context - Optional context with pre/post processing callbacks.
   * @param indent - Number of spaces for indentation. Defaults to 2.
   * @returns The JSON string representation of this instance.
   */
  toJson(context?: SaveContext, indent: number = 2): string {
    context = context ?? new SaveContext();
    return context.toJson(this.save(context), indent);
  }

  /**
   * Load a McpTool instance from a JSON string.
   * @param json - The JSON string to parse.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded McpTool instance.
   */
  static fromJson(json: string, context?: LoadContext): McpTool {
    const data = JSON.parse(json);

    return McpTool.load(data as Record<string, unknown>, context);
  }

  /**
   * Load a McpTool instance from a YAML string.
   * @param yaml - The YAML string to parse.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded McpTool instance.
   */
  static fromYaml(yaml: string, context?: LoadContext): McpTool {
    const { parse } = require("yaml");
    const data = parse(yaml);

    return McpTool.load(data as Record<string, unknown>, context);
  }

  //#endregion
}

/**
 *
 *
 */
export class OpenApiTool extends Tool {
  /**
   * The shorthand property name for this type, if any.
   */
  static readonly shorthandProperty: string | undefined = undefined;

  /**
   * The kind identifier for OpenAPI tools
   */
  kind: string = "openapi";

  /**
   * The connection configuration for the OpenAPI tool
   */
  connection: Connection;

  /**
   * The full OpenAPI specification
   */
  specification: string = "";

  /**
   * Initializes a new instance of OpenApiTool.
   */
  constructor(init?: Partial<OpenApiTool>) {
    super(init);

    this.kind = init?.kind ?? "openapi";

    this.connection = init?.connection ?? undefined!;

    this.specification = init?.specification ?? "";
  }

  //#region Load Methods

  /**
   * Load a OpenApiTool instance from a dictionary.
   * @param data - The dictionary containing the data.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded OpenApiTool instance.
   */
  static load(data: Record<string, unknown>, context?: LoadContext): OpenApiTool {
    if (context) {
      data = context.processInput(data);
    }

    // Create new instance
    const instance = new OpenApiTool();

    if (data["kind"] !== undefined && data["kind"] !== null) {
      instance.kind = String(data["kind"]);
    }

    if (data["connection"] !== undefined && data["connection"] !== null) {
      instance.connection = Connection.load(data["connection"] as Record<string, unknown>, context);
    }

    if (data["specification"] !== undefined && data["specification"] !== null) {
      instance.specification = String(data["specification"]);
    }

    if (context) {
      return context.processOutput(instance) as OpenApiTool;
    }
    return instance;
  }

  //#endregion

  //#region Save Methods

  /**
   * Save the OpenApiTool instance to a dictionary.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The dictionary representation of this instance.
   */
  save(context?: SaveContext): Record<string, unknown> {
    const obj = context ? (context.processObject(this) as OpenApiTool) : this;

    // Start with parent class properties
    const result = super.save(context);

    if (obj.kind !== undefined && obj.kind !== null) {
      result["kind"] = obj.kind;
    }

    if (obj.connection !== undefined && obj.connection !== null) {
      result["connection"] = obj.connection?.save(context);
    }

    if (obj.specification !== undefined && obj.specification !== null) {
      result["specification"] = obj.specification;
    }

    return result;
  }

  /**
   * Convert the OpenApiTool instance to a YAML string.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The YAML string representation of this instance.
   */
  toYaml(context?: SaveContext): string {
    context = context ?? new SaveContext();
    return context.toYaml(this.save(context));
  }

  /**
   * Convert the OpenApiTool instance to a JSON string.
   * @param context - Optional context with pre/post processing callbacks.
   * @param indent - Number of spaces for indentation. Defaults to 2.
   * @returns The JSON string representation of this instance.
   */
  toJson(context?: SaveContext, indent: number = 2): string {
    context = context ?? new SaveContext();
    return context.toJson(this.save(context), indent);
  }

  /**
   * Load a OpenApiTool instance from a JSON string.
   * @param json - The JSON string to parse.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded OpenApiTool instance.
   */
  static fromJson(json: string, context?: LoadContext): OpenApiTool {
    const data = JSON.parse(json);

    return OpenApiTool.load(data as Record<string, unknown>, context);
  }

  /**
   * Load a OpenApiTool instance from a YAML string.
   * @param yaml - The YAML string to parse.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded OpenApiTool instance.
   */
  static fromYaml(yaml: string, context?: LoadContext): OpenApiTool {
    const { parse } = require("yaml");
    const data = parse(yaml);

    return OpenApiTool.load(data as Record<string, unknown>, context);
  }

  //#endregion
}

/**
 * A tool for interpreting and executing code.
 * This tool allows an AI agent to run code snippets and analyze data files.
 *
 */
export class CodeInterpreterTool extends Tool {
  /**
   * The shorthand property name for this type, if any.
   */
  static readonly shorthandProperty: string | undefined = undefined;

  /**
   * The kind identifier for code interpreter tools
   */
  kind: string = "code_interpreter";

  /**
   * The IDs of the files to be used by the code interpreter tool.
   */
  fileIds: string[] = [];

  /**
   * Initializes a new instance of CodeInterpreterTool.
   */
  constructor(init?: Partial<CodeInterpreterTool>) {
    super(init);

    this.kind = init?.kind ?? "code_interpreter";

    this.fileIds = init?.fileIds ?? [];
  }

  //#region Load Methods

  /**
   * Load a CodeInterpreterTool instance from a dictionary.
   * @param data - The dictionary containing the data.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded CodeInterpreterTool instance.
   */
  static load(data: Record<string, unknown>, context?: LoadContext): CodeInterpreterTool {
    if (context) {
      data = context.processInput(data);
    }

    // Create new instance
    const instance = new CodeInterpreterTool();

    if (data["kind"] !== undefined && data["kind"] !== null) {
      instance.kind = String(data["kind"]);
    }

    if (data["fileIds"] !== undefined && data["fileIds"] !== null) {
      instance.fileIds = Array.isArray(data["fileIds"])
        ? (data["fileIds"] as unknown[]).map((v) => String(v))
        : [];
    }

    if (context) {
      return context.processOutput(instance) as CodeInterpreterTool;
    }
    return instance;
  }

  //#endregion

  //#region Save Methods

  /**
   * Save the CodeInterpreterTool instance to a dictionary.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The dictionary representation of this instance.
   */
  save(context?: SaveContext): Record<string, unknown> {
    const obj = context ? (context.processObject(this) as CodeInterpreterTool) : this;

    // Start with parent class properties
    const result = super.save(context);

    if (obj.kind !== undefined && obj.kind !== null) {
      result["kind"] = obj.kind;
    }

    if (obj.fileIds !== undefined && obj.fileIds !== null) {
      result["fileIds"] = obj.fileIds;
    }

    return result;
  }

  /**
   * Convert the CodeInterpreterTool instance to a YAML string.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The YAML string representation of this instance.
   */
  toYaml(context?: SaveContext): string {
    context = context ?? new SaveContext();
    return context.toYaml(this.save(context));
  }

  /**
   * Convert the CodeInterpreterTool instance to a JSON string.
   * @param context - Optional context with pre/post processing callbacks.
   * @param indent - Number of spaces for indentation. Defaults to 2.
   * @returns The JSON string representation of this instance.
   */
  toJson(context?: SaveContext, indent: number = 2): string {
    context = context ?? new SaveContext();
    return context.toJson(this.save(context), indent);
  }

  /**
   * Load a CodeInterpreterTool instance from a JSON string.
   * @param json - The JSON string to parse.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded CodeInterpreterTool instance.
   */
  static fromJson(json: string, context?: LoadContext): CodeInterpreterTool {
    const data = JSON.parse(json);

    return CodeInterpreterTool.load(data as Record<string, unknown>, context);
  }

  /**
   * Load a CodeInterpreterTool instance from a YAML string.
   * @param yaml - The YAML string to parse.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded CodeInterpreterTool instance.
   */
  static fromYaml(yaml: string, context?: LoadContext): CodeInterpreterTool {
    const { parse } = require("yaml");
    const data = parse(yaml);

    return CodeInterpreterTool.load(data as Record<string, unknown>, context);
  }

  //#endregion
}
