// Copyright (c) Microsoft. All rights reserved.
// WARNING: This is an auto-generated file. DO NOT EDIT THIS FILE DIRECTLY.

import { LoadContext, SaveContext } from "./context";

/**
 * Options for configuring the behavior of the AI model.
 * `kind` is a required property here, but this section can accept additional via options.
 *
 */
export class ModelOptions {
  /**
   * The shorthand property name for this type, if any.
   */
  static readonly shorthandProperty: string | undefined = undefined;

  /**
   * The frequency penalty to apply to the model's output
   */
  frequencyPenalty?: number | undefined;

  /**
   * The maximum number of tokens to generate in the output
   */
  maxOutputTokens?: number | undefined;

  /**
   * The presence penalty to apply to the model's output
   */
  presencePenalty?: number | undefined;

  /**
   * A random seed for deterministic output
   */
  seed?: number | undefined;

  /**
   * The temperature to use for sampling
   */
  temperature?: number | undefined;

  /**
   * The top-K sampling value
   */
  topK?: number | undefined;

  /**
   * The top-P sampling value
   */
  topP?: number | undefined;

  /**
   * Stop sequences to end generation
   */
  stopSequences?: string[] = [];

  /**
   * Whether to allow multiple tool calls in a single response
   */
  allowMultipleToolCalls?: boolean | undefined;

  /**
   * Additional custom properties for model options
   */
  additionalProperties?: Record<string, unknown> | undefined = {};

  /**
   * Initializes a new instance of ModelOptions.
   */
  constructor(init?: Partial<ModelOptions>) {
    if (init?.frequencyPenalty !== undefined) {
      this.frequencyPenalty = init.frequencyPenalty;
    }

    if (init?.maxOutputTokens !== undefined) {
      this.maxOutputTokens = init.maxOutputTokens;
    }

    if (init?.presencePenalty !== undefined) {
      this.presencePenalty = init.presencePenalty;
    }

    if (init?.seed !== undefined) {
      this.seed = init.seed;
    }

    if (init?.temperature !== undefined) {
      this.temperature = init.temperature;
    }

    if (init?.topK !== undefined) {
      this.topK = init.topK;
    }

    if (init?.topP !== undefined) {
      this.topP = init.topP;
    }

    if (init?.stopSequences !== undefined) {
      this.stopSequences = init.stopSequences;
    }

    if (init?.allowMultipleToolCalls !== undefined) {
      this.allowMultipleToolCalls = init.allowMultipleToolCalls;
    }

    if (init?.additionalProperties !== undefined) {
      this.additionalProperties = init.additionalProperties;
    }
  }

  //#region Load Methods

  /**
   * Load a ModelOptions instance from a dictionary.
   * @param data - The dictionary containing the data.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded ModelOptions instance.
   */
  static load(data: Record<string, unknown>, context?: LoadContext): ModelOptions {
    if (context) {
      data = context.processInput(data);
    }

    // Create new instance
    const instance = new ModelOptions();

    if (data["frequencyPenalty"] !== undefined && data["frequencyPenalty"] !== null) {
      instance.frequencyPenalty = Number(data["frequencyPenalty"]);
    }

    if (data["maxOutputTokens"] !== undefined && data["maxOutputTokens"] !== null) {
      instance.maxOutputTokens = Number(data["maxOutputTokens"]);
    }

    if (data["presencePenalty"] !== undefined && data["presencePenalty"] !== null) {
      instance.presencePenalty = Number(data["presencePenalty"]);
    }

    if (data["seed"] !== undefined && data["seed"] !== null) {
      instance.seed = Number(data["seed"]);
    }

    if (data["temperature"] !== undefined && data["temperature"] !== null) {
      instance.temperature = Number(data["temperature"]);
    }

    if (data["topK"] !== undefined && data["topK"] !== null) {
      instance.topK = Number(data["topK"]);
    }

    if (data["topP"] !== undefined && data["topP"] !== null) {
      instance.topP = Number(data["topP"]);
    }

    if (data["stopSequences"] !== undefined && data["stopSequences"] !== null) {
      instance.stopSequences = Array.isArray(data["stopSequences"])
        ? (data["stopSequences"] as unknown[]).map((v) => String(v))
        : [];
    }

    if (data["allowMultipleToolCalls"] !== undefined && data["allowMultipleToolCalls"] !== null) {
      instance.allowMultipleToolCalls = Boolean(data["allowMultipleToolCalls"]);
    }

    if (data["additionalProperties"] !== undefined && data["additionalProperties"] !== null) {
      instance.additionalProperties = data["additionalProperties"] as Record<string, unknown>;
    }

    if (context) {
      return context.processOutput(instance) as ModelOptions;
    }
    return instance;
  }

  //#endregion

  //#region Save Methods

  /**
   * Save the ModelOptions instance to a dictionary.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The dictionary representation of this instance.
   */
  save(context?: SaveContext): Record<string, unknown> {
    const obj = context ? (context.processObject(this) as ModelOptions) : this;

    const result: Record<string, unknown> = {};

    if (obj.frequencyPenalty !== undefined && obj.frequencyPenalty !== null) {
      result["frequencyPenalty"] = obj.frequencyPenalty;
    }

    if (obj.maxOutputTokens !== undefined && obj.maxOutputTokens !== null) {
      result["maxOutputTokens"] = obj.maxOutputTokens;
    }

    if (obj.presencePenalty !== undefined && obj.presencePenalty !== null) {
      result["presencePenalty"] = obj.presencePenalty;
    }

    if (obj.seed !== undefined && obj.seed !== null) {
      result["seed"] = obj.seed;
    }

    if (obj.temperature !== undefined && obj.temperature !== null) {
      result["temperature"] = obj.temperature;
    }

    if (obj.topK !== undefined && obj.topK !== null) {
      result["topK"] = obj.topK;
    }

    if (obj.topP !== undefined && obj.topP !== null) {
      result["topP"] = obj.topP;
    }

    if (obj.stopSequences !== undefined && obj.stopSequences !== null) {
      result["stopSequences"] = obj.stopSequences;
    }

    if (obj.allowMultipleToolCalls !== undefined && obj.allowMultipleToolCalls !== null) {
      result["allowMultipleToolCalls"] = obj.allowMultipleToolCalls;
    }

    if (obj.additionalProperties !== undefined && obj.additionalProperties !== null) {
      result["additionalProperties"] = obj.additionalProperties;
    }

    if (context) {
      return context.processDict(result);
    }

    return result;
  }

  /**
   * Convert the ModelOptions instance to a YAML string.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The YAML string representation of this instance.
   */
  toYaml(context?: SaveContext): string {
    context = context ?? new SaveContext();
    return context.toYaml(this.save(context));
  }

  /**
   * Convert the ModelOptions instance to a JSON string.
   * @param context - Optional context with pre/post processing callbacks.
   * @param indent - Number of spaces for indentation. Defaults to 2.
   * @returns The JSON string representation of this instance.
   */
  toJson(context?: SaveContext, indent: number = 2): string {
    context = context ?? new SaveContext();
    return context.toJson(this.save(context), indent);
  }

  /**
   * Load a ModelOptions instance from a JSON string.
   * @param json - The JSON string to parse.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded ModelOptions instance.
   */
  static fromJson(json: string, context?: LoadContext): ModelOptions {
    const data = JSON.parse(json);

    return ModelOptions.load(data as Record<string, unknown>, context);
  }

  /**
   * Load a ModelOptions instance from a YAML string.
   * @param yaml - The YAML string to parse.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded ModelOptions instance.
   */
  static fromYaml(yaml: string, context?: LoadContext): ModelOptions {
    const { parse } = require("yaml");
    const data = parse(yaml);

    return ModelOptions.load(data as Record<string, unknown>, context);
  }

  //#endregion
}
