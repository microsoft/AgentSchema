// Copyright (c) Microsoft. All rights reserved.
// WARNING: This is an auto-generated file. DO NOT EDIT THIS FILE DIRECTLY.

import { LoadContext, SaveContext } from "./context";

/**
 * Connection configuration for AI agents.
 * `provider`, `kind`, and `endpoint` are required properties here,
 * but this section can accept additional via options.
 *
 */
export abstract class Connection {
  /**
   * The shorthand property name for this type, if any.
   */
  static readonly shorthandProperty: string | undefined = undefined;

  /**
   * The Authentication kind for the AI service (e.g., 'key' for API key, 'oauth' for OAuth tokens)
   */
  kind: string = "";

  /**
   * The authority level for the connection, indicating under whose authority the connection is made (e.g., 'user', 'agent', 'system')
   */
  authenticationMode: string = "system";

  /**
   * The usage description for the connection, providing context on how this connection will be used
   */
  usageDescription?: string | undefined;

  /**
   * Initializes a new instance of Connection.
   */
  constructor(init?: Partial<Connection>) {
    this.kind = init?.kind ?? "";

    this.authenticationMode = init?.authenticationMode ?? "system";

    if (init?.usageDescription !== undefined) {
      this.usageDescription = init.usageDescription;
    }
  }

  //#region Load Methods

  /**
   * Load a Connection instance from a dictionary.
   * @param data - The dictionary containing the data.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded Connection instance.
   */
  static load(data: Record<string, unknown>, context?: LoadContext): Connection {
    if (context) {
      data = context.processInput(data);
    }

    // Load polymorphic Connection instance
    const instance = Connection.loadKind(data, context);

    if (data["kind"] !== undefined && data["kind"] !== null) {
      instance.kind = String(data["kind"]);
    }

    if (data["authenticationMode"] !== undefined && data["authenticationMode"] !== null) {
      instance.authenticationMode = String(data["authenticationMode"]);
    }

    if (data["usageDescription"] !== undefined && data["usageDescription"] !== null) {
      instance.usageDescription = String(data["usageDescription"]);
    }

    if (context) {
      return context.processOutput(instance) as Connection;
    }
    return instance;
  }

  /**
   * Load polymorphic Connection based on discriminator.
   * @param data - The dictionary containing the data.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded Connection instance.
   */
  private static loadKind(data: Record<string, unknown>, context?: LoadContext): Connection {
    const discriminatorValue = data["kind"];
    if (discriminatorValue !== undefined && discriminatorValue !== null) {
      const discriminator = String(discriminatorValue).toLowerCase();
      switch (discriminator) {
        case "reference":
          return ReferenceConnection.load(data, context);
        case "remote":
          return RemoteConnection.load(data, context);
        case "key":
          return ApiKeyConnection.load(data, context);
        case "anonymous":
          return AnonymousConnection.load(data, context);
        default:
          throw new Error(`Unknown Connection discriminator value: ${discriminator}`);
      }
    }

    throw new Error("Missing Connection discriminator property: 'kind'");
  }

  //#endregion

  //#region Save Methods

  /**
   * Save the Connection instance to a dictionary.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The dictionary representation of this instance.
   */
  save(context?: SaveContext): Record<string, unknown> {
    const obj = context ? (context.processObject(this) as Connection) : this;

    const result: Record<string, unknown> = {};

    if (obj.kind !== undefined && obj.kind !== null) {
      result["kind"] = obj.kind;
    }

    if (obj.authenticationMode !== undefined && obj.authenticationMode !== null) {
      result["authenticationMode"] = obj.authenticationMode;
    }

    if (obj.usageDescription !== undefined && obj.usageDescription !== null) {
      result["usageDescription"] = obj.usageDescription;
    }

    if (context) {
      return context.processDict(result);
    }

    return result;
  }

  /**
   * Convert the Connection instance to a YAML string.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The YAML string representation of this instance.
   */
  toYaml(context?: SaveContext): string {
    context = context ?? new SaveContext();
    return context.toYaml(this.save(context));
  }

  /**
   * Convert the Connection instance to a JSON string.
   * @param context - Optional context with pre/post processing callbacks.
   * @param indent - Number of spaces for indentation. Defaults to 2.
   * @returns The JSON string representation of this instance.
   */
  toJson(context?: SaveContext, indent: number = 2): string {
    context = context ?? new SaveContext();
    return context.toJson(this.save(context), indent);
  }

  /**
   * Load a Connection instance from a JSON string.
   * @param json - The JSON string to parse.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded Connection instance.
   */
  static fromJson(json: string, context?: LoadContext): Connection {
    const data = JSON.parse(json);

    return Connection.load(data as Record<string, unknown>, context);
  }

  /**
   * Load a Connection instance from a YAML string.
   * @param yaml - The YAML string to parse.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded Connection instance.
   */
  static fromYaml(yaml: string, context?: LoadContext): Connection {
    const { parse } = require("yaml");
    const data = parse(yaml);

    return Connection.load(data as Record<string, unknown>, context);
  }

  //#endregion
}

/**
 * Connection configuration for AI services using named connections.
 *
 */
export class ReferenceConnection extends Connection {
  /**
   * The shorthand property name for this type, if any.
   */
  static readonly shorthandProperty: string | undefined = undefined;

  /**
   * The Authentication kind for the AI service (e.g., 'key' for API key, 'oauth' for OAuth tokens)
   */
  kind: string = "reference";

  /**
   * The name of the connection
   */
  name: string = "";

  /**
   * The target resource or service that this connection refers to
   */
  target?: string | undefined;

  /**
   * Initializes a new instance of ReferenceConnection.
   */
  constructor(init?: Partial<ReferenceConnection>) {
    super(init);

    this.kind = init?.kind ?? "reference";

    this.name = init?.name ?? "";

    if (init?.target !== undefined) {
      this.target = init.target;
    }
  }

  //#region Load Methods

  /**
   * Load a ReferenceConnection instance from a dictionary.
   * @param data - The dictionary containing the data.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded ReferenceConnection instance.
   */
  static load(data: Record<string, unknown>, context?: LoadContext): ReferenceConnection {
    if (context) {
      data = context.processInput(data);
    }

    // Create new instance
    const instance = new ReferenceConnection();

    if (data["kind"] !== undefined && data["kind"] !== null) {
      instance.kind = String(data["kind"]);
    }

    if (data["name"] !== undefined && data["name"] !== null) {
      instance.name = String(data["name"]);
    }

    if (data["target"] !== undefined && data["target"] !== null) {
      instance.target = String(data["target"]);
    }

    if (context) {
      return context.processOutput(instance) as ReferenceConnection;
    }
    return instance;
  }

  //#endregion

  //#region Save Methods

  /**
   * Save the ReferenceConnection instance to a dictionary.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The dictionary representation of this instance.
   */
  save(context?: SaveContext): Record<string, unknown> {
    const obj = context ? (context.processObject(this) as ReferenceConnection) : this;

    // Start with parent class properties
    const result = super.save(context);

    if (obj.kind !== undefined && obj.kind !== null) {
      result["kind"] = obj.kind;
    }

    if (obj.name !== undefined && obj.name !== null) {
      result["name"] = obj.name;
    }

    if (obj.target !== undefined && obj.target !== null) {
      result["target"] = obj.target;
    }

    return result;
  }

  /**
   * Convert the ReferenceConnection instance to a YAML string.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The YAML string representation of this instance.
   */
  toYaml(context?: SaveContext): string {
    context = context ?? new SaveContext();
    return context.toYaml(this.save(context));
  }

  /**
   * Convert the ReferenceConnection instance to a JSON string.
   * @param context - Optional context with pre/post processing callbacks.
   * @param indent - Number of spaces for indentation. Defaults to 2.
   * @returns The JSON string representation of this instance.
   */
  toJson(context?: SaveContext, indent: number = 2): string {
    context = context ?? new SaveContext();
    return context.toJson(this.save(context), indent);
  }

  /**
   * Load a ReferenceConnection instance from a JSON string.
   * @param json - The JSON string to parse.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded ReferenceConnection instance.
   */
  static fromJson(json: string, context?: LoadContext): ReferenceConnection {
    const data = JSON.parse(json);

    return ReferenceConnection.load(data as Record<string, unknown>, context);
  }

  /**
   * Load a ReferenceConnection instance from a YAML string.
   * @param yaml - The YAML string to parse.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded ReferenceConnection instance.
   */
  static fromYaml(yaml: string, context?: LoadContext): ReferenceConnection {
    const { parse } = require("yaml");
    const data = parse(yaml);

    return ReferenceConnection.load(data as Record<string, unknown>, context);
  }

  //#endregion
}

/**
 * Connection configuration for AI services using named connections.
 *
 */
export class RemoteConnection extends Connection {
  /**
   * The shorthand property name for this type, if any.
   */
  static readonly shorthandProperty: string | undefined = undefined;

  /**
   * The Authentication kind for the AI service (e.g., 'key' for API key, 'oauth' for OAuth tokens)
   */
  kind: string = "remote";

  /**
   * The name of the connection
   */
  name: string = "";

  /**
   * The endpoint URL for the AI service
   */
  endpoint: string = "";

  /**
   * Initializes a new instance of RemoteConnection.
   */
  constructor(init?: Partial<RemoteConnection>) {
    super(init);

    this.kind = init?.kind ?? "remote";

    this.name = init?.name ?? "";

    this.endpoint = init?.endpoint ?? "";
  }

  //#region Load Methods

  /**
   * Load a RemoteConnection instance from a dictionary.
   * @param data - The dictionary containing the data.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded RemoteConnection instance.
   */
  static load(data: Record<string, unknown>, context?: LoadContext): RemoteConnection {
    if (context) {
      data = context.processInput(data);
    }

    // Create new instance
    const instance = new RemoteConnection();

    if (data["kind"] !== undefined && data["kind"] !== null) {
      instance.kind = String(data["kind"]);
    }

    if (data["name"] !== undefined && data["name"] !== null) {
      instance.name = String(data["name"]);
    }

    if (data["endpoint"] !== undefined && data["endpoint"] !== null) {
      instance.endpoint = String(data["endpoint"]);
    }

    if (context) {
      return context.processOutput(instance) as RemoteConnection;
    }
    return instance;
  }

  //#endregion

  //#region Save Methods

  /**
   * Save the RemoteConnection instance to a dictionary.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The dictionary representation of this instance.
   */
  save(context?: SaveContext): Record<string, unknown> {
    const obj = context ? (context.processObject(this) as RemoteConnection) : this;

    // Start with parent class properties
    const result = super.save(context);

    if (obj.kind !== undefined && obj.kind !== null) {
      result["kind"] = obj.kind;
    }

    if (obj.name !== undefined && obj.name !== null) {
      result["name"] = obj.name;
    }

    if (obj.endpoint !== undefined && obj.endpoint !== null) {
      result["endpoint"] = obj.endpoint;
    }

    return result;
  }

  /**
   * Convert the RemoteConnection instance to a YAML string.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The YAML string representation of this instance.
   */
  toYaml(context?: SaveContext): string {
    context = context ?? new SaveContext();
    return context.toYaml(this.save(context));
  }

  /**
   * Convert the RemoteConnection instance to a JSON string.
   * @param context - Optional context with pre/post processing callbacks.
   * @param indent - Number of spaces for indentation. Defaults to 2.
   * @returns The JSON string representation of this instance.
   */
  toJson(context?: SaveContext, indent: number = 2): string {
    context = context ?? new SaveContext();
    return context.toJson(this.save(context), indent);
  }

  /**
   * Load a RemoteConnection instance from a JSON string.
   * @param json - The JSON string to parse.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded RemoteConnection instance.
   */
  static fromJson(json: string, context?: LoadContext): RemoteConnection {
    const data = JSON.parse(json);

    return RemoteConnection.load(data as Record<string, unknown>, context);
  }

  /**
   * Load a RemoteConnection instance from a YAML string.
   * @param yaml - The YAML string to parse.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded RemoteConnection instance.
   */
  static fromYaml(yaml: string, context?: LoadContext): RemoteConnection {
    const { parse } = require("yaml");
    const data = parse(yaml);

    return RemoteConnection.load(data as Record<string, unknown>, context);
  }

  //#endregion
}

/**
 * Connection configuration for AI services using API keys.
 *
 */
export class ApiKeyConnection extends Connection {
  /**
   * The shorthand property name for this type, if any.
   */
  static readonly shorthandProperty: string | undefined = undefined;

  /**
   * The Authentication kind for the AI service (e.g., 'key' for API key, 'oauth' for OAuth tokens)
   */
  kind: string = "key";

  /**
   * The endpoint URL for the AI service
   */
  endpoint: string = "";

  /**
   * The API key for authenticating with the AI service
   */
  apiKey: string = "";

  /**
   * Initializes a new instance of ApiKeyConnection.
   */
  constructor(init?: Partial<ApiKeyConnection>) {
    super(init);

    this.kind = init?.kind ?? "key";

    this.endpoint = init?.endpoint ?? "";

    this.apiKey = init?.apiKey ?? "";
  }

  //#region Load Methods

  /**
   * Load a ApiKeyConnection instance from a dictionary.
   * @param data - The dictionary containing the data.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded ApiKeyConnection instance.
   */
  static load(data: Record<string, unknown>, context?: LoadContext): ApiKeyConnection {
    if (context) {
      data = context.processInput(data);
    }

    // Create new instance
    const instance = new ApiKeyConnection();

    if (data["kind"] !== undefined && data["kind"] !== null) {
      instance.kind = String(data["kind"]);
    }

    if (data["endpoint"] !== undefined && data["endpoint"] !== null) {
      instance.endpoint = String(data["endpoint"]);
    }

    if (data["apiKey"] !== undefined && data["apiKey"] !== null) {
      instance.apiKey = String(data["apiKey"]);
    }

    if (context) {
      return context.processOutput(instance) as ApiKeyConnection;
    }
    return instance;
  }

  //#endregion

  //#region Save Methods

  /**
   * Save the ApiKeyConnection instance to a dictionary.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The dictionary representation of this instance.
   */
  save(context?: SaveContext): Record<string, unknown> {
    const obj = context ? (context.processObject(this) as ApiKeyConnection) : this;

    // Start with parent class properties
    const result = super.save(context);

    if (obj.kind !== undefined && obj.kind !== null) {
      result["kind"] = obj.kind;
    }

    if (obj.endpoint !== undefined && obj.endpoint !== null) {
      result["endpoint"] = obj.endpoint;
    }

    if (obj.apiKey !== undefined && obj.apiKey !== null) {
      result["apiKey"] = obj.apiKey;
    }

    return result;
  }

  /**
   * Convert the ApiKeyConnection instance to a YAML string.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The YAML string representation of this instance.
   */
  toYaml(context?: SaveContext): string {
    context = context ?? new SaveContext();
    return context.toYaml(this.save(context));
  }

  /**
   * Convert the ApiKeyConnection instance to a JSON string.
   * @param context - Optional context with pre/post processing callbacks.
   * @param indent - Number of spaces for indentation. Defaults to 2.
   * @returns The JSON string representation of this instance.
   */
  toJson(context?: SaveContext, indent: number = 2): string {
    context = context ?? new SaveContext();
    return context.toJson(this.save(context), indent);
  }

  /**
   * Load a ApiKeyConnection instance from a JSON string.
   * @param json - The JSON string to parse.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded ApiKeyConnection instance.
   */
  static fromJson(json: string, context?: LoadContext): ApiKeyConnection {
    const data = JSON.parse(json);

    return ApiKeyConnection.load(data as Record<string, unknown>, context);
  }

  /**
   * Load a ApiKeyConnection instance from a YAML string.
   * @param yaml - The YAML string to parse.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded ApiKeyConnection instance.
   */
  static fromYaml(yaml: string, context?: LoadContext): ApiKeyConnection {
    const { parse } = require("yaml");
    const data = parse(yaml);

    return ApiKeyConnection.load(data as Record<string, unknown>, context);
  }

  //#endregion
}

/**
 *
 *
 */
export class AnonymousConnection extends Connection {
  /**
   * The shorthand property name for this type, if any.
   */
  static readonly shorthandProperty: string | undefined = undefined;

  /**
   * The Authentication kind for the AI service (e.g., 'key' for API key, 'oauth' for OAuth tokens)
   */
  kind: string = "anonymous";

  /**
   * The endpoint for authenticating with the AI service
   */
  endpoint: string = "";

  /**
   * Initializes a new instance of AnonymousConnection.
   */
  constructor(init?: Partial<AnonymousConnection>) {
    super(init);

    this.kind = init?.kind ?? "anonymous";

    this.endpoint = init?.endpoint ?? "";
  }

  //#region Load Methods

  /**
   * Load a AnonymousConnection instance from a dictionary.
   * @param data - The dictionary containing the data.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded AnonymousConnection instance.
   */
  static load(data: Record<string, unknown>, context?: LoadContext): AnonymousConnection {
    if (context) {
      data = context.processInput(data);
    }

    // Create new instance
    const instance = new AnonymousConnection();

    if (data["kind"] !== undefined && data["kind"] !== null) {
      instance.kind = String(data["kind"]);
    }

    if (data["endpoint"] !== undefined && data["endpoint"] !== null) {
      instance.endpoint = String(data["endpoint"]);
    }

    if (context) {
      return context.processOutput(instance) as AnonymousConnection;
    }
    return instance;
  }

  //#endregion

  //#region Save Methods

  /**
   * Save the AnonymousConnection instance to a dictionary.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The dictionary representation of this instance.
   */
  save(context?: SaveContext): Record<string, unknown> {
    const obj = context ? (context.processObject(this) as AnonymousConnection) : this;

    // Start with parent class properties
    const result = super.save(context);

    if (obj.kind !== undefined && obj.kind !== null) {
      result["kind"] = obj.kind;
    }

    if (obj.endpoint !== undefined && obj.endpoint !== null) {
      result["endpoint"] = obj.endpoint;
    }

    return result;
  }

  /**
   * Convert the AnonymousConnection instance to a YAML string.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The YAML string representation of this instance.
   */
  toYaml(context?: SaveContext): string {
    context = context ?? new SaveContext();
    return context.toYaml(this.save(context));
  }

  /**
   * Convert the AnonymousConnection instance to a JSON string.
   * @param context - Optional context with pre/post processing callbacks.
   * @param indent - Number of spaces for indentation. Defaults to 2.
   * @returns The JSON string representation of this instance.
   */
  toJson(context?: SaveContext, indent: number = 2): string {
    context = context ?? new SaveContext();
    return context.toJson(this.save(context), indent);
  }

  /**
   * Load a AnonymousConnection instance from a JSON string.
   * @param json - The JSON string to parse.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded AnonymousConnection instance.
   */
  static fromJson(json: string, context?: LoadContext): AnonymousConnection {
    const data = JSON.parse(json);

    return AnonymousConnection.load(data as Record<string, unknown>, context);
  }

  /**
   * Load a AnonymousConnection instance from a YAML string.
   * @param yaml - The YAML string to parse.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded AnonymousConnection instance.
   */
  static fromYaml(yaml: string, context?: LoadContext): AnonymousConnection {
    const { parse } = require("yaml");
    const data = parse(yaml);

    return AnonymousConnection.load(data as Record<string, unknown>, context);
  }

  //#endregion
}
