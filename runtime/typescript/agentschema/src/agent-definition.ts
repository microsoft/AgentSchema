// Copyright (c) Microsoft. All rights reserved.
// WARNING: This is an auto-generated file. DO NOT EDIT THIS FILE DIRECTLY.

import { LoadContext, SaveContext } from "./context";
import { ContainerResources } from "./container-resources";
import { ContainerScale } from "./container-scale";
import { EnvironmentVariable } from "./environment-variable";
import { Model } from "./model";
import { PropertySchema } from "./property-schema";
import { ProtocolVersionRecord } from "./protocol-version-record";
import { Template } from "./template";
import { Tool } from "./tool";

/**
 * The following is a specification for defining AI agents with structured metadata, inputs, outputs, tools, and templates.
 * It provides a way to create reusable and composable AI agents that can be executed with specific configurations.
 * The specification includes metadata about the agent, model configuration, input parameters, expected outputs,
 * available tools, and template configurations for prompt rendering.
 *
 */
export abstract class AgentDefinition {
  /**
   * The shorthand property name for this type, if any.
   */
  static readonly shorthandProperty: string | undefined = undefined;

  /**
   * Kind represented by the document
   */
  kind: string = "";

  /**
   * Human-readable name of the agent
   */
  name: string = "";

  /**
   * Display name of the agent for UI purposes
   */
  displayName?: string | undefined;

  /**
   * Description of the agent's capabilities and purpose
   */
  description?: string | undefined;

  /**
   * Additional metadata including authors, tags, and other arbitrary properties
   */
  metadata?: Record<string, unknown> | undefined = {};

  /**
   * Input parameters that participate in template rendering
   */
  inputSchema?: PropertySchema | undefined;

  /**
   * Expected output format and structure from the agent
   */
  outputSchema?: PropertySchema | undefined;

  /**
   * Initializes a new instance of AgentDefinition.
   */
  constructor(init?: Partial<AgentDefinition>) {
    this.kind = init?.kind ?? "";

    this.name = init?.name ?? "";

    if (init?.displayName !== undefined) {
      this.displayName = init.displayName;
    }

    if (init?.description !== undefined) {
      this.description = init.description;
    }

    if (init?.metadata !== undefined) {
      this.metadata = init.metadata;
    }

    if (init?.inputSchema !== undefined) {
      this.inputSchema = init.inputSchema;
    }

    if (init?.outputSchema !== undefined) {
      this.outputSchema = init.outputSchema;
    }
  }

  //#region Load Methods

  /**
   * Load a AgentDefinition instance from a dictionary.
   * @param data - The dictionary containing the data.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded AgentDefinition instance.
   */
  static load(data: Record<string, unknown>, context?: LoadContext): AgentDefinition {
    if (context) {
      data = context.processInput(data);
    }

    // Load polymorphic AgentDefinition instance
    const instance = AgentDefinition.loadKind(data, context);

    if (data["kind"] !== undefined && data["kind"] !== null) {
      instance.kind = String(data["kind"]);
    }

    if (data["name"] !== undefined && data["name"] !== null) {
      instance.name = String(data["name"]);
    }

    if (data["displayName"] !== undefined && data["displayName"] !== null) {
      instance.displayName = String(data["displayName"]);
    }

    if (data["description"] !== undefined && data["description"] !== null) {
      instance.description = String(data["description"]);
    }

    if (data["metadata"] !== undefined && data["metadata"] !== null) {
      instance.metadata = data["metadata"] as Record<string, unknown>;
    }

    if (data["inputSchema"] !== undefined && data["inputSchema"] !== null) {
      instance.inputSchema = PropertySchema.load(
        data["inputSchema"] as Record<string, unknown>,
        context
      );
    }

    if (data["outputSchema"] !== undefined && data["outputSchema"] !== null) {
      instance.outputSchema = PropertySchema.load(
        data["outputSchema"] as Record<string, unknown>,
        context
      );
    }

    if (context) {
      return context.processOutput(instance) as AgentDefinition;
    }
    return instance;
  }

  /**
   * Load polymorphic AgentDefinition based on discriminator.
   * @param data - The dictionary containing the data.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded AgentDefinition instance.
   */
  private static loadKind(data: Record<string, unknown>, context?: LoadContext): AgentDefinition {
    const discriminatorValue = data["kind"];
    if (discriminatorValue !== undefined && discriminatorValue !== null) {
      const discriminator = String(discriminatorValue).toLowerCase();
      switch (discriminator) {
        case "prompt":
          return PromptAgent.load(data, context);
        case "workflow":
          return Workflow.load(data, context);
        case "hosted":
          return ContainerAgent.load(data, context);
        default:
          throw new Error(`Unknown AgentDefinition discriminator value: ${discriminator}`);
      }
    }

    throw new Error("Missing AgentDefinition discriminator property: 'kind'");
  }

  //#endregion

  //#region Save Methods

  /**
   * Save the AgentDefinition instance to a dictionary.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The dictionary representation of this instance.
   */
  save(context?: SaveContext): Record<string, unknown> {
    const obj = context ? (context.processObject(this) as AgentDefinition) : this;

    const result: Record<string, unknown> = {};

    if (obj.kind !== undefined && obj.kind !== null) {
      result["kind"] = obj.kind;
    }

    if (obj.name !== undefined && obj.name !== null) {
      result["name"] = obj.name;
    }

    if (obj.displayName !== undefined && obj.displayName !== null) {
      result["displayName"] = obj.displayName;
    }

    if (obj.description !== undefined && obj.description !== null) {
      result["description"] = obj.description;
    }

    if (obj.metadata !== undefined && obj.metadata !== null) {
      result["metadata"] = obj.metadata;
    }

    if (obj.inputSchema !== undefined && obj.inputSchema !== null) {
      result["inputSchema"] = obj.inputSchema?.save(context);
    }

    if (obj.outputSchema !== undefined && obj.outputSchema !== null) {
      result["outputSchema"] = obj.outputSchema?.save(context);
    }

    if (context) {
      return context.processDict(result);
    }

    return result;
  }

  /**
   * Convert the AgentDefinition instance to a YAML string.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The YAML string representation of this instance.
   */
  toYaml(context?: SaveContext): string {
    context = context ?? new SaveContext();
    return context.toYaml(this.save(context));
  }

  /**
   * Convert the AgentDefinition instance to a JSON string.
   * @param context - Optional context with pre/post processing callbacks.
   * @param indent - Number of spaces for indentation. Defaults to 2.
   * @returns The JSON string representation of this instance.
   */
  toJson(context?: SaveContext, indent: number = 2): string {
    context = context ?? new SaveContext();
    return context.toJson(this.save(context), indent);
  }

  /**
   * Load a AgentDefinition instance from a JSON string.
   * @param json - The JSON string to parse.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded AgentDefinition instance.
   */
  static fromJson(json: string, context?: LoadContext): AgentDefinition {
    const data = JSON.parse(json);

    return AgentDefinition.load(data as Record<string, unknown>, context);
  }

  /**
   * Load a AgentDefinition instance from a YAML string.
   * @param yaml - The YAML string to parse.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded AgentDefinition instance.
   */
  static fromYaml(yaml: string, context?: LoadContext): AgentDefinition {
    const { parse } = require("yaml");
    const data = parse(yaml);

    return AgentDefinition.load(data as Record<string, unknown>, context);
  }

  //#endregion
}

/**
 * Prompt based agent definition. Used to create agents that can be executed directly.
 * These agents can leverage tools, input parameters, and templates to generate responses.
 * They are designed to be straightforward and easy to use for various applications.
 *
 */
export class PromptAgent extends AgentDefinition {
  /**
   * The shorthand property name for this type, if any.
   */
  static readonly shorthandProperty: string | undefined = undefined;

  /**
   * Type of agent, e.g., 'prompt'
   */
  kind: string = "prompt";

  /**
   * Primary AI model configuration for the agent
   */
  model: Model;

  /**
   * Tools available to the agent for extended functionality
   */
  tools?: Tool[] = [];

  /**
   * Template configuration for prompt rendering
   */
  template?: Template | undefined;

  /**
   * Give your agent clear directions on what to do and how to do it. Include specific tasks, their order, and any special instructions like tone or engagement style. (can use this for a pure yaml declaration or as content in the markdown format)
   */
  instructions?: string | undefined;

  /**
   * Additional instructions or context for the agent, can be used to provide extra guidance (can use this for a pure yaml declaration)
   */
  additionalInstructions?: string | undefined;

  /**
   * Initializes a new instance of PromptAgent.
   */
  constructor(init?: Partial<PromptAgent>) {
    super(init);

    this.kind = init?.kind ?? "prompt";

    this.model = init?.model ?? undefined!;

    if (init?.tools !== undefined) {
      this.tools = init.tools;
    }

    if (init?.template !== undefined) {
      this.template = init.template;
    }

    if (init?.instructions !== undefined) {
      this.instructions = init.instructions;
    }

    if (init?.additionalInstructions !== undefined) {
      this.additionalInstructions = init.additionalInstructions;
    }
  }

  //#region Load Methods

  /**
   * Load a PromptAgent instance from a dictionary.
   * @param data - The dictionary containing the data.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded PromptAgent instance.
   */
  static load(data: Record<string, unknown>, context?: LoadContext): PromptAgent {
    if (context) {
      data = context.processInput(data);
    }

    // Create new instance
    const instance = new PromptAgent();

    if (data["kind"] !== undefined && data["kind"] !== null) {
      instance.kind = String(data["kind"]);
    }

    if (data["model"] !== undefined && data["model"] !== null) {
      instance.model = Model.load(data["model"] as Record<string, unknown>, context);
    }

    if (data["tools"] !== undefined && data["tools"] !== null) {
      instance.tools = PromptAgent.loadTools(data["tools"], context);
    }

    if (data["template"] !== undefined && data["template"] !== null) {
      instance.template = Template.load(data["template"] as Record<string, unknown>, context);
    }

    if (data["instructions"] !== undefined && data["instructions"] !== null) {
      instance.instructions = String(data["instructions"]);
    }

    if (data["additionalInstructions"] !== undefined && data["additionalInstructions"] !== null) {
      instance.additionalInstructions = String(data["additionalInstructions"]);
    }

    if (context) {
      return context.processOutput(instance) as PromptAgent;
    }
    return instance;
  }

  /**
   * Load a collection of Tool from a dictionary or array.
   * @param data - The data to load from.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded array of Tool.
   */
  static loadTools(data: unknown, context?: LoadContext): Tool[] {
    const result: Tool[] = [];

    if (data && typeof data === "object" && !Array.isArray(data)) {
      // Convert named dictionary to array
      for (const [key, value] of Object.entries(data as Record<string, unknown>)) {
        if (value && typeof value === "object" && !Array.isArray(value)) {
          // Value is an object, add name to it
          (value as Record<string, unknown>)["name"] = key;
          result.push(Tool.load(value as Record<string, unknown>, context));
        } else {
          // Value is a scalar, use it as the primary property
          const newObj: Record<string, unknown> = {
            name: key,
            kind: value,
          };
          result.push(Tool.load(newObj, context));
        }
      }
    } else if (Array.isArray(data)) {
      for (const item of data) {
        if (item && typeof item === "object") {
          result.push(Tool.load(item as Record<string, unknown>, context));
        }
      }
    }

    return result;
  }

  //#endregion

  //#region Save Methods

  /**
   * Save the PromptAgent instance to a dictionary.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The dictionary representation of this instance.
   */
  save(context?: SaveContext): Record<string, unknown> {
    const obj = context ? (context.processObject(this) as PromptAgent) : this;

    // Start with parent class properties
    const result = super.save(context);

    if (obj.kind !== undefined && obj.kind !== null) {
      result["kind"] = obj.kind;
    }

    if (obj.model !== undefined && obj.model !== null) {
      result["model"] = obj.model?.save(context);
    }

    if (obj.tools !== undefined && obj.tools !== null) {
      result["tools"] = PromptAgent.saveTools(obj.tools, context);
    }

    if (obj.template !== undefined && obj.template !== null) {
      result["template"] = obj.template?.save(context);
    }

    if (obj.instructions !== undefined && obj.instructions !== null) {
      result["instructions"] = obj.instructions;
    }

    if (obj.additionalInstructions !== undefined && obj.additionalInstructions !== null) {
      result["additionalInstructions"] = obj.additionalInstructions;
    }

    return result;
  }

  /**
   * Save a collection of Tool to object or array format.
   * @param items - The items to save.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The saved collection in object or array format.
   */
  static saveTools(
    items: Tool[],
    context?: SaveContext
  ): Record<string, unknown> | Record<string, unknown>[] {
    context = context ?? new SaveContext();

    if (context.collectionFormat === "array") {
      return items.map((item) => item.save(context));
    }

    // Object format: use name as key
    const result: Record<string, unknown> = {};
    for (const item of items) {
      const itemData = item.save(context);
      const name = itemData["name"] as string | undefined;
      if (name) {
        delete itemData["name"];

        // Check if we can use shorthand
        if (context.useShorthand && Tool.shorthandProperty) {
          const shorthandProp = Tool.shorthandProperty;
          const keys = Object.keys(itemData);
          if (keys.length === 1 && keys[0] === shorthandProp) {
            result[name] = itemData[shorthandProp];
            continue;
          }
        }
        result[name] = itemData;
      } else {
        throw new Error("Cannot save item in object format: missing 'name' property");
      }
    }
    return result;
  }

  /**
   * Convert the PromptAgent instance to a YAML string.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The YAML string representation of this instance.
   */
  toYaml(context?: SaveContext): string {
    context = context ?? new SaveContext();
    return context.toYaml(this.save(context));
  }

  /**
   * Convert the PromptAgent instance to a JSON string.
   * @param context - Optional context with pre/post processing callbacks.
   * @param indent - Number of spaces for indentation. Defaults to 2.
   * @returns The JSON string representation of this instance.
   */
  toJson(context?: SaveContext, indent: number = 2): string {
    context = context ?? new SaveContext();
    return context.toJson(this.save(context), indent);
  }

  /**
   * Load a PromptAgent instance from a JSON string.
   * @param json - The JSON string to parse.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded PromptAgent instance.
   */
  static fromJson(json: string, context?: LoadContext): PromptAgent {
    const data = JSON.parse(json);

    return PromptAgent.load(data as Record<string, unknown>, context);
  }

  /**
   * Load a PromptAgent instance from a YAML string.
   * @param yaml - The YAML string to parse.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded PromptAgent instance.
   */
  static fromYaml(yaml: string, context?: LoadContext): PromptAgent {
    const { parse } = require("yaml");
    const data = parse(yaml);

    return PromptAgent.load(data as Record<string, unknown>, context);
  }

  //#endregion
}

/**
 * A workflow agent that can orchestrate multiple steps and actions.
 * This agent type is designed to handle complex workflows that may involve
 * multiple tools, models, and decision points.
 *
 * The workflow agent can be configured with a series of steps that define
 * the flow of execution, including conditional logic and parallel processing.
 * This allows for the creation of sophisticated AI-driven processes that can
 * adapt to various scenarios and requirements.
 *
 * Note: The detailed structure of the workflow steps and actions is not defined here
 * and would need to be implemented based on specific use cases and requirements.
 *
 */
export class Workflow extends AgentDefinition {
  /**
   * The shorthand property name for this type, if any.
   */
  static readonly shorthandProperty: string | undefined = undefined;

  /**
   * Type of agent, e.g., 'workflow'
   */
  kind: string = "workflow";

  /**
   * The steps that make up the workflow
   */
  trigger?: Record<string, unknown> | undefined = {};

  /**
   * Initializes a new instance of Workflow.
   */
  constructor(init?: Partial<Workflow>) {
    super(init);

    this.kind = init?.kind ?? "workflow";

    if (init?.trigger !== undefined) {
      this.trigger = init.trigger;
    }
  }

  //#region Load Methods

  /**
   * Load a Workflow instance from a dictionary.
   * @param data - The dictionary containing the data.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded Workflow instance.
   */
  static load(data: Record<string, unknown>, context?: LoadContext): Workflow {
    if (context) {
      data = context.processInput(data);
    }

    // Create new instance
    const instance = new Workflow();

    if (data["kind"] !== undefined && data["kind"] !== null) {
      instance.kind = String(data["kind"]);
    }

    if (data["trigger"] !== undefined && data["trigger"] !== null) {
      instance.trigger = data["trigger"] as Record<string, unknown>;
    }

    if (context) {
      return context.processOutput(instance) as Workflow;
    }
    return instance;
  }

  //#endregion

  //#region Save Methods

  /**
   * Save the Workflow instance to a dictionary.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The dictionary representation of this instance.
   */
  save(context?: SaveContext): Record<string, unknown> {
    const obj = context ? (context.processObject(this) as Workflow) : this;

    // Start with parent class properties
    const result = super.save(context);

    if (obj.kind !== undefined && obj.kind !== null) {
      result["kind"] = obj.kind;
    }

    if (obj.trigger !== undefined && obj.trigger !== null) {
      result["trigger"] = obj.trigger;
    }

    return result;
  }

  /**
   * Convert the Workflow instance to a YAML string.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The YAML string representation of this instance.
   */
  toYaml(context?: SaveContext): string {
    context = context ?? new SaveContext();
    return context.toYaml(this.save(context));
  }

  /**
   * Convert the Workflow instance to a JSON string.
   * @param context - Optional context with pre/post processing callbacks.
   * @param indent - Number of spaces for indentation. Defaults to 2.
   * @returns The JSON string representation of this instance.
   */
  toJson(context?: SaveContext, indent: number = 2): string {
    context = context ?? new SaveContext();
    return context.toJson(this.save(context), indent);
  }

  /**
   * Load a Workflow instance from a JSON string.
   * @param json - The JSON string to parse.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded Workflow instance.
   */
  static fromJson(json: string, context?: LoadContext): Workflow {
    const data = JSON.parse(json);

    return Workflow.load(data as Record<string, unknown>, context);
  }

  /**
   * Load a Workflow instance from a YAML string.
   * @param yaml - The YAML string to parse.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded Workflow instance.
   */
  static fromYaml(yaml: string, context?: LoadContext): Workflow {
    const { parse } = require("yaml");
    const data = parse(yaml);

    return Workflow.load(data as Record<string, unknown>, context);
  }

  //#endregion
}

/**
 * This represents a container based agent hosted by the provider/publisher.
 * The intent is to represent a container application that the user wants to run
 * in a hosted environment that the provider manages.
 *
 */
export class ContainerAgent extends AgentDefinition {
  /**
   * The shorthand property name for this type, if any.
   */
  static readonly shorthandProperty: string | undefined = undefined;

  /**
   * Type of agent, e.g., 'hosted'
   */
  kind: string = "hosted";

  /**
   * Protocol used by the containerized agent
   */
  protocols: ProtocolVersionRecord[] = [];

  /**
   * Resource allocation for the container
   */
  resources: ContainerResources;

  /**
   * Scaling configuration for the container
   */
  scale: ContainerScale;

  /**
   * Environment variables to set in the container
   */
  environmentVariables?: EnvironmentVariable[] = [];

  /**
   * Initializes a new instance of ContainerAgent.
   */
  constructor(init?: Partial<ContainerAgent>) {
    super(init);

    this.kind = init?.kind ?? "hosted";

    this.protocols = init?.protocols ?? [];

    this.resources = init?.resources ?? undefined!;

    this.scale = init?.scale ?? undefined!;

    if (init?.environmentVariables !== undefined) {
      this.environmentVariables = init.environmentVariables;
    }
  }

  //#region Load Methods

  /**
   * Load a ContainerAgent instance from a dictionary.
   * @param data - The dictionary containing the data.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded ContainerAgent instance.
   */
  static load(data: Record<string, unknown>, context?: LoadContext): ContainerAgent {
    if (context) {
      data = context.processInput(data);
    }

    // Create new instance
    const instance = new ContainerAgent();

    if (data["kind"] !== undefined && data["kind"] !== null) {
      instance.kind = String(data["kind"]);
    }

    if (data["protocols"] !== undefined && data["protocols"] !== null) {
      instance.protocols = ContainerAgent.loadProtocols(data["protocols"], context);
    }

    if (data["resources"] !== undefined && data["resources"] !== null) {
      instance.resources = ContainerResources.load(
        data["resources"] as Record<string, unknown>,
        context
      );
    }

    if (data["scale"] !== undefined && data["scale"] !== null) {
      instance.scale = ContainerScale.load(data["scale"] as Record<string, unknown>, context);
    }

    if (data["environmentVariables"] !== undefined && data["environmentVariables"] !== null) {
      instance.environmentVariables = ContainerAgent.loadEnvironmentVariables(
        data["environmentVariables"],
        context
      );
    }

    if (context) {
      return context.processOutput(instance) as ContainerAgent;
    }
    return instance;
  }

  /**
   * Load a collection of ProtocolVersionRecord from a dictionary or array.
   * @param data - The data to load from.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded array of ProtocolVersionRecord.
   */
  static loadProtocols(data: unknown, context?: LoadContext): ProtocolVersionRecord[] {
    const result: ProtocolVersionRecord[] = [];

    if (data && typeof data === "object" && !Array.isArray(data)) {
      // Convert named dictionary to array
      for (const [key, value] of Object.entries(data as Record<string, unknown>)) {
        if (value && typeof value === "object" && !Array.isArray(value)) {
          // Value is an object, add name to it
          (value as Record<string, unknown>)["name"] = key;
          result.push(ProtocolVersionRecord.load(value as Record<string, unknown>, context));
        } else {
          // Value is a scalar, use it as the primary property
          const newObj: Record<string, unknown> = {
            name: key,
            protocol: value,
          };
          result.push(ProtocolVersionRecord.load(newObj, context));
        }
      }
    } else if (Array.isArray(data)) {
      for (const item of data) {
        if (item && typeof item === "object") {
          result.push(ProtocolVersionRecord.load(item as Record<string, unknown>, context));
        }
      }
    }

    return result;
  }

  /**
   * Load a collection of EnvironmentVariable from a dictionary or array.
   * @param data - The data to load from.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded array of EnvironmentVariable.
   */
  static loadEnvironmentVariables(data: unknown, context?: LoadContext): EnvironmentVariable[] {
    const result: EnvironmentVariable[] = [];

    if (data && typeof data === "object" && !Array.isArray(data)) {
      // Convert named dictionary to array
      for (const [key, value] of Object.entries(data as Record<string, unknown>)) {
        if (value && typeof value === "object" && !Array.isArray(value)) {
          // Value is an object, add name to it
          (value as Record<string, unknown>)["name"] = key;
          result.push(EnvironmentVariable.load(value as Record<string, unknown>, context));
        } else {
          // Value is a scalar, use it as the primary property
          const newObj: Record<string, unknown> = {
            name: key,
            value: value,
          };
          result.push(EnvironmentVariable.load(newObj, context));
        }
      }
    } else if (Array.isArray(data)) {
      for (const item of data) {
        if (item && typeof item === "object") {
          result.push(EnvironmentVariable.load(item as Record<string, unknown>, context));
        }
      }
    }

    return result;
  }

  //#endregion

  //#region Save Methods

  /**
   * Save the ContainerAgent instance to a dictionary.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The dictionary representation of this instance.
   */
  save(context?: SaveContext): Record<string, unknown> {
    const obj = context ? (context.processObject(this) as ContainerAgent) : this;

    // Start with parent class properties
    const result = super.save(context);

    if (obj.kind !== undefined && obj.kind !== null) {
      result["kind"] = obj.kind;
    }

    if (obj.protocols !== undefined && obj.protocols !== null) {
      result["protocols"] = ContainerAgent.saveProtocols(obj.protocols, context);
    }

    if (obj.resources !== undefined && obj.resources !== null) {
      result["resources"] = obj.resources?.save(context);
    }

    if (obj.scale !== undefined && obj.scale !== null) {
      result["scale"] = obj.scale?.save(context);
    }

    if (obj.environmentVariables !== undefined && obj.environmentVariables !== null) {
      result["environmentVariables"] = ContainerAgent.saveEnvironmentVariables(
        obj.environmentVariables,
        context
      );
    }

    return result;
  }

  /**
   * Save a collection of ProtocolVersionRecord to object or array format.
   * @param items - The items to save.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The saved collection in object or array format.
   */
  static saveProtocols(
    items: ProtocolVersionRecord[],
    context?: SaveContext
  ): Record<string, unknown> | Record<string, unknown>[] {
    context = context ?? new SaveContext();

    // This type doesn't have a 'name' property, so always use array format
    return items.map((item) => item.save(context));
  }

  /**
   * Save a collection of EnvironmentVariable to object or array format.
   * @param items - The items to save.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The saved collection in object or array format.
   */
  static saveEnvironmentVariables(
    items: EnvironmentVariable[],
    context?: SaveContext
  ): Record<string, unknown> | Record<string, unknown>[] {
    context = context ?? new SaveContext();

    if (context.collectionFormat === "array") {
      return items.map((item) => item.save(context));
    }

    // Object format: use name as key
    const result: Record<string, unknown> = {};
    for (const item of items) {
      const itemData = item.save(context);
      const name = itemData["name"] as string | undefined;
      if (name) {
        delete itemData["name"];

        // Check if we can use shorthand
        if (context.useShorthand && EnvironmentVariable.shorthandProperty) {
          const shorthandProp = EnvironmentVariable.shorthandProperty;
          const keys = Object.keys(itemData);
          if (keys.length === 1 && keys[0] === shorthandProp) {
            result[name] = itemData[shorthandProp];
            continue;
          }
        }
        result[name] = itemData;
      } else {
        throw new Error("Cannot save item in object format: missing 'name' property");
      }
    }
    return result;
  }

  /**
   * Convert the ContainerAgent instance to a YAML string.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The YAML string representation of this instance.
   */
  toYaml(context?: SaveContext): string {
    context = context ?? new SaveContext();
    return context.toYaml(this.save(context));
  }

  /**
   * Convert the ContainerAgent instance to a JSON string.
   * @param context - Optional context with pre/post processing callbacks.
   * @param indent - Number of spaces for indentation. Defaults to 2.
   * @returns The JSON string representation of this instance.
   */
  toJson(context?: SaveContext, indent: number = 2): string {
    context = context ?? new SaveContext();
    return context.toJson(this.save(context), indent);
  }

  /**
   * Load a ContainerAgent instance from a JSON string.
   * @param json - The JSON string to parse.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded ContainerAgent instance.
   */
  static fromJson(json: string, context?: LoadContext): ContainerAgent {
    const data = JSON.parse(json);

    return ContainerAgent.load(data as Record<string, unknown>, context);
  }

  /**
   * Load a ContainerAgent instance from a YAML string.
   * @param yaml - The YAML string to parse.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded ContainerAgent instance.
   */
  static fromYaml(yaml: string, context?: LoadContext): ContainerAgent {
    const { parse } = require("yaml");
    const data = parse(yaml);

    return ContainerAgent.load(data as Record<string, unknown>, context);
  }

  //#endregion
}
