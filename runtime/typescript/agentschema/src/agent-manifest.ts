// Copyright (c) Microsoft. All rights reserved.
// WARNING: This is an auto-generated file. DO NOT EDIT THIS FILE DIRECTLY.

import { LoadContext, SaveContext } from "./context";
import { AgentDefinition } from "./agent-definition";
import { PropertySchema } from "./property-schema";
import { Resource } from "./resource";

/**
 * The following represents a manifest that can be used to create agents dynamically.
 * It includes parameters that can be used to configure the agent's behavior.
 * These parameters include values that can be used as publisher parameters that can
 * be used to describe additional variables that have been tested and are known to work.
 *
 * Variables described here are then used to project into a prompt agent that can be executed.
 * Once parameters are provided, these can be referenced in the manifest using the following notation:
 *
 * `{{myParameter}}`
 *
 * This allows for dynamic configuration of the agent based on the provided parameters.
 * (This notation is used elsewhere, but only the `param` scope is supported here)
 *
 */
export class AgentManifest {
  /**
   * The shorthand property name for this type, if any.
   */
  static readonly shorthandProperty: string | undefined = undefined;

  /**
   * Name of the manifest
   */
  name: string = "";

  /**
   * Human-readable name of the manifest
   */
  displayName: string = "";

  /**
   * Description of the agent's capabilities and purpose
   */
  description?: string | undefined;

  /**
   * Additional metadata including authors, tags, and other arbitrary properties
   */
  metadata?: Record<string, unknown> | undefined = {};

  /**
   * The agent that this manifest is based on
   */
  template: AgentDefinition;

  /**
   * Parameters for configuring the agent's behavior and execution
   */
  parameters: PropertySchema;

  /**
   * Resources required by the agent, such as models or tools
   */
  resources: Resource[] = [];

  /**
   * Initializes a new instance of AgentManifest.
   */
  constructor(init?: Partial<AgentManifest>) {
    this.name = init?.name ?? "";

    this.displayName = init?.displayName ?? "";

    if (init?.description !== undefined) {
      this.description = init.description;
    }

    if (init?.metadata !== undefined) {
      this.metadata = init.metadata;
    }

    this.template = init?.template ?? undefined!;

    this.parameters = init?.parameters ?? undefined!;

    this.resources = init?.resources ?? [];
  }

  //#region Load Methods

  /**
   * Load a AgentManifest instance from a dictionary.
   * @param data - The dictionary containing the data.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded AgentManifest instance.
   */
  static load(data: Record<string, unknown>, context?: LoadContext): AgentManifest {
    if (context) {
      data = context.processInput(data);
    }

    // Create new instance
    const instance = new AgentManifest();

    if (data["name"] !== undefined && data["name"] !== null) {
      instance.name = String(data["name"]);
    }

    if (data["displayName"] !== undefined && data["displayName"] !== null) {
      instance.displayName = String(data["displayName"]);
    }

    if (data["description"] !== undefined && data["description"] !== null) {
      instance.description = String(data["description"]);
    }

    if (data["metadata"] !== undefined && data["metadata"] !== null) {
      instance.metadata = data["metadata"] as Record<string, unknown>;
    }

    if (data["template"] !== undefined && data["template"] !== null) {
      instance.template = AgentDefinition.load(
        data["template"] as Record<string, unknown>,
        context
      );
    }

    if (data["parameters"] !== undefined && data["parameters"] !== null) {
      instance.parameters = PropertySchema.load(
        data["parameters"] as Record<string, unknown>,
        context
      );
    }

    if (data["resources"] !== undefined && data["resources"] !== null) {
      instance.resources = AgentManifest.loadResources(data["resources"], context);
    }

    if (context) {
      return context.processOutput(instance) as AgentManifest;
    }
    return instance;
  }

  /**
   * Load a collection of Resource from a dictionary or array.
   * @param data - The data to load from.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded array of Resource.
   */
  static loadResources(data: unknown, context?: LoadContext): Resource[] {
    const result: Resource[] = [];

    if (data && typeof data === "object" && !Array.isArray(data)) {
      // Convert named dictionary to array
      for (const [key, value] of Object.entries(data as Record<string, unknown>)) {
        if (value && typeof value === "object" && !Array.isArray(value)) {
          // Value is an object, add name to it
          (value as Record<string, unknown>)["name"] = key;
          result.push(Resource.load(value as Record<string, unknown>, context));
        } else {
          // Value is a scalar, use it as the primary property
          const newObj: Record<string, unknown> = {
            name: key,
            kind: value,
          };
          result.push(Resource.load(newObj, context));
        }
      }
    } else if (Array.isArray(data)) {
      for (const item of data) {
        if (item && typeof item === "object") {
          result.push(Resource.load(item as Record<string, unknown>, context));
        }
      }
    }

    return result;
  }

  //#endregion

  //#region Save Methods

  /**
   * Save the AgentManifest instance to a dictionary.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The dictionary representation of this instance.
   */
  save(context?: SaveContext): Record<string, unknown> {
    const obj = context ? (context.processObject(this) as AgentManifest) : this;

    const result: Record<string, unknown> = {};

    if (obj.name !== undefined && obj.name !== null) {
      result["name"] = obj.name;
    }

    if (obj.displayName !== undefined && obj.displayName !== null) {
      result["displayName"] = obj.displayName;
    }

    if (obj.description !== undefined && obj.description !== null) {
      result["description"] = obj.description;
    }

    if (obj.metadata !== undefined && obj.metadata !== null) {
      result["metadata"] = obj.metadata;
    }

    if (obj.template !== undefined && obj.template !== null) {
      result["template"] = obj.template?.save(context);
    }

    if (obj.parameters !== undefined && obj.parameters !== null) {
      result["parameters"] = obj.parameters?.save(context);
    }

    if (obj.resources !== undefined && obj.resources !== null) {
      result["resources"] = AgentManifest.saveResources(obj.resources, context);
    }

    if (context) {
      return context.processDict(result);
    }

    return result;
  }

  /**
   * Save a collection of Resource to object or array format.
   * @param items - The items to save.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The saved collection in object or array format.
   */
  static saveResources(
    items: Resource[],
    context?: SaveContext
  ): Record<string, unknown> | Record<string, unknown>[] {
    context = context ?? new SaveContext();

    if (context.collectionFormat === "array") {
      return items.map((item) => item.save(context));
    }

    // Object format: use name as key
    const result: Record<string, unknown> = {};
    for (const item of items) {
      const itemData = item.save(context);
      const name = itemData["name"] as string | undefined;
      if (name) {
        delete itemData["name"];

        // Check if we can use shorthand
        if (context.useShorthand && Resource.shorthandProperty) {
          const shorthandProp = Resource.shorthandProperty;
          const keys = Object.keys(itemData);
          if (keys.length === 1 && keys[0] === shorthandProp) {
            result[name] = itemData[shorthandProp];
            continue;
          }
        }
        result[name] = itemData;
      } else {
        throw new Error("Cannot save item in object format: missing 'name' property");
      }
    }
    return result;
  }

  /**
   * Convert the AgentManifest instance to a YAML string.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The YAML string representation of this instance.
   */
  toYaml(context?: SaveContext): string {
    context = context ?? new SaveContext();
    return context.toYaml(this.save(context));
  }

  /**
   * Convert the AgentManifest instance to a JSON string.
   * @param context - Optional context with pre/post processing callbacks.
   * @param indent - Number of spaces for indentation. Defaults to 2.
   * @returns The JSON string representation of this instance.
   */
  toJson(context?: SaveContext, indent: number = 2): string {
    context = context ?? new SaveContext();
    return context.toJson(this.save(context), indent);
  }

  /**
   * Load a AgentManifest instance from a JSON string.
   * @param json - The JSON string to parse.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded AgentManifest instance.
   */
  static fromJson(json: string, context?: LoadContext): AgentManifest {
    const data = JSON.parse(json);

    return AgentManifest.load(data as Record<string, unknown>, context);
  }

  /**
   * Load a AgentManifest instance from a YAML string.
   * @param yaml - The YAML string to parse.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded AgentManifest instance.
   */
  static fromYaml(yaml: string, context?: LoadContext): AgentManifest {
    const { parse } = require("yaml");
    const data = parse(yaml);

    return AgentManifest.load(data as Record<string, unknown>, context);
  }

  //#endregion
}
