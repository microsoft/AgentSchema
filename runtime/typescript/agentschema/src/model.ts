// Copyright (c) Microsoft. All rights reserved.
// WARNING: This is an auto-generated file. DO NOT EDIT THIS FILE DIRECTLY.

import { LoadContext, SaveContext } from "./context";
import { Connection } from "./connection";
import { ModelOptions } from "./model-options";

/**
 * Model for defining the structure and behavior of AI agents.
 * This model includes properties for specifying the model's provider, connection details, and various options.
 * It allows for flexible configuration of AI models to suit different use cases and requirements.
 *
 */
export class Model {
  /**
   * The shorthand property name for this type, if any.
   */
  static readonly shorthandProperty: string | undefined = "id";

  /**
   * The unique identifier of the model - can be used as the single property shorthand
   */
  id: string = "";

  /**
   * The provider of the model (e.g., 'openai', 'azure', 'anthropic')
   */
  provider?: string | undefined;

  /**
   * The type of API to use for the model (e.g., 'chat', 'response', etc.)
   */
  apiType?: string | undefined;

  /**
   * The connection configuration for the model
   */
  connection?: Connection | undefined;

  /**
   * Additional options for the model
   */
  options?: ModelOptions | undefined;

  /**
   * Initializes a new instance of Model.
   */
  constructor(init?: Partial<Model>) {
    this.id = init?.id ?? "";

    if (init?.provider !== undefined) {
      this.provider = init.provider;
    }

    if (init?.apiType !== undefined) {
      this.apiType = init.apiType;
    }

    if (init?.connection !== undefined) {
      this.connection = init.connection;
    }

    if (init?.options !== undefined) {
      this.options = init.options;
    }
  }

  //#region Load Methods

  /**
   * Load a Model instance from a dictionary.
   * @param data - The dictionary containing the data.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded Model instance.
   */
  static load(data: Record<string, unknown>, context?: LoadContext): Model {
    if (context) {
      data = context.processInput(data);
    }

    // Handle alternate representations
    if (typeof data === "string") {
      data = { id: data };
    } else if (typeof data === "number") {
    } else if (typeof data === "boolean") {
    }

    // Create new instance
    const instance = new Model();

    if (data["id"] !== undefined && data["id"] !== null) {
      instance.id = String(data["id"]);
    }

    if (data["provider"] !== undefined && data["provider"] !== null) {
      instance.provider = String(data["provider"]);
    }

    if (data["apiType"] !== undefined && data["apiType"] !== null) {
      instance.apiType = String(data["apiType"]);
    }

    if (data["connection"] !== undefined && data["connection"] !== null) {
      instance.connection = Connection.load(data["connection"] as Record<string, unknown>, context);
    }

    if (data["options"] !== undefined && data["options"] !== null) {
      instance.options = ModelOptions.load(data["options"] as Record<string, unknown>, context);
    }

    if (context) {
      return context.processOutput(instance) as Model;
    }
    return instance;
  }

  //#endregion

  //#region Save Methods

  /**
   * Save the Model instance to a dictionary.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The dictionary representation of this instance.
   */
  save(context?: SaveContext): Record<string, unknown> {
    const obj = context ? (context.processObject(this) as Model) : this;

    const result: Record<string, unknown> = {};

    if (obj.id !== undefined && obj.id !== null) {
      result["id"] = obj.id;
    }

    if (obj.provider !== undefined && obj.provider !== null) {
      result["provider"] = obj.provider;
    }

    if (obj.apiType !== undefined && obj.apiType !== null) {
      result["apiType"] = obj.apiType;
    }

    if (obj.connection !== undefined && obj.connection !== null) {
      result["connection"] = obj.connection?.save(context);
    }

    if (obj.options !== undefined && obj.options !== null) {
      result["options"] = obj.options?.save(context);
    }

    if (context) {
      return context.processDict(result);
    }

    return result;
  }

  /**
   * Convert the Model instance to a YAML string.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The YAML string representation of this instance.
   */
  toYaml(context?: SaveContext): string {
    context = context ?? new SaveContext();
    return context.toYaml(this.save(context));
  }

  /**
   * Convert the Model instance to a JSON string.
   * @param context - Optional context with pre/post processing callbacks.
   * @param indent - Number of spaces for indentation. Defaults to 2.
   * @returns The JSON string representation of this instance.
   */
  toJson(context?: SaveContext, indent: number = 2): string {
    context = context ?? new SaveContext();
    return context.toJson(this.save(context), indent);
  }

  /**
   * Load a Model instance from a JSON string.
   * @param json - The JSON string to parse.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded Model instance.
   */
  static fromJson(json: string, context?: LoadContext): Model {
    const data = JSON.parse(json);

    // Handle alternate representations
    if (typeof data !== "object" || data === null || Array.isArray(data)) {
      if (typeof data === "string") {
        return Model.load({ id: data }, context);
      } else if (typeof data === "number") {
        // Check if it's an integer or float
        if (Number.isInteger(data)) {
        } else {
        }
      } else if (typeof data === "boolean") {
      }
      // Fallback - shouldn't reach here
      return Model.load({ id: data }, context);
    }

    return Model.load(data as Record<string, unknown>, context);
  }

  /**
   * Load a Model instance from a YAML string.
   * @param yaml - The YAML string to parse.
   * @param context - Optional context with pre/post processing callbacks.
   * @returns The loaded Model instance.
   */
  static fromYaml(yaml: string, context?: LoadContext): Model {
    const { parse } = require("yaml");
    const data = parse(yaml);

    // Handle alternate representations
    if (typeof data !== "object" || data === null || Array.isArray(data)) {
      if (typeof data === "string") {
        return Model.load({ id: data }, context);
      } else if (typeof data === "number") {
        // Check if it's an integer or float
        if (Number.isInteger(data)) {
        } else {
        }
      } else if (typeof data === "boolean") {
      }
      // Fallback - shouldn't reach here
      return Model.load({ id: data }, context);
    }

    return Model.load(data as Record<string, unknown>, context);
  }

  //#endregion
}
