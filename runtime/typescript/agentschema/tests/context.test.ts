// Copyright (c) Microsoft. All rights reserved.
// WARNING: This is an auto-generated file. DO NOT EDIT THIS FILE DIRECTLY.

import { LoadContext, SaveContext } from "../src/context";

describe("LoadContext", () => {
  describe("default values", () => {
    it("should have undefined preProcess by default", () => {
      const context = new LoadContext();
      expect(context.preProcess).toBeUndefined();
    });

    it("should have undefined postProcess by default", () => {
      const context = new LoadContext();
      expect(context.postProcess).toBeUndefined();
    });
  });

  describe("processInput", () => {
    it("should return original data when no callback set", () => {
      const context = new LoadContext();
      const data = { key: "value", nested: { a: 1 } };
      const result = context.processInput(data);
      expect(result).toBe(data);
    });

    it("should apply preProcess callback", () => {
      const addField = (data: Record<string, unknown>) => ({ ...data, added: true });
      const context = new LoadContext({ preProcess: addField });
      const data = { key: "value" };
      const result = context.processInput(data);
      expect(result).toEqual({ key: "value", added: true });
      expect(result).not.toBe(data);
    });
  });

  describe("processOutput", () => {
    it("should return original result when no callback set", () => {
      const context = new LoadContext();
      const result = { some: "result" };
      const processed = context.processOutput(result);
      expect(processed).toBe(result);
    });

    it("should apply postProcess callback", () => {
      const wrapResult = (result: unknown) => ({ wrapped: result });
      const context = new LoadContext({ postProcess: wrapResult });
      const result = { key: "value" };
      const processed = context.processOutput(result);
      expect(processed).toEqual({ wrapped: { key: "value" } });
    });
  });

  describe("both callbacks", () => {
    it("should support both preProcess and postProcess", () => {
      const normalizeKeys = (data: Record<string, unknown>) => {
        const result: Record<string, unknown> = {};
        for (const [k, v] of Object.entries(data)) {
          result[k.toLowerCase()] = v;
        }
        return result;
      };
      const addMetadata = (result: unknown) => ({ ...(result as object), _processed: true });

      const context = new LoadContext({ preProcess: normalizeKeys, postProcess: addMetadata });

      const inputData = { Key: "value", UPPER: "case" };
      const processedInput = context.processInput(inputData);
      expect(processedInput).toEqual({ key: "value", upper: "case" });

      const finalResult = context.processOutput(processedInput);
      expect(finalResult).toEqual({ key: "value", upper: "case", _processed: true });
    });
  });
});

describe("SaveContext", () => {
  describe("default values", () => {
    it("should have undefined preSave by default", () => {
      const context = new SaveContext();
      expect(context.preSave).toBeUndefined();
    });

    it("should have undefined postSave by default", () => {
      const context = new SaveContext();
      expect(context.postSave).toBeUndefined();
    });

    it("should have collectionFormat 'object' by default", () => {
      const context = new SaveContext();
      expect(context.collectionFormat).toBe("object");
    });

    it("should have useShorthand true by default", () => {
      const context = new SaveContext();
      expect(context.useShorthand).toBe(true);
    });
  });

  describe("processObject", () => {
    it("should return original object when no callback set", () => {
      const context = new SaveContext();
      const obj = { key: "value" };
      const result = context.processObject(obj);
      expect(result).toBe(obj);
    });

    it("should apply preSave callback", () => {
      const addTimestamp = (obj: unknown) => ({ ...(obj as object), timestamp: "2024-01-01" });
      const context = new SaveContext({ preSave: addTimestamp });
      const obj = { key: "value" };
      const result = context.processObject(obj);
      expect(result).toEqual({ key: "value", timestamp: "2024-01-01" });
    });
  });

  describe("processDict", () => {
    it("should return original dict when no callback set", () => {
      const context = new SaveContext();
      const data = { key: "value" };
      const result = context.processDict(data);
      expect(result).toBe(data);
    });

    it("should apply postSave callback", () => {
      const removeInternal = (data: Record<string, unknown>) => {
        const result: Record<string, unknown> = {};
        for (const [k, v] of Object.entries(data)) {
          if (!k.startsWith("_")) {
            result[k] = v;
          }
        }
        return result;
      };
      const context = new SaveContext({ postSave: removeInternal });
      const data = { key: "value", _internal: "secret" };
      const result = context.processDict(data);
      expect(result).toEqual({ key: "value" });
    });
  });

  describe("both callbacks", () => {
    it("should support both preSave and postSave", () => {
      const markForExport = (obj: unknown) => ({ ...(obj as object), _exporting: true });
      const cleanMarkers = (data: Record<string, unknown>) => {
        const result: Record<string, unknown> = {};
        for (const [k, v] of Object.entries(data)) {
          if (!k.startsWith("_")) {
            result[k] = v;
          }
        }
        return result;
      };

      const context = new SaveContext({ preSave: markForExport, postSave: cleanMarkers });

      const obj = { name: "test", value: 42 };
      const processedObj = context.processObject(obj);
      expect(processedObj).toEqual({ name: "test", value: 42, _exporting: true });

      const finalDict = context.processDict(processedObj as Record<string, unknown>);
      expect(finalDict).toEqual({ name: "test", value: 42 });
    });
  });

  describe("toYaml", () => {
    it("should produce valid YAML string", () => {
      const context = new SaveContext();
      const data = { name: "test", items: ["a", "b"] };
      const result = context.toYaml(data);
      expect(result).toContain("name: test");
      expect(result).toContain("items:");
    });
  });

  describe("toJson", () => {
    it("should produce valid JSON string", () => {
      const context = new SaveContext();
      const data = { name: "test", items: ["a", "b"] };
      const result = context.toJson(data);
      const parsed = JSON.parse(result);
      expect(parsed).toEqual(data);
    });

    it("should respect custom indent", () => {
      const context = new SaveContext();
      const data = { name: "test" };
      const result2 = context.toJson(data, 2);
      const result4 = context.toJson(data, 4);
      expect(result4.length).toBeGreaterThan(result2.length);
    });
  });

  describe("options", () => {
    it("should allow setting collectionFormat to array", () => {
      const context = new SaveContext({ collectionFormat: "array" });
      expect(context.collectionFormat).toBe("array");
    });

    it("should allow disabling useShorthand", () => {
      const context = new SaveContext({ useShorthand: false });
      expect(context.useShorthand).toBe(false);
    });
  });
});
