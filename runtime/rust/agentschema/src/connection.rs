// Code generated by AgentSchema emitter; DO NOT EDIT.

use crate::context::{LoadContext, SaveContext};

/// Connection configuration for AI agents.
/// `provider`, `kind`, and `endpoint` are required properties here,
/// but this section can accept additional via options.
#[derive(Debug, Clone)]
pub struct Connection {
    /// The Authentication kind for the AI service (e.g., 'key' for API key, 'oauth' for OAuth tokens)
    pub kind: String,
    /// The authority level for the connection, indicating under whose authority the connection is made (e.g., 'user', 'agent', 'system')
    pub authentication_mode: String,
    /// The usage description for the connection, providing context on how this connection will be used
    pub usage_description: Option<String>,
}

impl Default for Connection {
    fn default() -> Self {
        Connection {
            kind: String::from(""),
            authentication_mode: String::from("system"),
            usage_description: None,
        }
    }
}

impl Connection {
    /// Create a new Connection with default values.
    pub fn new() -> Self {
        Self::default()
    }

    /// Load Connection from a JSON string.
    pub fn from_json(json: &str) -> Result<Self, serde_json::Error> {
        let value: serde_json::Value = serde_json::from_str(json)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load Connection from a YAML string.
    pub fn from_yaml(yaml: &str) -> Result<Self, serde_yaml::Error> {
        let value: serde_json::Value = serde_yaml::from_str(yaml)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load Connection from a `serde_json::Value`.
    pub fn load_from_value(value: &serde_json::Value) -> Self {
        let mut result = Self::default();
        // Load fields from JSON object
        result.kind = value
            .get("kind")
            .and_then(|v| v.as_str())
            .unwrap_or_default()
            .to_string();
        result.authentication_mode = value
            .get("authenticationMode")
            .and_then(|v| v.as_str())
            .unwrap_or_default()
            .to_string();
        result.usage_description = value
            .get("usageDescription")
            .and_then(|v| v.as_str())
            .map(|s| s.to_string());
        result
    }

    /// Serialize Connection to a `serde_json::Value`.
    pub fn to_value(&self) -> serde_json::Value {
        let mut result = serde_json::Map::new();
        if !self.kind.is_empty() {
            result.insert(
                "kind".to_string(),
                serde_json::Value::String(self.kind.clone()),
            );
        }
        if !self.authentication_mode.is_empty() {
            result.insert(
                "authenticationMode".to_string(),
                serde_json::Value::String(self.authentication_mode.clone()),
            );
        }
        if let Some(ref val) = self.usage_description {
            result.insert(
                "usageDescription".to_string(),
                serde_json::Value::String(val.clone()),
            );
        }
        serde_json::Value::Object(result)
    }

    /// Serialize Connection to a JSON string.
    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string_pretty(&self.to_value())
    }

    /// Serialize Connection to a YAML string.
    pub fn to_yaml(&self) -> Result<String, serde_yaml::Error> {
        serde_yaml::to_string(&self.to_value())
    }
}

/// Connection configuration for AI services using named connections.
#[derive(Debug, Clone)]
pub struct ReferenceConnection {
    /// The Authentication kind for the AI service (e.g., 'key' for API key, 'oauth' for OAuth tokens)
    pub kind: String,
    /// The name of the connection
    pub name: String,
    /// The target resource or service that this connection refers to
    pub target: Option<String>,
}

impl Default for ReferenceConnection {
    fn default() -> Self {
        ReferenceConnection {
            kind: String::from("reference"),
            name: String::from(""),
            target: None,
        }
    }
}

impl ReferenceConnection {
    /// Create a new ReferenceConnection with default values.
    pub fn new() -> Self {
        Self::default()
    }

    /// Load ReferenceConnection from a JSON string.
    pub fn from_json(json: &str) -> Result<Self, serde_json::Error> {
        let value: serde_json::Value = serde_json::from_str(json)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load ReferenceConnection from a YAML string.
    pub fn from_yaml(yaml: &str) -> Result<Self, serde_yaml::Error> {
        let value: serde_json::Value = serde_yaml::from_str(yaml)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load ReferenceConnection from a `serde_json::Value`.
    pub fn load_from_value(value: &serde_json::Value) -> Self {
        let mut result = Self::default();
        // Load fields from JSON object
        result.kind = value
            .get("kind")
            .and_then(|v| v.as_str())
            .unwrap_or_default()
            .to_string();
        result.name = value
            .get("name")
            .and_then(|v| v.as_str())
            .unwrap_or_default()
            .to_string();
        result.target = value
            .get("target")
            .and_then(|v| v.as_str())
            .map(|s| s.to_string());
        result
    }

    /// Serialize ReferenceConnection to a `serde_json::Value`.
    pub fn to_value(&self) -> serde_json::Value {
        let mut result = serde_json::Map::new();
        if !self.kind.is_empty() {
            result.insert(
                "kind".to_string(),
                serde_json::Value::String(self.kind.clone()),
            );
        }
        if !self.name.is_empty() {
            result.insert(
                "name".to_string(),
                serde_json::Value::String(self.name.clone()),
            );
        }
        if let Some(ref val) = self.target {
            result.insert("target".to_string(), serde_json::Value::String(val.clone()));
        }
        serde_json::Value::Object(result)
    }

    /// Serialize ReferenceConnection to a JSON string.
    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string_pretty(&self.to_value())
    }

    /// Serialize ReferenceConnection to a YAML string.
    pub fn to_yaml(&self) -> Result<String, serde_yaml::Error> {
        serde_yaml::to_string(&self.to_value())
    }
}

/// Connection configuration for AI services using named connections.
#[derive(Debug, Clone)]
pub struct RemoteConnection {
    /// The Authentication kind for the AI service (e.g., 'key' for API key, 'oauth' for OAuth tokens)
    pub kind: String,
    /// The name of the connection
    pub name: String,
    /// The endpoint URL for the AI service
    pub endpoint: String,
}

impl Default for RemoteConnection {
    fn default() -> Self {
        RemoteConnection {
            kind: String::from("remote"),
            name: String::from(""),
            endpoint: String::from(""),
        }
    }
}

impl RemoteConnection {
    /// Create a new RemoteConnection with default values.
    pub fn new() -> Self {
        Self::default()
    }

    /// Load RemoteConnection from a JSON string.
    pub fn from_json(json: &str) -> Result<Self, serde_json::Error> {
        let value: serde_json::Value = serde_json::from_str(json)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load RemoteConnection from a YAML string.
    pub fn from_yaml(yaml: &str) -> Result<Self, serde_yaml::Error> {
        let value: serde_json::Value = serde_yaml::from_str(yaml)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load RemoteConnection from a `serde_json::Value`.
    pub fn load_from_value(value: &serde_json::Value) -> Self {
        let mut result = Self::default();
        // Load fields from JSON object
        result.kind = value
            .get("kind")
            .and_then(|v| v.as_str())
            .unwrap_or_default()
            .to_string();
        result.name = value
            .get("name")
            .and_then(|v| v.as_str())
            .unwrap_or_default()
            .to_string();
        result.endpoint = value
            .get("endpoint")
            .and_then(|v| v.as_str())
            .unwrap_or_default()
            .to_string();
        result
    }

    /// Serialize RemoteConnection to a `serde_json::Value`.
    pub fn to_value(&self) -> serde_json::Value {
        let mut result = serde_json::Map::new();
        if !self.kind.is_empty() {
            result.insert(
                "kind".to_string(),
                serde_json::Value::String(self.kind.clone()),
            );
        }
        if !self.name.is_empty() {
            result.insert(
                "name".to_string(),
                serde_json::Value::String(self.name.clone()),
            );
        }
        if !self.endpoint.is_empty() {
            result.insert(
                "endpoint".to_string(),
                serde_json::Value::String(self.endpoint.clone()),
            );
        }
        serde_json::Value::Object(result)
    }

    /// Serialize RemoteConnection to a JSON string.
    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string_pretty(&self.to_value())
    }

    /// Serialize RemoteConnection to a YAML string.
    pub fn to_yaml(&self) -> Result<String, serde_yaml::Error> {
        serde_yaml::to_string(&self.to_value())
    }
}

/// Connection configuration for AI services using API keys.
#[derive(Debug, Clone)]
pub struct ApiKeyConnection {
    /// The Authentication kind for the AI service (e.g., 'key' for API key, 'oauth' for OAuth tokens)
    pub kind: String,
    /// The endpoint URL for the AI service
    pub endpoint: String,
    /// The API key for authenticating with the AI service
    pub api_key: String,
}

impl Default for ApiKeyConnection {
    fn default() -> Self {
        ApiKeyConnection {
            kind: String::from("key"),
            endpoint: String::from(""),
            api_key: String::from(""),
        }
    }
}

impl ApiKeyConnection {
    /// Create a new ApiKeyConnection with default values.
    pub fn new() -> Self {
        Self::default()
    }

    /// Load ApiKeyConnection from a JSON string.
    pub fn from_json(json: &str) -> Result<Self, serde_json::Error> {
        let value: serde_json::Value = serde_json::from_str(json)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load ApiKeyConnection from a YAML string.
    pub fn from_yaml(yaml: &str) -> Result<Self, serde_yaml::Error> {
        let value: serde_json::Value = serde_yaml::from_str(yaml)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load ApiKeyConnection from a `serde_json::Value`.
    pub fn load_from_value(value: &serde_json::Value) -> Self {
        let mut result = Self::default();
        // Load fields from JSON object
        result.kind = value
            .get("kind")
            .and_then(|v| v.as_str())
            .unwrap_or_default()
            .to_string();
        result.endpoint = value
            .get("endpoint")
            .and_then(|v| v.as_str())
            .unwrap_or_default()
            .to_string();
        result.api_key = value
            .get("apiKey")
            .and_then(|v| v.as_str())
            .unwrap_or_default()
            .to_string();
        result
    }

    /// Serialize ApiKeyConnection to a `serde_json::Value`.
    pub fn to_value(&self) -> serde_json::Value {
        let mut result = serde_json::Map::new();
        if !self.kind.is_empty() {
            result.insert(
                "kind".to_string(),
                serde_json::Value::String(self.kind.clone()),
            );
        }
        if !self.endpoint.is_empty() {
            result.insert(
                "endpoint".to_string(),
                serde_json::Value::String(self.endpoint.clone()),
            );
        }
        if !self.api_key.is_empty() {
            result.insert(
                "apiKey".to_string(),
                serde_json::Value::String(self.api_key.clone()),
            );
        }
        serde_json::Value::Object(result)
    }

    /// Serialize ApiKeyConnection to a JSON string.
    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string_pretty(&self.to_value())
    }

    /// Serialize ApiKeyConnection to a YAML string.
    pub fn to_yaml(&self) -> Result<String, serde_yaml::Error> {
        serde_yaml::to_string(&self.to_value())
    }
}

/// AnonymousConnection schema type
#[derive(Debug, Clone)]
pub struct AnonymousConnection {
    /// The Authentication kind for the AI service (e.g., 'key' for API key, 'oauth' for OAuth tokens)
    pub kind: String,
    /// The endpoint for authenticating with the AI service
    pub endpoint: String,
}

impl Default for AnonymousConnection {
    fn default() -> Self {
        AnonymousConnection {
            kind: String::from("anonymous"),
            endpoint: String::from(""),
        }
    }
}

impl AnonymousConnection {
    /// Create a new AnonymousConnection with default values.
    pub fn new() -> Self {
        Self::default()
    }

    /// Load AnonymousConnection from a JSON string.
    pub fn from_json(json: &str) -> Result<Self, serde_json::Error> {
        let value: serde_json::Value = serde_json::from_str(json)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load AnonymousConnection from a YAML string.
    pub fn from_yaml(yaml: &str) -> Result<Self, serde_yaml::Error> {
        let value: serde_json::Value = serde_yaml::from_str(yaml)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load AnonymousConnection from a `serde_json::Value`.
    pub fn load_from_value(value: &serde_json::Value) -> Self {
        let mut result = Self::default();
        // Load fields from JSON object
        result.kind = value
            .get("kind")
            .and_then(|v| v.as_str())
            .unwrap_or_default()
            .to_string();
        result.endpoint = value
            .get("endpoint")
            .and_then(|v| v.as_str())
            .unwrap_or_default()
            .to_string();
        result
    }

    /// Serialize AnonymousConnection to a `serde_json::Value`.
    pub fn to_value(&self) -> serde_json::Value {
        let mut result = serde_json::Map::new();
        if !self.kind.is_empty() {
            result.insert(
                "kind".to_string(),
                serde_json::Value::String(self.kind.clone()),
            );
        }
        if !self.endpoint.is_empty() {
            result.insert(
                "endpoint".to_string(),
                serde_json::Value::String(self.endpoint.clone()),
            );
        }
        serde_json::Value::Object(result)
    }

    /// Serialize AnonymousConnection to a JSON string.
    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string_pretty(&self.to_value())
    }

    /// Serialize AnonymousConnection to a YAML string.
    pub fn to_yaml(&self) -> Result<String, serde_yaml::Error> {
        serde_yaml::to_string(&self.to_value())
    }
}
