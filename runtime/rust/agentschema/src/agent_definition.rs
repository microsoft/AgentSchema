// Code generated by AgentSchema emitter; DO NOT EDIT.

use crate::context::{LoadContext, SaveContext};

use crate::environment_variable::EnvironmentVariable;

use crate::model::Model;

use crate::property_schema::PropertySchema;

use crate::protocol_version_record::ProtocolVersionRecord;

use crate::template::Template;

use crate::tool::Tool;

/// The following is a specification for defining AI agents with structured metadata, inputs, outputs, tools, and templates.
/// It provides a way to create reusable and composable AI agents that can be executed with specific configurations.
/// The specification includes metadata about the agent, model configuration, input parameters, expected outputs,
/// available tools, and template configurations for prompt rendering.
#[derive(Debug, Clone)]
pub struct AgentDefinition {
    /// Kind represented by the document
    pub kind: String,
    /// Human-readable name of the agent
    pub name: String,
    /// Display name of the agent for UI purposes
    pub display_name: Option<String>,
    /// Description of the agent's capabilities and purpose
    pub description: Option<String>,
    /// Additional metadata including authors, tags, and other arbitrary properties
    pub metadata: serde_json::Value,
    /// Input parameters that participate in template rendering
    pub input_schema: Option<PropertySchema>,
    /// Expected output format and structure from the agent
    pub output_schema: Option<PropertySchema>,
}

impl Default for AgentDefinition {
    fn default() -> Self {
        AgentDefinition {
            kind: String::from(""),
            name: String::from(""),
            display_name: None,
            description: None,
            metadata: serde_json::Value::Null,
            input_schema: None,
            output_schema: None,
        }
    }
}

impl AgentDefinition {
    /// Create a new AgentDefinition with default values.
    pub fn new() -> Self {
        Self::default()
    }

    /// Load AgentDefinition from a JSON string.
    pub fn from_json(json: &str) -> Result<Self, serde_json::Error> {
        let value: serde_json::Value = serde_json::from_str(json)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load AgentDefinition from a YAML string.
    pub fn from_yaml(yaml: &str) -> Result<Self, serde_yaml::Error> {
        let value: serde_json::Value = serde_yaml::from_str(yaml)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load AgentDefinition from a `serde_json::Value`.
    pub fn load_from_value(value: &serde_json::Value) -> Self {
        let mut result = Self::default();
        // Load fields from JSON object
        result.kind = value
            .get("kind")
            .and_then(|v| v.as_str())
            .unwrap_or_default()
            .to_string();
        result.name = value
            .get("name")
            .and_then(|v| v.as_str())
            .unwrap_or_default()
            .to_string();
        result.display_name = value
            .get("displayName")
            .and_then(|v| v.as_str())
            .map(|s| s.to_string());
        result.description = value
            .get("description")
            .and_then(|v| v.as_str())
            .map(|s| s.to_string());
        if let Some(val) = value.get("metadata") {
            result.metadata = val.clone();
        }
        if let Some(val) = value.get("inputSchema") {
            if val.is_object() || val.is_array() {
                result.input_schema = Some(PropertySchema::load_from_value(val));
            }
        }
        if let Some(val) = value.get("outputSchema") {
            if val.is_object() || val.is_array() {
                result.output_schema = Some(PropertySchema::load_from_value(val));
            }
        }
        result
    }

    /// Serialize AgentDefinition to a `serde_json::Value`.
    pub fn to_value(&self) -> serde_json::Value {
        let mut result = serde_json::Map::new();
        if !self.kind.is_empty() {
            result.insert(
                "kind".to_string(),
                serde_json::Value::String(self.kind.clone()),
            );
        }
        if !self.name.is_empty() {
            result.insert(
                "name".to_string(),
                serde_json::Value::String(self.name.clone()),
            );
        }
        if let Some(ref val) = self.display_name {
            result.insert(
                "displayName".to_string(),
                serde_json::Value::String(val.clone()),
            );
        }
        if let Some(ref val) = self.description {
            result.insert(
                "description".to_string(),
                serde_json::Value::String(val.clone()),
            );
        }
        if !self.metadata.is_null() {
            result.insert("metadata".to_string(), self.metadata.clone());
        }
        if let Some(ref val) = self.input_schema {
            let nested = val.to_value();
            if !nested.is_null() {
                result.insert("inputSchema".to_string(), nested);
            }
        }
        if let Some(ref val) = self.output_schema {
            let nested = val.to_value();
            if !nested.is_null() {
                result.insert("outputSchema".to_string(), nested);
            }
        }
        serde_json::Value::Object(result)
    }

    /// Serialize AgentDefinition to a JSON string.
    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string_pretty(&self.to_value())
    }

    /// Serialize AgentDefinition to a YAML string.
    pub fn to_yaml(&self) -> Result<String, serde_yaml::Error> {
        serde_yaml::to_string(&self.to_value())
    }
    /// Returns typed reference to the map if the field is an object.
    /// Returns `None` if the field is null or not an object.
    pub fn as_metadata_dict(&self) -> Option<&serde_json::Map<String, serde_json::Value>> {
        self.metadata.as_object()
    }
}

/// Prompt based agent definition. Used to create agents that can be executed directly.
/// These agents can leverage tools, input parameters, and templates to generate responses.
/// They are designed to be straightforward and easy to use for various applications.
#[derive(Debug, Clone)]
pub struct PromptAgent {
    /// Type of agent, e.g., 'prompt'
    pub kind: String,
    /// Primary AI model configuration for the agent
    pub model: Model,
    /// Tools available to the agent for extended functionality
    pub tools: serde_json::Value,
    /// Template configuration for prompt rendering
    pub template: Option<Template>,
    /// Give your agent clear directions on what to do and how to do it. Include specific tasks, their order, and any special instructions like tone or engagement style. (can use this for a pure yaml declaration or as content in the markdown format)
    pub instructions: Option<String>,
    /// Additional instructions or context for the agent, can be used to provide extra guidance (can use this for a pure yaml declaration)
    pub additional_instructions: Option<String>,
}

impl Default for PromptAgent {
    fn default() -> Self {
        PromptAgent {
            kind: String::from("prompt"),
            model: Default::default(),
            tools: serde_json::Value::Null,
            template: None,
            instructions: None,
            additional_instructions: None,
        }
    }
}

impl PromptAgent {
    /// Create a new PromptAgent with default values.
    pub fn new() -> Self {
        Self::default()
    }

    /// Load PromptAgent from a JSON string.
    pub fn from_json(json: &str) -> Result<Self, serde_json::Error> {
        let value: serde_json::Value = serde_json::from_str(json)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load PromptAgent from a YAML string.
    pub fn from_yaml(yaml: &str) -> Result<Self, serde_yaml::Error> {
        let value: serde_json::Value = serde_yaml::from_str(yaml)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load PromptAgent from a `serde_json::Value`.
    pub fn load_from_value(value: &serde_json::Value) -> Self {
        let mut result = Self::default();
        // Load fields from JSON object
        result.kind = value
            .get("kind")
            .and_then(|v| v.as_str())
            .unwrap_or_default()
            .to_string();
        if let Some(val) = value.get("model") {
            if val.is_object() || val.is_array() {
                result.model = Model::load_from_value(val);
            }
        }
        if let Some(val) = value.get("tools") {
            result.tools = val.clone();
        }
        if let Some(val) = value.get("template") {
            if val.is_object() || val.is_array() {
                result.template = Some(Template::load_from_value(val));
            }
        }
        result.instructions = value
            .get("instructions")
            .and_then(|v| v.as_str())
            .map(|s| s.to_string());
        result.additional_instructions = value
            .get("additionalInstructions")
            .and_then(|v| v.as_str())
            .map(|s| s.to_string());
        result
    }

    /// Serialize PromptAgent to a `serde_json::Value`.
    pub fn to_value(&self) -> serde_json::Value {
        let mut result = serde_json::Map::new();
        if !self.kind.is_empty() {
            result.insert(
                "kind".to_string(),
                serde_json::Value::String(self.kind.clone()),
            );
        }
        {
            let nested = self.model.to_value();
            if !nested.is_null() {
                result.insert("model".to_string(), nested);
            }
        }
        if !self.tools.is_null() {
            result.insert("tools".to_string(), self.tools.clone());
        }
        if let Some(ref val) = self.template {
            let nested = val.to_value();
            if !nested.is_null() {
                result.insert("template".to_string(), nested);
            }
        }
        if let Some(ref val) = self.instructions {
            result.insert(
                "instructions".to_string(),
                serde_json::Value::String(val.clone()),
            );
        }
        if let Some(ref val) = self.additional_instructions {
            result.insert(
                "additionalInstructions".to_string(),
                serde_json::Value::String(val.clone()),
            );
        }
        serde_json::Value::Object(result)
    }

    /// Serialize PromptAgent to a JSON string.
    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string_pretty(&self.to_value())
    }

    /// Serialize PromptAgent to a YAML string.
    pub fn to_yaml(&self) -> Result<String, serde_yaml::Error> {
        serde_yaml::to_string(&self.to_value())
    }
    /// Returns typed `Vec<Tool>` by parsing the stored JSON value.
    /// Handles both array format `[{...}]` and dict format `{"name": {...}}`.
    /// Returns `None` if the field is null or cannot be parsed.
    pub fn as_tools(&self) -> Option<Vec<Tool>> {
        match &self.tools {
            serde_json::Value::Array(arr) => Some(arr.iter().map(Tool::load_from_value).collect()),
            serde_json::Value::Object(obj) => {
                let result: Vec<Tool> = obj
                    .iter()
                    .map(|(name, value)| {
                        let mut v = if value.is_object() {
                            value.clone()
                        } else {
                            serde_json::json!({ "value": value })
                        };
                        if let serde_json::Value::Object(ref mut m) = v {
                            m.entry("name".to_string())
                                .or_insert_with(|| serde_json::Value::String(name.clone()));
                        }
                        Tool::load_from_value(&v)
                    })
                    .collect();
                Some(result)
            }
            _ => None,
        }
    }
}

/// A workflow agent that can orchestrate multiple steps and actions.
/// This agent type is designed to handle complex workflows that may involve
/// multiple tools, models, and decision points.
///
/// The workflow agent can be configured with a series of steps that define
/// the flow of execution, including conditional logic and parallel processing.
/// This allows for the creation of sophisticated AI-driven processes that can
/// adapt to various scenarios and requirements.
///
/// Note: The detailed structure of the workflow steps and actions is not defined here
/// and would need to be implemented based on specific use cases and requirements.
#[derive(Debug, Clone)]
pub struct Workflow {
    /// Type of agent, e.g., 'workflow'
    pub kind: String,
    /// The steps that make up the workflow
    pub trigger: serde_json::Value,
}

impl Default for Workflow {
    fn default() -> Self {
        Workflow {
            kind: String::from("workflow"),
            trigger: serde_json::Value::Null,
        }
    }
}

impl Workflow {
    /// Create a new Workflow with default values.
    pub fn new() -> Self {
        Self::default()
    }

    /// Load Workflow from a JSON string.
    pub fn from_json(json: &str) -> Result<Self, serde_json::Error> {
        let value: serde_json::Value = serde_json::from_str(json)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load Workflow from a YAML string.
    pub fn from_yaml(yaml: &str) -> Result<Self, serde_yaml::Error> {
        let value: serde_json::Value = serde_yaml::from_str(yaml)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load Workflow from a `serde_json::Value`.
    pub fn load_from_value(value: &serde_json::Value) -> Self {
        let mut result = Self::default();
        // Load fields from JSON object
        result.kind = value
            .get("kind")
            .and_then(|v| v.as_str())
            .unwrap_or_default()
            .to_string();
        if let Some(val) = value.get("trigger") {
            result.trigger = val.clone();
        }
        result
    }

    /// Serialize Workflow to a `serde_json::Value`.
    pub fn to_value(&self) -> serde_json::Value {
        let mut result = serde_json::Map::new();
        if !self.kind.is_empty() {
            result.insert(
                "kind".to_string(),
                serde_json::Value::String(self.kind.clone()),
            );
        }
        if !self.trigger.is_null() {
            result.insert("trigger".to_string(), self.trigger.clone());
        }
        serde_json::Value::Object(result)
    }

    /// Serialize Workflow to a JSON string.
    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string_pretty(&self.to_value())
    }

    /// Serialize Workflow to a YAML string.
    pub fn to_yaml(&self) -> Result<String, serde_yaml::Error> {
        serde_yaml::to_string(&self.to_value())
    }
    /// Returns typed reference to the map if the field is an object.
    /// Returns `None` if the field is null or not an object.
    pub fn as_trigger_dict(&self) -> Option<&serde_json::Map<String, serde_json::Value>> {
        self.trigger.as_object()
    }
}

/// This represents a container based agent hosted by the provider/publisher.
/// The intent is to represent a container application that the user wants to run
/// in a hosted environment that the provider manages.
#[derive(Debug, Clone)]
pub struct ContainerAgent {
    /// Type of agent, e.g., 'hosted'
    pub kind: String,
    /// Protocol used by the containerized agent
    pub protocols: serde_json::Value,
    /// Environment variables to set in the container
    pub environment_variables: serde_json::Value,
}

impl Default for ContainerAgent {
    fn default() -> Self {
        ContainerAgent {
            kind: String::from("hosted"),
            protocols: serde_json::Value::Null,
            environment_variables: serde_json::Value::Null,
        }
    }
}

impl ContainerAgent {
    /// Create a new ContainerAgent with default values.
    pub fn new() -> Self {
        Self::default()
    }

    /// Load ContainerAgent from a JSON string.
    pub fn from_json(json: &str) -> Result<Self, serde_json::Error> {
        let value: serde_json::Value = serde_json::from_str(json)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load ContainerAgent from a YAML string.
    pub fn from_yaml(yaml: &str) -> Result<Self, serde_yaml::Error> {
        let value: serde_json::Value = serde_yaml::from_str(yaml)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load ContainerAgent from a `serde_json::Value`.
    pub fn load_from_value(value: &serde_json::Value) -> Self {
        let mut result = Self::default();
        // Load fields from JSON object
        result.kind = value
            .get("kind")
            .and_then(|v| v.as_str())
            .unwrap_or_default()
            .to_string();
        if let Some(val) = value.get("protocols") {
            result.protocols = val.clone();
        }
        if let Some(val) = value.get("environmentVariables") {
            result.environment_variables = val.clone();
        }
        result
    }

    /// Serialize ContainerAgent to a `serde_json::Value`.
    pub fn to_value(&self) -> serde_json::Value {
        let mut result = serde_json::Map::new();
        if !self.kind.is_empty() {
            result.insert(
                "kind".to_string(),
                serde_json::Value::String(self.kind.clone()),
            );
        }
        if !self.protocols.is_null() {
            result.insert("protocols".to_string(), self.protocols.clone());
        }
        if !self.environment_variables.is_null() {
            result.insert(
                "environmentVariables".to_string(),
                self.environment_variables.clone(),
            );
        }
        serde_json::Value::Object(result)
    }

    /// Serialize ContainerAgent to a JSON string.
    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string_pretty(&self.to_value())
    }

    /// Serialize ContainerAgent to a YAML string.
    pub fn to_yaml(&self) -> Result<String, serde_yaml::Error> {
        serde_yaml::to_string(&self.to_value())
    }
    /// Returns typed `Vec<ProtocolVersionRecord>` by parsing the stored JSON value.
    /// Handles both array format `[{...}]` and dict format `{"name": {...}}`.
    /// Returns `None` if the field is null or cannot be parsed.
    pub fn as_protocols(&self) -> Option<Vec<ProtocolVersionRecord>> {
        match &self.protocols {
            serde_json::Value::Array(arr) => Some(
                arr.iter()
                    .map(ProtocolVersionRecord::load_from_value)
                    .collect(),
            ),
            serde_json::Value::Object(obj) => {
                let result: Vec<ProtocolVersionRecord> = obj
                    .iter()
                    .map(|(name, value)| {
                        let mut v = if value.is_object() {
                            value.clone()
                        } else {
                            serde_json::json!({ "value": value })
                        };
                        if let serde_json::Value::Object(ref mut m) = v {
                            m.entry("name".to_string())
                                .or_insert_with(|| serde_json::Value::String(name.clone()));
                        }
                        ProtocolVersionRecord::load_from_value(&v)
                    })
                    .collect();
                Some(result)
            }
            _ => None,
        }
    }
    /// Returns typed `Vec<EnvironmentVariable>` by parsing the stored JSON value.
    /// Handles both array format `[{...}]` and dict format `{"name": {...}}`.
    /// Returns `None` if the field is null or cannot be parsed.
    pub fn as_environment_variables(&self) -> Option<Vec<EnvironmentVariable>> {
        match &self.environment_variables {
            serde_json::Value::Array(arr) => Some(
                arr.iter()
                    .map(EnvironmentVariable::load_from_value)
                    .collect(),
            ),
            serde_json::Value::Object(obj) => {
                let result: Vec<EnvironmentVariable> = obj
                    .iter()
                    .map(|(name, value)| {
                        let mut v = if value.is_object() {
                            value.clone()
                        } else {
                            serde_json::json!({ "value": value })
                        };
                        if let serde_json::Value::Object(ref mut m) = v {
                            m.entry("name".to_string())
                                .or_insert_with(|| serde_json::Value::String(name.clone()));
                        }
                        EnvironmentVariable::load_from_value(&v)
                    })
                    .collect();
                Some(result)
            }
            _ => None,
        }
    }
}
