// Code generated by AgentSchema emitter; DO NOT EDIT.

use crate::context::{LoadContext, SaveContext};

use crate::binding::Binding;

use crate::connection::Connection;

use crate::mcp_server_approval_mode::McpServerApprovalMode;

use crate::property_schema::PropertySchema;

/// Represents a tool that can be used in prompts.
#[derive(Debug, Clone)]
pub struct Tool {
    /// Name of the tool. If a function tool, this is the function name, otherwise it is the type
    pub name: String,
    /// The kind identifier for the tool
    pub kind: String,
    /// A short description of the tool for metadata purposes
    pub description: Option<String>,
    /// Tool argument bindings to input properties
    pub bindings: serde_json::Value,
}

impl Default for Tool {
    fn default() -> Self {
        Tool {
            name: String::from(""),
            kind: String::from(""),
            description: None,
            bindings: serde_json::Value::Null,
        }
    }
}

impl Tool {
    /// Create a new Tool with default values.
    pub fn new() -> Self {
        Self::default()
    }

    /// Load Tool from a JSON string.
    pub fn from_json(json: &str) -> Result<Self, serde_json::Error> {
        let value: serde_json::Value = serde_json::from_str(json)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load Tool from a YAML string.
    pub fn from_yaml(yaml: &str) -> Result<Self, serde_yaml::Error> {
        let value: serde_json::Value = serde_yaml::from_str(yaml)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load Tool from a `serde_json::Value`.
    pub fn load_from_value(value: &serde_json::Value) -> Self {
        let mut result = Self::default();
        // Load fields from JSON object
        result.name = value
            .get("name")
            .and_then(|v| v.as_str())
            .unwrap_or_default()
            .to_string();
        result.kind = value
            .get("kind")
            .and_then(|v| v.as_str())
            .unwrap_or_default()
            .to_string();
        result.description = value
            .get("description")
            .and_then(|v| v.as_str())
            .map(|s| s.to_string());
        if let Some(val) = value.get("bindings") {
            result.bindings = val.clone();
        }
        result
    }

    /// Serialize Tool to a `serde_json::Value`.
    pub fn to_value(&self) -> serde_json::Value {
        let mut result = serde_json::Map::new();
        if !self.name.is_empty() {
            result.insert(
                "name".to_string(),
                serde_json::Value::String(self.name.clone()),
            );
        }
        if !self.kind.is_empty() {
            result.insert(
                "kind".to_string(),
                serde_json::Value::String(self.kind.clone()),
            );
        }
        if let Some(ref val) = self.description {
            result.insert(
                "description".to_string(),
                serde_json::Value::String(val.clone()),
            );
        }
        if !self.bindings.is_null() {
            result.insert("bindings".to_string(), self.bindings.clone());
        }
        serde_json::Value::Object(result)
    }

    /// Serialize Tool to a JSON string.
    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string_pretty(&self.to_value())
    }

    /// Serialize Tool to a YAML string.
    pub fn to_yaml(&self) -> Result<String, serde_yaml::Error> {
        serde_yaml::to_string(&self.to_value())
    }
    /// Returns typed `Vec<Binding>` by parsing the stored JSON value.
    /// Handles both array format `[{...}]` and dict format `{"name": {...}}`.
    /// Returns `None` if the field is null or cannot be parsed.
    pub fn as_bindings(&self) -> Option<Vec<Binding>> {
        match &self.bindings {
            serde_json::Value::Array(arr) => {
                Some(arr.iter().map(Binding::load_from_value).collect())
            }
            serde_json::Value::Object(obj) => {
                let result: Vec<Binding> = obj
                    .iter()
                    .map(|(name, value)| {
                        let mut v = if value.is_object() {
                            value.clone()
                        } else {
                            serde_json::json!({ "value": value })
                        };
                        if let serde_json::Value::Object(ref mut m) = v {
                            m.entry("name".to_string())
                                .or_insert_with(|| serde_json::Value::String(name.clone()));
                        }
                        Binding::load_from_value(&v)
                    })
                    .collect();
                Some(result)
            }
            _ => None,
        }
    }
}

/// Represents a local function tool.
#[derive(Debug, Clone)]
pub struct FunctionTool {
    /// The kind identifier for function tools
    pub kind: String,
    /// Parameters accepted by the function tool
    pub parameters: PropertySchema,
    /// Indicates whether the function tool enforces strict validation on its parameters
    pub strict: Option<bool>,
}

impl Default for FunctionTool {
    fn default() -> Self {
        FunctionTool {
            kind: String::from("function"),
            parameters: Default::default(),
            strict: None,
        }
    }
}

impl FunctionTool {
    /// Create a new FunctionTool with default values.
    pub fn new() -> Self {
        Self::default()
    }

    /// Load FunctionTool from a JSON string.
    pub fn from_json(json: &str) -> Result<Self, serde_json::Error> {
        let value: serde_json::Value = serde_json::from_str(json)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load FunctionTool from a YAML string.
    pub fn from_yaml(yaml: &str) -> Result<Self, serde_yaml::Error> {
        let value: serde_json::Value = serde_yaml::from_str(yaml)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load FunctionTool from a `serde_json::Value`.
    pub fn load_from_value(value: &serde_json::Value) -> Self {
        let mut result = Self::default();
        // Load fields from JSON object
        result.kind = value
            .get("kind")
            .and_then(|v| v.as_str())
            .unwrap_or_default()
            .to_string();
        if let Some(val) = value.get("parameters") {
            if val.is_object() || val.is_array() {
                result.parameters = PropertySchema::load_from_value(val);
            }
        }
        result.strict = value.get("strict").and_then(|v| v.as_bool());
        result
    }

    /// Serialize FunctionTool to a `serde_json::Value`.
    pub fn to_value(&self) -> serde_json::Value {
        let mut result = serde_json::Map::new();
        if !self.kind.is_empty() {
            result.insert(
                "kind".to_string(),
                serde_json::Value::String(self.kind.clone()),
            );
        }
        {
            let nested = self.parameters.to_value();
            if !nested.is_null() {
                result.insert("parameters".to_string(), nested);
            }
        }
        if let Some(val) = self.strict {
            result.insert("strict".to_string(), serde_json::Value::Bool(val));
        }
        serde_json::Value::Object(result)
    }

    /// Serialize FunctionTool to a JSON string.
    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string_pretty(&self.to_value())
    }

    /// Serialize FunctionTool to a YAML string.
    pub fn to_yaml(&self) -> Result<String, serde_yaml::Error> {
        serde_yaml::to_string(&self.to_value())
    }
}

/// Represents a generic server tool that runs on a server
/// This tool kind is designed for operations that require server-side execution
/// It may include features such as authentication, data storage, and long-running processes
/// This tool kind is ideal for tasks that involve complex computations or access to secure resources
/// Server tools can be used to offload heavy processing from client applications
#[derive(Debug, Clone)]
pub struct CustomTool {
    /// The kind identifier for server tools. This is a wildcard and can represent any server tool type not explicitly defined.
    pub kind: String,
    /// Connection configuration for the server tool
    pub connection: serde_json::Value,
    /// Configuration options for the server tool
    pub options: serde_json::Value,
}

impl Default for CustomTool {
    fn default() -> Self {
        CustomTool {
            kind: String::from("*"),
            connection: serde_json::Value::Null,
            options: serde_json::Value::Null,
        }
    }
}

impl CustomTool {
    /// Create a new CustomTool with default values.
    pub fn new() -> Self {
        Self::default()
    }

    /// Load CustomTool from a JSON string.
    pub fn from_json(json: &str) -> Result<Self, serde_json::Error> {
        let value: serde_json::Value = serde_json::from_str(json)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load CustomTool from a YAML string.
    pub fn from_yaml(yaml: &str) -> Result<Self, serde_yaml::Error> {
        let value: serde_json::Value = serde_yaml::from_str(yaml)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load CustomTool from a `serde_json::Value`.
    pub fn load_from_value(value: &serde_json::Value) -> Self {
        let mut result = Self::default();
        // Load fields from JSON object
        result.kind = value
            .get("kind")
            .and_then(|v| v.as_str())
            .unwrap_or_default()
            .to_string();
        if let Some(val) = value.get("connection") {
            result.connection = val.clone();
        }
        if let Some(val) = value.get("options") {
            result.options = val.clone();
        }
        result
    }

    /// Serialize CustomTool to a `serde_json::Value`.
    pub fn to_value(&self) -> serde_json::Value {
        let mut result = serde_json::Map::new();
        if !self.kind.is_empty() {
            result.insert(
                "kind".to_string(),
                serde_json::Value::String(self.kind.clone()),
            );
        }
        if !self.connection.is_null() {
            result.insert("connection".to_string(), self.connection.clone());
        }
        if !self.options.is_null() {
            result.insert("options".to_string(), self.options.clone());
        }
        serde_json::Value::Object(result)
    }

    /// Serialize CustomTool to a JSON string.
    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string_pretty(&self.to_value())
    }

    /// Serialize CustomTool to a YAML string.
    pub fn to_yaml(&self) -> Result<String, serde_yaml::Error> {
        serde_yaml::to_string(&self.to_value())
    }
    /// Returns typed reference to the map if the field is an object.
    /// Returns `None` if the field is null or not an object.
    pub fn as_options_dict(&self) -> Option<&serde_json::Map<String, serde_json::Value>> {
        self.options.as_object()
    }
}

/// The Bing search tool.
#[derive(Debug, Clone)]
pub struct WebSearchTool {
    /// The kind identifier for Bing search tools
    pub kind: String,
    /// The connection configuration for the Bing search tool
    pub connection: serde_json::Value,
    /// The configuration options for the Bing search tool
    pub options: serde_json::Value,
}

impl Default for WebSearchTool {
    fn default() -> Self {
        WebSearchTool {
            kind: String::from("bing_search"),
            connection: serde_json::Value::Null,
            options: serde_json::Value::Null,
        }
    }
}

impl WebSearchTool {
    /// Create a new WebSearchTool with default values.
    pub fn new() -> Self {
        Self::default()
    }

    /// Load WebSearchTool from a JSON string.
    pub fn from_json(json: &str) -> Result<Self, serde_json::Error> {
        let value: serde_json::Value = serde_json::from_str(json)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load WebSearchTool from a YAML string.
    pub fn from_yaml(yaml: &str) -> Result<Self, serde_yaml::Error> {
        let value: serde_json::Value = serde_yaml::from_str(yaml)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load WebSearchTool from a `serde_json::Value`.
    pub fn load_from_value(value: &serde_json::Value) -> Self {
        let mut result = Self::default();
        // Load fields from JSON object
        result.kind = value
            .get("kind")
            .and_then(|v| v.as_str())
            .unwrap_or_default()
            .to_string();
        if let Some(val) = value.get("connection") {
            result.connection = val.clone();
        }
        if let Some(val) = value.get("options") {
            result.options = val.clone();
        }
        result
    }

    /// Serialize WebSearchTool to a `serde_json::Value`.
    pub fn to_value(&self) -> serde_json::Value {
        let mut result = serde_json::Map::new();
        if !self.kind.is_empty() {
            result.insert(
                "kind".to_string(),
                serde_json::Value::String(self.kind.clone()),
            );
        }
        if !self.connection.is_null() {
            result.insert("connection".to_string(), self.connection.clone());
        }
        if !self.options.is_null() {
            result.insert("options".to_string(), self.options.clone());
        }
        serde_json::Value::Object(result)
    }

    /// Serialize WebSearchTool to a JSON string.
    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string_pretty(&self.to_value())
    }

    /// Serialize WebSearchTool to a YAML string.
    pub fn to_yaml(&self) -> Result<String, serde_yaml::Error> {
        serde_yaml::to_string(&self.to_value())
    }
    /// Returns typed reference to the map if the field is an object.
    /// Returns `None` if the field is null or not an object.
    pub fn as_options_dict(&self) -> Option<&serde_json::Map<String, serde_json::Value>> {
        self.options.as_object()
    }
}

/// A tool for searching files.
/// This tool allows an AI agent to search for files based on a query.
#[derive(Debug, Clone)]
pub struct FileSearchTool {
    /// The kind identifier for file search tools
    pub kind: String,
    /// The connection configuration for the file search tool
    pub connection: serde_json::Value,
    /// The IDs of the vector stores to search within.
    pub vector_store_ids: Vec<String>,
    /// The maximum number of search results to return.
    pub maximum_result_count: Option<i32>,
    /// File search ranker.
    pub ranker: Option<String>,
    /// Ranker search threshold.
    pub score_threshold: Option<f32>,
    /// Additional filters to apply during the file search.
    pub filters: serde_json::Value,
}

impl Default for FileSearchTool {
    fn default() -> Self {
        FileSearchTool {
            kind: String::from("file_search"),
            connection: serde_json::Value::Null,
            vector_store_ids: Vec::new(),
            maximum_result_count: None,
            ranker: None,
            score_threshold: None,
            filters: serde_json::Value::Null,
        }
    }
}

impl FileSearchTool {
    /// Create a new FileSearchTool with default values.
    pub fn new() -> Self {
        Self::default()
    }

    /// Load FileSearchTool from a JSON string.
    pub fn from_json(json: &str) -> Result<Self, serde_json::Error> {
        let value: serde_json::Value = serde_json::from_str(json)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load FileSearchTool from a YAML string.
    pub fn from_yaml(yaml: &str) -> Result<Self, serde_yaml::Error> {
        let value: serde_json::Value = serde_yaml::from_str(yaml)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load FileSearchTool from a `serde_json::Value`.
    pub fn load_from_value(value: &serde_json::Value) -> Self {
        let mut result = Self::default();
        // Load fields from JSON object
        result.kind = value
            .get("kind")
            .and_then(|v| v.as_str())
            .unwrap_or_default()
            .to_string();
        if let Some(val) = value.get("connection") {
            result.connection = val.clone();
        }
        if let Some(arr) = value.get("vectorStoreIds").and_then(|v| v.as_array()) {
            result.vector_store_ids = arr
                .iter()
                .filter_map(|v| v.as_str().map(|s| s.to_string()))
                .collect();
        }
        result.maximum_result_count = value
            .get("maximumResultCount")
            .and_then(|v| v.as_i64())
            .map(|n| n as i32);
        result.ranker = value
            .get("ranker")
            .and_then(|v| v.as_str())
            .map(|s| s.to_string());
        result.score_threshold = value
            .get("scoreThreshold")
            .and_then(|v| v.as_f64())
            .map(|n| n as f32);
        if let Some(val) = value.get("filters") {
            result.filters = val.clone();
        }
        result
    }

    /// Serialize FileSearchTool to a `serde_json::Value`.
    pub fn to_value(&self) -> serde_json::Value {
        let mut result = serde_json::Map::new();
        if !self.kind.is_empty() {
            result.insert(
                "kind".to_string(),
                serde_json::Value::String(self.kind.clone()),
            );
        }
        if !self.connection.is_null() {
            result.insert("connection".to_string(), self.connection.clone());
        }
        if !self.vector_store_ids.is_empty() {
            result.insert(
                "vectorStoreIds".to_string(),
                serde_json::to_value(&self.vector_store_ids).unwrap_or(serde_json::Value::Null),
            );
        }
        if let Some(ref val) = self.maximum_result_count {
            result.insert(
                "maximumResultCount".to_string(),
                serde_json::to_value(val).unwrap_or(serde_json::Value::Null),
            );
        }
        if let Some(ref val) = self.ranker {
            result.insert("ranker".to_string(), serde_json::Value::String(val.clone()));
        }
        if let Some(ref val) = self.score_threshold {
            result.insert(
                "scoreThreshold".to_string(),
                serde_json::to_value(val).unwrap_or(serde_json::Value::Null),
            );
        }
        if !self.filters.is_null() {
            result.insert("filters".to_string(), self.filters.clone());
        }
        serde_json::Value::Object(result)
    }

    /// Serialize FileSearchTool to a JSON string.
    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string_pretty(&self.to_value())
    }

    /// Serialize FileSearchTool to a YAML string.
    pub fn to_yaml(&self) -> Result<String, serde_yaml::Error> {
        serde_yaml::to_string(&self.to_value())
    }
    /// Returns typed reference to the map if the field is an object.
    /// Returns `None` if the field is null or not an object.
    pub fn as_filters_dict(&self) -> Option<&serde_json::Map<String, serde_json::Value>> {
        self.filters.as_object()
    }
}

/// The MCP Server tool.
#[derive(Debug, Clone)]
pub struct McpTool {
    /// The kind identifier for MCP tools
    pub kind: String,
    /// The connection configuration for the MCP tool
    pub connection: serde_json::Value,
    /// The server name of the MCP tool
    pub server_name: String,
    /// The description of the MCP tool
    pub server_description: Option<String>,
    /// The approval mode for the MCP tool, either 'auto' or 'manual'
    pub approval_mode: serde_json::Value,
    /// List of allowed operations or resources for the MCP tool
    pub allowed_tools: Option<Vec<String>>,
}

impl Default for McpTool {
    fn default() -> Self {
        McpTool {
            kind: String::from("mcp"),
            connection: serde_json::Value::Null,
            server_name: String::from(""),
            server_description: None,
            approval_mode: serde_json::Value::Null,
            allowed_tools: None,
        }
    }
}

impl McpTool {
    /// Create a new McpTool with default values.
    pub fn new() -> Self {
        Self::default()
    }

    /// Load McpTool from a JSON string.
    pub fn from_json(json: &str) -> Result<Self, serde_json::Error> {
        let value: serde_json::Value = serde_json::from_str(json)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load McpTool from a YAML string.
    pub fn from_yaml(yaml: &str) -> Result<Self, serde_yaml::Error> {
        let value: serde_json::Value = serde_yaml::from_str(yaml)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load McpTool from a `serde_json::Value`.
    pub fn load_from_value(value: &serde_json::Value) -> Self {
        let mut result = Self::default();
        // Load fields from JSON object
        result.kind = value
            .get("kind")
            .and_then(|v| v.as_str())
            .unwrap_or_default()
            .to_string();
        if let Some(val) = value.get("connection") {
            result.connection = val.clone();
        }
        result.server_name = value
            .get("serverName")
            .and_then(|v| v.as_str())
            .unwrap_or_default()
            .to_string();
        result.server_description = value
            .get("serverDescription")
            .and_then(|v| v.as_str())
            .map(|s| s.to_string());
        if let Some(val) = value.get("approvalMode") {
            result.approval_mode = val.clone();
        }
        if let Some(arr) = value.get("allowedTools").and_then(|v| v.as_array()) {
            result.allowed_tools = Some(
                arr.iter()
                    .filter_map(|v| v.as_str().map(|s| s.to_string()))
                    .collect(),
            );
        }
        result
    }

    /// Serialize McpTool to a `serde_json::Value`.
    pub fn to_value(&self) -> serde_json::Value {
        let mut result = serde_json::Map::new();
        if !self.kind.is_empty() {
            result.insert(
                "kind".to_string(),
                serde_json::Value::String(self.kind.clone()),
            );
        }
        if !self.connection.is_null() {
            result.insert("connection".to_string(), self.connection.clone());
        }
        if !self.server_name.is_empty() {
            result.insert(
                "serverName".to_string(),
                serde_json::Value::String(self.server_name.clone()),
            );
        }
        if let Some(ref val) = self.server_description {
            result.insert(
                "serverDescription".to_string(),
                serde_json::Value::String(val.clone()),
            );
        }
        if !self.approval_mode.is_null() {
            result.insert("approvalMode".to_string(), self.approval_mode.clone());
        }
        if let Some(ref items) = self.allowed_tools {
            result.insert(
                "allowedTools".to_string(),
                serde_json::to_value(items).unwrap_or(serde_json::Value::Null),
            );
        }
        serde_json::Value::Object(result)
    }

    /// Serialize McpTool to a JSON string.
    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string_pretty(&self.to_value())
    }

    /// Serialize McpTool to a YAML string.
    pub fn to_yaml(&self) -> Result<String, serde_yaml::Error> {
        serde_yaml::to_string(&self.to_value())
    }
}

/// OpenApiTool schema type
#[derive(Debug, Clone)]
pub struct OpenApiTool {
    /// The kind identifier for OpenAPI tools
    pub kind: String,
    /// The connection configuration for the OpenAPI tool
    pub connection: serde_json::Value,
    /// The full OpenAPI specification
    pub specification: String,
}

impl Default for OpenApiTool {
    fn default() -> Self {
        OpenApiTool {
            kind: String::from("openapi"),
            connection: serde_json::Value::Null,
            specification: String::from(""),
        }
    }
}

impl OpenApiTool {
    /// Create a new OpenApiTool with default values.
    pub fn new() -> Self {
        Self::default()
    }

    /// Load OpenApiTool from a JSON string.
    pub fn from_json(json: &str) -> Result<Self, serde_json::Error> {
        let value: serde_json::Value = serde_json::from_str(json)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load OpenApiTool from a YAML string.
    pub fn from_yaml(yaml: &str) -> Result<Self, serde_yaml::Error> {
        let value: serde_json::Value = serde_yaml::from_str(yaml)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load OpenApiTool from a `serde_json::Value`.
    pub fn load_from_value(value: &serde_json::Value) -> Self {
        let mut result = Self::default();
        // Load fields from JSON object
        result.kind = value
            .get("kind")
            .and_then(|v| v.as_str())
            .unwrap_or_default()
            .to_string();
        if let Some(val) = value.get("connection") {
            result.connection = val.clone();
        }
        result.specification = value
            .get("specification")
            .and_then(|v| v.as_str())
            .unwrap_or_default()
            .to_string();
        result
    }

    /// Serialize OpenApiTool to a `serde_json::Value`.
    pub fn to_value(&self) -> serde_json::Value {
        let mut result = serde_json::Map::new();
        if !self.kind.is_empty() {
            result.insert(
                "kind".to_string(),
                serde_json::Value::String(self.kind.clone()),
            );
        }
        if !self.connection.is_null() {
            result.insert("connection".to_string(), self.connection.clone());
        }
        if !self.specification.is_empty() {
            result.insert(
                "specification".to_string(),
                serde_json::Value::String(self.specification.clone()),
            );
        }
        serde_json::Value::Object(result)
    }

    /// Serialize OpenApiTool to a JSON string.
    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string_pretty(&self.to_value())
    }

    /// Serialize OpenApiTool to a YAML string.
    pub fn to_yaml(&self) -> Result<String, serde_yaml::Error> {
        serde_yaml::to_string(&self.to_value())
    }
}

/// A tool for interpreting and executing code.
/// This tool allows an AI agent to run code snippets and analyze data files.
#[derive(Debug, Clone)]
pub struct CodeInterpreterTool {
    /// The kind identifier for code interpreter tools
    pub kind: String,
    /// The IDs of the files to be used by the code interpreter tool.
    pub file_ids: Vec<String>,
}

impl Default for CodeInterpreterTool {
    fn default() -> Self {
        CodeInterpreterTool {
            kind: String::from("code_interpreter"),
            file_ids: Vec::new(),
        }
    }
}

impl CodeInterpreterTool {
    /// Create a new CodeInterpreterTool with default values.
    pub fn new() -> Self {
        Self::default()
    }

    /// Load CodeInterpreterTool from a JSON string.
    pub fn from_json(json: &str) -> Result<Self, serde_json::Error> {
        let value: serde_json::Value = serde_json::from_str(json)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load CodeInterpreterTool from a YAML string.
    pub fn from_yaml(yaml: &str) -> Result<Self, serde_yaml::Error> {
        let value: serde_json::Value = serde_yaml::from_str(yaml)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load CodeInterpreterTool from a `serde_json::Value`.
    pub fn load_from_value(value: &serde_json::Value) -> Self {
        let mut result = Self::default();
        // Load fields from JSON object
        result.kind = value
            .get("kind")
            .and_then(|v| v.as_str())
            .unwrap_or_default()
            .to_string();
        if let Some(arr) = value.get("fileIds").and_then(|v| v.as_array()) {
            result.file_ids = arr
                .iter()
                .filter_map(|v| v.as_str().map(|s| s.to_string()))
                .collect();
        }
        result
    }

    /// Serialize CodeInterpreterTool to a `serde_json::Value`.
    pub fn to_value(&self) -> serde_json::Value {
        let mut result = serde_json::Map::new();
        if !self.kind.is_empty() {
            result.insert(
                "kind".to_string(),
                serde_json::Value::String(self.kind.clone()),
            );
        }
        if !self.file_ids.is_empty() {
            result.insert(
                "fileIds".to_string(),
                serde_json::to_value(&self.file_ids).unwrap_or(serde_json::Value::Null),
            );
        }
        serde_json::Value::Object(result)
    }

    /// Serialize CodeInterpreterTool to a JSON string.
    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string_pretty(&self.to_value())
    }

    /// Serialize CodeInterpreterTool to a YAML string.
    pub fn to_yaml(&self) -> Result<String, serde_yaml::Error> {
        serde_yaml::to_string(&self.to_value())
    }
}
