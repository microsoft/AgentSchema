// Code generated by AgentSchema emitter; DO NOT EDIT.

use crate::format::Format;

use crate::parser::Parser;

/// Template model for defining prompt templates.
///
/// This model specifies the rendering engine used for slot filling prompts,
/// the parser used to process the rendered template into API-compatible format,
/// and additional options for the template engine.
///
/// It allows for the creation of reusable templates that can be filled with dynamic data
/// and processed to generate prompts for AI models.
#[derive(Debug, Clone)]
pub struct Template {
    /// Template rendering engine used for slot filling prompts (e.g., mustache, jinja2)
    pub format: Format,
    /// Parser used to process the rendered template into API-compatible format
    pub parser: Parser,
}

impl Default for Template {
    fn default() -> Self {
        Template {
            format: Default::default(),
            parser: Default::default(),
        }
    }
}

impl Template {
    /// Create a new Template with default values.
    pub fn new() -> Self {
        Self::default()
    }

    /// Load Template from a JSON string.
    pub fn from_json(json: &str) -> Result<Self, serde_json::Error> {
        let value: serde_json::Value = serde_json::from_str(json)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load Template from a YAML string.
    pub fn from_yaml(yaml: &str) -> Result<Self, serde_yaml::Error> {
        let value: serde_json::Value = serde_yaml::from_str(yaml)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load Template from a `serde_json::Value`.
    pub fn load_from_value(value: &serde_json::Value) -> Self {
        let mut result = Self::default();
        // Load fields from JSON object
        if let Some(val) = value.get("format") {
            if val.is_object() || val.is_array() {
                result.format = Format::load_from_value(val);
            }
        }
        if let Some(val) = value.get("parser") {
            if val.is_object() || val.is_array() {
                result.parser = Parser::load_from_value(val);
            }
        }
        result
    }

    /// Serialize Template to a `serde_json::Value`.
    pub fn to_value(&self) -> serde_json::Value {
        let mut result = serde_json::Map::new();
        {
            let nested = self.format.to_value();
            if !nested.is_null() {
                result.insert("format".to_string(), nested);
            }
        }
        {
            let nested = self.parser.to_value();
            if !nested.is_null() {
                result.insert("parser".to_string(), nested);
            }
        }
        serde_json::Value::Object(result)
    }

    /// Serialize Template to a JSON string.
    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string_pretty(&self.to_value())
    }

    /// Serialize Template to a YAML string.
    pub fn to_yaml(&self) -> Result<String, serde_yaml::Error> {
        serde_yaml::to_string(&self.to_value())
    }
}
