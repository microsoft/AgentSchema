// Code generated by AgentSchema emitter; DO NOT EDIT.

/// Options for configuring the behavior of the AI model.
/// `kind` is a required property here, but this section can accept additional via options.
#[derive(Debug, Clone)]
pub struct ModelOptions {
    /// The frequency penalty to apply to the model's output
    pub frequency_penalty: Option<f32>,
    /// The maximum number of tokens to generate in the output
    pub max_output_tokens: Option<i32>,
    /// The presence penalty to apply to the model's output
    pub presence_penalty: Option<f32>,
    /// A random seed for deterministic output
    pub seed: Option<i32>,
    /// The temperature to use for sampling
    pub temperature: Option<f32>,
    /// The top-K sampling value
    pub top_k: Option<i32>,
    /// The top-P sampling value
    pub top_p: Option<f32>,
    /// Stop sequences to end generation
    pub stop_sequences: Option<Vec<String>>,
    /// Whether to allow multiple tool calls in a single response
    pub allow_multiple_tool_calls: Option<bool>,
    /// Additional custom properties for model options
    pub additional_properties: serde_json::Value,
}

impl Default for ModelOptions {
    fn default() -> Self {
        ModelOptions {
            frequency_penalty: None,
            max_output_tokens: None,
            presence_penalty: None,
            seed: None,
            temperature: None,
            top_k: None,
            top_p: None,
            stop_sequences: None,
            allow_multiple_tool_calls: None,
            additional_properties: serde_json::Value::Null,
        }
    }
}

impl ModelOptions {
    /// Create a new ModelOptions with default values.
    pub fn new() -> Self {
        Self::default()
    }

    /// Load ModelOptions from a JSON string.
    pub fn from_json(json: &str) -> Result<Self, serde_json::Error> {
        let value: serde_json::Value = serde_json::from_str(json)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load ModelOptions from a YAML string.
    pub fn from_yaml(yaml: &str) -> Result<Self, serde_yaml::Error> {
        let value: serde_json::Value = serde_yaml::from_str(yaml)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load ModelOptions from a `serde_json::Value`.
    pub fn load_from_value(value: &serde_json::Value) -> Self {
        let mut result = Self::default();
        // Load fields from JSON object
        result.frequency_penalty = value
            .get("frequencyPenalty")
            .and_then(|v| v.as_f64())
            .map(|n| n as f32);
        result.max_output_tokens = value
            .get("maxOutputTokens")
            .and_then(|v| v.as_i64())
            .map(|n| n as i32);
        result.presence_penalty = value
            .get("presencePenalty")
            .and_then(|v| v.as_f64())
            .map(|n| n as f32);
        result.seed = value.get("seed").and_then(|v| v.as_i64()).map(|n| n as i32);
        result.temperature = value
            .get("temperature")
            .and_then(|v| v.as_f64())
            .map(|n| n as f32);
        result.top_k = value.get("topK").and_then(|v| v.as_i64()).map(|n| n as i32);
        result.top_p = value.get("topP").and_then(|v| v.as_f64()).map(|n| n as f32);
        if let Some(arr) = value.get("stopSequences").and_then(|v| v.as_array()) {
            result.stop_sequences = Some(
                arr.iter()
                    .filter_map(|v| v.as_str().map(|s| s.to_string()))
                    .collect(),
            );
        }
        result.allow_multiple_tool_calls = value
            .get("allowMultipleToolCalls")
            .and_then(|v| v.as_bool());
        if let Some(val) = value.get("additionalProperties") {
            result.additional_properties = val.clone();
        }
        result
    }

    /// Serialize ModelOptions to a `serde_json::Value`.
    pub fn to_value(&self) -> serde_json::Value {
        let mut result = serde_json::Map::new();
        if let Some(ref val) = self.frequency_penalty {
            result.insert(
                "frequencyPenalty".to_string(),
                serde_json::to_value(val).unwrap_or(serde_json::Value::Null),
            );
        }
        if let Some(ref val) = self.max_output_tokens {
            result.insert(
                "maxOutputTokens".to_string(),
                serde_json::to_value(val).unwrap_or(serde_json::Value::Null),
            );
        }
        if let Some(ref val) = self.presence_penalty {
            result.insert(
                "presencePenalty".to_string(),
                serde_json::to_value(val).unwrap_or(serde_json::Value::Null),
            );
        }
        if let Some(ref val) = self.seed {
            result.insert(
                "seed".to_string(),
                serde_json::to_value(val).unwrap_or(serde_json::Value::Null),
            );
        }
        if let Some(ref val) = self.temperature {
            result.insert(
                "temperature".to_string(),
                serde_json::to_value(val).unwrap_or(serde_json::Value::Null),
            );
        }
        if let Some(ref val) = self.top_k {
            result.insert(
                "topK".to_string(),
                serde_json::to_value(val).unwrap_or(serde_json::Value::Null),
            );
        }
        if let Some(ref val) = self.top_p {
            result.insert(
                "topP".to_string(),
                serde_json::to_value(val).unwrap_or(serde_json::Value::Null),
            );
        }
        if let Some(ref items) = self.stop_sequences {
            result.insert(
                "stopSequences".to_string(),
                serde_json::to_value(items).unwrap_or(serde_json::Value::Null),
            );
        }
        if let Some(val) = self.allow_multiple_tool_calls {
            result.insert(
                "allowMultipleToolCalls".to_string(),
                serde_json::Value::Bool(val),
            );
        }
        if !self.additional_properties.is_null() {
            result.insert(
                "additionalProperties".to_string(),
                self.additional_properties.clone(),
            );
        }
        serde_json::Value::Object(result)
    }

    /// Serialize ModelOptions to a JSON string.
    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string_pretty(&self.to_value())
    }

    /// Serialize ModelOptions to a YAML string.
    pub fn to_yaml(&self) -> Result<String, serde_yaml::Error> {
        serde_yaml::to_string(&self.to_value())
    }
    /// Returns typed reference to the map if the field is an object.
    /// Returns `None` if the field is null or not an object.
    pub fn as_additional_properties_dict(
        &self,
    ) -> Option<&serde_json::Map<String, serde_json::Value>> {
        self.additional_properties.as_object()
    }
}
