// Code generated by AgentSchema emitter; DO NOT EDIT.

#[allow(unused_imports)]
use crate::*;

/// ModelOptions represents Options for configuring the behavior of the AI model.
/// `kind` is a required property here, but this section can accept additional via options.

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct ModelOptions {
    #[serde(
        rename = "frequencyPenalty",
        skip_serializing_if = "Option::is_none",
        default
    )]
    pub frequency_penalty: Option<f32>,
    #[serde(
        rename = "maxOutputTokens",
        skip_serializing_if = "Option::is_none",
        default
    )]
    pub max_output_tokens: Option<i32>,
    #[serde(
        rename = "presencePenalty",
        skip_serializing_if = "Option::is_none",
        default
    )]
    pub presence_penalty: Option<f32>,
    #[serde(rename = "seed", skip_serializing_if = "Option::is_none", default)]
    pub seed: Option<i32>,
    #[serde(
        rename = "temperature",
        skip_serializing_if = "Option::is_none",
        default
    )]
    pub temperature: Option<f32>,
    #[serde(rename = "topK", skip_serializing_if = "Option::is_none", default)]
    pub top_k: Option<i32>,
    #[serde(rename = "topP", skip_serializing_if = "Option::is_none", default)]
    pub top_p: Option<f32>,
    #[serde(
        rename = "stopSequences",
        skip_serializing_if = "Vec::is_empty",
        default
    )]
    pub stop_sequences: Vec<String>,
    #[serde(
        rename = "allowMultipleToolCalls",
        skip_serializing_if = "Option::is_none",
        default
    )]
    pub allow_multiple_tool_calls: Option<bool>,
    #[serde(rename = "additionalProperties", default)]
    pub additional_properties: serde_json::Value,
}

impl ModelOptions {
    /// Load from a JSON string.
    pub fn from_json(s: &str) -> Result<Self, String> {
        serde_json::from_str(s).map_err(|e| e.to_string())
    }

    /// Serialize to a JSON string.
    pub fn to_json(&self) -> Result<String, String> {
        serde_json::to_string(self).map_err(|e| e.to_string())
    }

    /// Load from a YAML string.
    pub fn from_yaml(s: &str) -> Result<Self, String> {
        serde_yaml::from_str(s).map_err(|e| e.to_string())
    }

    /// Serialize to a YAML string.
    pub fn to_yaml(&self) -> Result<String, String> {
        serde_yaml::to_string(self).map_err(|e| e.to_string())
    }
}
