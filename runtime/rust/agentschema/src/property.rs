// Code generated by AgentSchema emitter; DO NOT EDIT.

#[allow(unused_imports)]
use crate::*;

#[doc(hidden)]
#[derive(serde::Deserialize)]
struct _PropertyFields {
    #[serde(rename = "name", default)]
    name: String,
    #[serde(rename = "kind", default)]
    kind: String,
    #[serde(rename = "description", default)]
    description: Option<String>,
    #[serde(rename = "required", default)]
    required: Option<bool>,
    #[serde(rename = "default", default)]
    default: Option<serde_json::Value>,
    #[serde(rename = "example", default)]
    example: Option<serde_json::Value>,
    #[serde(rename = "enumValues", default)]
    enum_values: Vec<serde_json::Value>,
}

#[doc(hidden)]
#[derive(serde::Deserialize)]
#[serde(untagged)]
enum _PropertyRepr {
    Short(bool),
    Short2(f32),
    Short3(i64),
    Short4(String),
    Full(_PropertyFields),
}

/// Property represents Represents a single property.
///
/// - This model defines the structure of properties that can be used in prompts,
/// including their type, description, whether they are required, and other attributes.
/// - It allows for the definition of dynamic inputs that can be filled with data
/// and processed to generate prompts for AI models.

#[derive(Debug, Clone, Default, serde::Serialize)]
pub struct Property {
    #[serde(rename = "name", default)]
    pub name: String,
    #[serde(rename = "kind", default)]
    pub kind: String,
    #[serde(
        rename = "description",
        skip_serializing_if = "Option::is_none",
        default
    )]
    pub description: Option<String>,
    #[serde(rename = "required", skip_serializing_if = "Option::is_none", default)]
    pub required: Option<bool>,
    #[serde(rename = "default", skip_serializing_if = "Option::is_none", default)]
    pub default: Option<serde_json::Value>,
    #[serde(rename = "example", skip_serializing_if = "Option::is_none", default)]
    pub example: Option<serde_json::Value>,
    #[serde(rename = "enumValues", skip_serializing_if = "Vec::is_empty", default)]
    pub enum_values: Vec<serde_json::Value>,
}

impl<'de> serde::Deserialize<'de> for Property {
    fn deserialize<D: serde::Deserializer<'de>>(d: D) -> Result<Self, D::Error> {
        let repr = _PropertyRepr::deserialize(d)?;
        match repr {
            _PropertyRepr::Short(v) => {
                let expanded = serde_json::json!({
                    "kind": "boolean",
                    "example": v
                });
                let fields: _PropertyFields = serde_json::from_value(expanded)
                    .map_err(|e| serde::de::Error::custom(e.to_string()))?;
                Ok(Property {
                    name: fields.name,
                    kind: fields.kind,
                    description: fields.description,
                    required: fields.required,
                    default: fields.default,
                    example: fields.example,
                    enum_values: fields.enum_values,
                })
            }
            _PropertyRepr::Short2(v) => {
                let expanded = serde_json::json!({
                    "kind": "float",
                    "example": v
                });
                let fields: _PropertyFields = serde_json::from_value(expanded)
                    .map_err(|e| serde::de::Error::custom(e.to_string()))?;
                Ok(Property {
                    name: fields.name,
                    kind: fields.kind,
                    description: fields.description,
                    required: fields.required,
                    default: fields.default,
                    example: fields.example,
                    enum_values: fields.enum_values,
                })
            }
            _PropertyRepr::Short3(v) => {
                let expanded = serde_json::json!({
                    "kind": "integer",
                    "example": v
                });
                let fields: _PropertyFields = serde_json::from_value(expanded)
                    .map_err(|e| serde::de::Error::custom(e.to_string()))?;
                Ok(Property {
                    name: fields.name,
                    kind: fields.kind,
                    description: fields.description,
                    required: fields.required,
                    default: fields.default,
                    example: fields.example,
                    enum_values: fields.enum_values,
                })
            }
            _PropertyRepr::Short4(v) => {
                let expanded = serde_json::json!({
                    "kind": "string",
                    "example": v
                });
                let fields: _PropertyFields = serde_json::from_value(expanded)
                    .map_err(|e| serde::de::Error::custom(e.to_string()))?;
                Ok(Property {
                    name: fields.name,
                    kind: fields.kind,
                    description: fields.description,
                    required: fields.required,
                    default: fields.default,
                    example: fields.example,
                    enum_values: fields.enum_values,
                })
            }
            _PropertyRepr::Full(f) => Ok(Property {
                name: f.name,
                kind: f.kind,
                description: f.description,
                required: f.required,
                default: f.default,
                example: f.example,
                enum_values: f.enum_values,
            }),
        }
    }
}

impl Property {
    /// Load from a JSON string.
    pub fn from_json(s: &str) -> Result<Self, String> {
        serde_json::from_str(s).map_err(|e| e.to_string())
    }

    /// Serialize to a JSON string.
    pub fn to_json(&self) -> Result<String, String> {
        serde_json::to_string(self).map_err(|e| e.to_string())
    }

    /// Load from a YAML string.
    pub fn from_yaml(s: &str) -> Result<Self, String> {
        serde_yaml::from_str(s).map_err(|e| e.to_string())
    }

    /// Serialize to a YAML string.
    pub fn to_yaml(&self) -> Result<String, String> {
        serde_yaml::to_string(self).map_err(|e| e.to_string())
    }

    /// Load from a JSON string, dispatching to the appropriate child type.
    /// Returns a `serde_json::Value` containing the deserialized child type.
    pub fn from_json_polymorphic(s: &str) -> Result<serde_json::Value, String> {
        let val: serde_json::Value = serde_json::from_str(s).map_err(|e| e.to_string())?;
        Self::load_polymorphic(val)
    }

    /// Load from a YAML string, dispatching to the appropriate child type.
    /// Returns a `serde_json::Value` containing the deserialized child type.
    pub fn from_yaml_polymorphic(s: &str) -> Result<serde_json::Value, String> {
        let val: serde_json::Value = serde_yaml::from_str(s).map_err(|e| e.to_string())?;
        Self::load_polymorphic(val)
    }

    /// Dispatch a `serde_json::Value` to the appropriate child type based on
    /// the `kind` discriminator field.
    pub fn load_polymorphic(val: serde_json::Value) -> Result<serde_json::Value, String> {
        if let Some(disc) = val.get("kind").and_then(|v| v.as_str()) {
            match disc {
                "array" => {
                    let typed = ArrayProperty::from_json(
                        &serde_json::to_string(&val).map_err(|e| e.to_string())?,
                    )?;
                    serde_json::to_value(typed).map_err(|e| e.to_string())
                }
                "object" => {
                    let typed = ObjectProperty::from_json(
                        &serde_json::to_string(&val).map_err(|e| e.to_string())?,
                    )?;
                    serde_json::to_value(typed).map_err(|e| e.to_string())
                }
                _ => serde_json::to_value(
                    serde_json::from_value::<Property>(val).map_err(|e| e.to_string())?,
                )
                .map_err(|e| e.to_string()),
            }
        } else {
            Ok(val)
        }
    }
}

/// ArrayProperty represents Represents an array property.
/// This extends the base Property model to represent an array of items.

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct ArrayProperty {
    #[serde(rename = "kind", default)]
    pub kind: String,
    #[serde(rename = "items", default)]
    pub items: serde_json::Value,
}

impl ArrayProperty {
    /// Load from a JSON string.
    pub fn from_json(s: &str) -> Result<Self, String> {
        serde_json::from_str(s).map_err(|e| e.to_string())
    }

    /// Serialize to a JSON string.
    pub fn to_json(&self) -> Result<String, String> {
        serde_json::to_string(self).map_err(|e| e.to_string())
    }

    /// Load from a YAML string.
    pub fn from_yaml(s: &str) -> Result<Self, String> {
        serde_yaml::from_str(s).map_err(|e| e.to_string())
    }

    /// Serialize to a YAML string.
    pub fn to_yaml(&self) -> Result<String, String> {
        serde_yaml::to_string(self).map_err(|e| e.to_string())
    }
}

/// ObjectProperty represents Represents an object property.
/// This extends the base Property model to represent a structured object.

#[derive(Debug, Clone, Default, serde::Serialize, serde::Deserialize)]
pub struct ObjectProperty {
    #[serde(rename = "kind", default)]
    pub kind: String,
    #[serde(rename = "properties", default)]
    pub properties: serde_json::Value,
}

impl ObjectProperty {
    /// Load from a JSON string.
    pub fn from_json(s: &str) -> Result<Self, String> {
        serde_json::from_str(s).map_err(|e| e.to_string())
    }

    /// Serialize to a JSON string.
    pub fn to_json(&self) -> Result<String, String> {
        serde_json::to_string(self).map_err(|e| e.to_string())
    }

    /// Load from a YAML string.
    pub fn from_yaml(s: &str) -> Result<Self, String> {
        serde_yaml::from_str(s).map_err(|e| e.to_string())
    }

    /// Serialize to a YAML string.
    pub fn to_yaml(&self) -> Result<String, String> {
        serde_yaml::to_string(self).map_err(|e| e.to_string())
    }
}
