// Code generated by AgentSchema emitter; DO NOT EDIT.

use crate::context::{LoadContext, SaveContext};

/// Represents a single property.
///
/// - This model defines the structure of properties that can be used in prompts,
/// including their type, description, whether they are required, and other attributes.
/// - It allows for the definition of dynamic inputs that can be filled with data
/// and processed to generate prompts for AI models.
#[derive(Debug, Clone)]
pub struct Property {
    /// Name of the property
    pub name: String,
    /// The data type of the input property
    pub kind: String,
    /// A short description of the input property
    pub description: Option<String>,
    /// Whether the property is required
    pub required: Option<bool>,
    /// The default value of the property - this represents the default value if none is provided
    pub default: Option<serde_json::Value>,
    /// Example value used for either initialization or tooling
    pub example: Option<serde_json::Value>,
    /// Allowed enumeration values for the property
    pub enum_values: Option<Vec<serde_json::Value>>,
}

impl Default for Property {
    fn default() -> Self {
        Property {
            name: String::from(""),
            kind: String::from(""),
            description: None,
            required: None,
            default: None,
            example: None,
            enum_values: None,
        }
    }
}

impl Property {
    /// Create a new Property with default values.
    pub fn new() -> Self {
        Self::default()
    }

    /// Load Property from a JSON string.
    pub fn from_json(json: &str) -> Result<Self, serde_json::Error> {
        let value: serde_json::Value = serde_json::from_str(json)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load Property from a YAML string.
    pub fn from_yaml(yaml: &str) -> Result<Self, serde_yaml::Error> {
        let value: serde_json::Value = serde_yaml::from_str(yaml)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load Property from a `serde_json::Value`.
    pub fn load_from_value(value: &serde_json::Value) -> Self {
        let mut result = Self::default();
        if let Some(value) = value.as_bool() {
            let expansion = serde_json::json!({"kind":"boolean","example":value});
            return Self::load_from_value(&expansion);
        }
        if let Some(value) = value.as_f64() {
            let expansion = serde_json::json!({"kind":"float","example":value});
            return Self::load_from_value(&expansion);
        }
        if let Some(value) = value.as_i64() {
            let expansion = serde_json::json!({"kind":"integer","example":value});
            return Self::load_from_value(&expansion);
        }
        if let Some(s) = value.as_str() {
            let value = s.to_string();
            let expansion = serde_json::json!({"kind":"string","example":value});
            return Self::load_from_value(&expansion);
        }
        // Load fields from JSON object
        result.name = value
            .get("name")
            .and_then(|v| v.as_str())
            .unwrap_or_default()
            .to_string();
        result.kind = value
            .get("kind")
            .and_then(|v| v.as_str())
            .unwrap_or_default()
            .to_string();
        result.description = value
            .get("description")
            .and_then(|v| v.as_str())
            .map(|s| s.to_string());
        result.required = value.get("required").and_then(|v| v.as_bool());
        if let Some(val) = value.get("default") {
            result.default = Some(val.clone());
        }
        if let Some(val) = value.get("example") {
            result.example = Some(val.clone());
        }
        if let Some(arr) = value.get("enumValues").and_then(|v| v.as_array()) {
            result.enum_values = Some(arr.iter().cloned().collect());
        }
        result
    }

    /// Serialize Property to a `serde_json::Value`.
    pub fn to_value(&self) -> serde_json::Value {
        let mut result = serde_json::Map::new();
        if !self.name.is_empty() {
            result.insert(
                "name".to_string(),
                serde_json::Value::String(self.name.clone()),
            );
        }
        if !self.kind.is_empty() {
            result.insert(
                "kind".to_string(),
                serde_json::Value::String(self.kind.clone()),
            );
        }
        if let Some(ref val) = self.description {
            result.insert(
                "description".to_string(),
                serde_json::Value::String(val.clone()),
            );
        }
        if let Some(val) = self.required {
            result.insert("required".to_string(), serde_json::Value::Bool(val));
        }
        if let Some(ref val) = self.default {
            result.insert(
                "default".to_string(),
                serde_json::to_value(val).unwrap_or(serde_json::Value::Null),
            );
        }
        if let Some(ref val) = self.example {
            result.insert(
                "example".to_string(),
                serde_json::to_value(val).unwrap_or(serde_json::Value::Null),
            );
        }
        if let Some(ref items) = self.enum_values {
            result.insert(
                "enumValues".to_string(),
                serde_json::to_value(items).unwrap_or(serde_json::Value::Null),
            );
        }
        serde_json::Value::Object(result)
    }

    /// Serialize Property to a JSON string.
    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string_pretty(&self.to_value())
    }

    /// Serialize Property to a YAML string.
    pub fn to_yaml(&self) -> Result<String, serde_yaml::Error> {
        serde_yaml::to_string(&self.to_value())
    }
}

/// Represents an array property.
/// This extends the base Property model to represent an array of items.
#[derive(Debug, Clone)]
pub struct ArrayProperty {
    pub kind: String,
    /// The type of items contained in the array
    pub items: serde_json::Value,
}

impl Default for ArrayProperty {
    fn default() -> Self {
        ArrayProperty {
            kind: String::from("array"),
            items: serde_json::Value::Null,
        }
    }
}

impl ArrayProperty {
    /// Create a new ArrayProperty with default values.
    pub fn new() -> Self {
        Self::default()
    }

    /// Load ArrayProperty from a JSON string.
    pub fn from_json(json: &str) -> Result<Self, serde_json::Error> {
        let value: serde_json::Value = serde_json::from_str(json)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load ArrayProperty from a YAML string.
    pub fn from_yaml(yaml: &str) -> Result<Self, serde_yaml::Error> {
        let value: serde_json::Value = serde_yaml::from_str(yaml)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load ArrayProperty from a `serde_json::Value`.
    pub fn load_from_value(value: &serde_json::Value) -> Self {
        let mut result = Self::default();
        // Load fields from JSON object
        result.kind = value
            .get("kind")
            .and_then(|v| v.as_str())
            .unwrap_or_default()
            .to_string();
        if let Some(val) = value.get("items") {
            result.items = val.clone();
        }
        result
    }

    /// Serialize ArrayProperty to a `serde_json::Value`.
    pub fn to_value(&self) -> serde_json::Value {
        let mut result = serde_json::Map::new();
        if !self.kind.is_empty() {
            result.insert(
                "kind".to_string(),
                serde_json::Value::String(self.kind.clone()),
            );
        }
        if !self.items.is_null() {
            result.insert("items".to_string(), self.items.clone());
        }
        serde_json::Value::Object(result)
    }

    /// Serialize ArrayProperty to a JSON string.
    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string_pretty(&self.to_value())
    }

    /// Serialize ArrayProperty to a YAML string.
    pub fn to_yaml(&self) -> Result<String, serde_yaml::Error> {
        serde_yaml::to_string(&self.to_value())
    }
}

/// Represents an object property.
/// This extends the base Property model to represent a structured object.
#[derive(Debug, Clone)]
pub struct ObjectProperty {
    pub kind: String,
    /// The properties contained in the object
    pub properties: serde_json::Value,
}

impl Default for ObjectProperty {
    fn default() -> Self {
        ObjectProperty {
            kind: String::from("object"),
            properties: serde_json::Value::Null,
        }
    }
}

impl ObjectProperty {
    /// Create a new ObjectProperty with default values.
    pub fn new() -> Self {
        Self::default()
    }

    /// Load ObjectProperty from a JSON string.
    pub fn from_json(json: &str) -> Result<Self, serde_json::Error> {
        let value: serde_json::Value = serde_json::from_str(json)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load ObjectProperty from a YAML string.
    pub fn from_yaml(yaml: &str) -> Result<Self, serde_yaml::Error> {
        let value: serde_json::Value = serde_yaml::from_str(yaml)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load ObjectProperty from a `serde_json::Value`.
    pub fn load_from_value(value: &serde_json::Value) -> Self {
        let mut result = Self::default();
        // Load fields from JSON object
        result.kind = value
            .get("kind")
            .and_then(|v| v.as_str())
            .unwrap_or_default()
            .to_string();
        if let Some(val) = value.get("properties") {
            result.properties = val.clone();
        }
        result
    }

    /// Serialize ObjectProperty to a `serde_json::Value`.
    pub fn to_value(&self) -> serde_json::Value {
        let mut result = serde_json::Map::new();
        if !self.kind.is_empty() {
            result.insert(
                "kind".to_string(),
                serde_json::Value::String(self.kind.clone()),
            );
        }
        if !self.properties.is_null() {
            result.insert("properties".to_string(), self.properties.clone());
        }
        serde_json::Value::Object(result)
    }

    /// Serialize ObjectProperty to a JSON string.
    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string_pretty(&self.to_value())
    }

    /// Serialize ObjectProperty to a YAML string.
    pub fn to_yaml(&self) -> Result<String, serde_yaml::Error> {
        serde_yaml::to_string(&self.to_value())
    }
    /// Returns typed `Vec<Property>` by parsing the stored JSON value.
    /// Handles both array format `[{...}]` and dict format `{"name": {...}}`.
    /// Returns `None` if the field is null or cannot be parsed.
    pub fn as_properties(&self) -> Option<Vec<Property>> {
        match &self.properties {
            serde_json::Value::Array(arr) => {
                Some(arr.iter().map(Property::load_from_value).collect())
            }
            serde_json::Value::Object(obj) => {
                let result: Vec<Property> = obj
                    .iter()
                    .map(|(name, value)| {
                        let mut v = if value.is_object() {
                            value.clone()
                        } else {
                            serde_json::json!({ "value": value })
                        };
                        if let serde_json::Value::Object(ref mut m) = v {
                            m.entry("name".to_string())
                                .or_insert_with(|| serde_json::Value::String(name.clone()));
                        }
                        Property::load_from_value(&v)
                    })
                    .collect();
                Some(result)
            }
            _ => None,
        }
    }
}
