// Code generated by AgentSchema emitter; DO NOT EDIT.

use crate::property_schema::PropertySchema;

use crate::resource::Resource;

/// The following represents a manifest that can be used to create agents dynamically.
/// It includes parameters that can be used to configure the agent's behavior.
/// These parameters include values that can be used as publisher parameters that can
/// be used to describe additional variables that have been tested and are known to work.
///
/// Variables described here are then used to project into a prompt agent that can be executed.
/// Once parameters are provided, these can be referenced in the manifest using the following notation:
///
/// `{{myParameter}}`
///
/// This allows for dynamic configuration of the agent based on the provided parameters.
/// (This notation is used elsewhere, but only the `param` scope is supported here)
#[derive(Debug, Clone)]
pub struct AgentManifest {
    /// Name of the manifest
    pub name: String,
    /// Human-readable name of the manifest
    pub display_name: String,
    /// Description of the agent's capabilities and purpose
    pub description: Option<String>,
    /// Additional metadata including authors, tags, and other arbitrary properties
    pub metadata: serde_json::Value,
    /// The agent that this manifest is based on
    pub template: serde_json::Value,
    /// Parameters for configuring the agent's behavior and execution
    pub parameters: PropertySchema,
    /// Resources required by the agent, such as models or tools
    pub resources: serde_json::Value,
}

impl Default for AgentManifest {
    fn default() -> Self {
        AgentManifest {
            name: String::from(""),
            display_name: String::from(""),
            description: None,
            metadata: serde_json::Value::Null,
            template: serde_json::Value::Null,
            parameters: Default::default(),
            resources: serde_json::Value::Null,
        }
    }
}

impl AgentManifest {
    /// Create a new AgentManifest with default values.
    pub fn new() -> Self {
        Self::default()
    }

    /// Load AgentManifest from a JSON string.
    pub fn from_json(json: &str) -> Result<Self, serde_json::Error> {
        let value: serde_json::Value = serde_json::from_str(json)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load AgentManifest from a YAML string.
    pub fn from_yaml(yaml: &str) -> Result<Self, serde_yaml::Error> {
        let value: serde_json::Value = serde_yaml::from_str(yaml)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load AgentManifest from a `serde_json::Value`.
    pub fn load_from_value(value: &serde_json::Value) -> Self {
        let mut result = Self::default();
        // Load fields from JSON object
        result.name = value
            .get("name")
            .and_then(|v| v.as_str())
            .unwrap_or_default()
            .to_string();
        result.display_name = value
            .get("displayName")
            .and_then(|v| v.as_str())
            .unwrap_or_default()
            .to_string();
        result.description = value
            .get("description")
            .and_then(|v| v.as_str())
            .map(|s| s.to_string());
        if let Some(val) = value.get("metadata") {
            result.metadata = val.clone();
        }
        if let Some(val) = value.get("template") {
            result.template = val.clone();
        }
        if let Some(val) = value.get("parameters") {
            if val.is_object() || val.is_array() {
                result.parameters = PropertySchema::load_from_value(val);
            }
        }
        if let Some(val) = value.get("resources") {
            result.resources = val.clone();
        }
        result
    }

    /// Serialize AgentManifest to a `serde_json::Value`.
    pub fn to_value(&self) -> serde_json::Value {
        let mut result = serde_json::Map::new();
        if !self.name.is_empty() {
            result.insert(
                "name".to_string(),
                serde_json::Value::String(self.name.clone()),
            );
        }
        if !self.display_name.is_empty() {
            result.insert(
                "displayName".to_string(),
                serde_json::Value::String(self.display_name.clone()),
            );
        }
        if let Some(ref val) = self.description {
            result.insert(
                "description".to_string(),
                serde_json::Value::String(val.clone()),
            );
        }
        if !self.metadata.is_null() {
            result.insert("metadata".to_string(), self.metadata.clone());
        }
        if !self.template.is_null() {
            result.insert("template".to_string(), self.template.clone());
        }
        {
            let nested = self.parameters.to_value();
            if !nested.is_null() {
                result.insert("parameters".to_string(), nested);
            }
        }
        if !self.resources.is_null() {
            result.insert("resources".to_string(), self.resources.clone());
        }
        serde_json::Value::Object(result)
    }

    /// Serialize AgentManifest to a JSON string.
    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string_pretty(&self.to_value())
    }

    /// Serialize AgentManifest to a YAML string.
    pub fn to_yaml(&self) -> Result<String, serde_yaml::Error> {
        serde_yaml::to_string(&self.to_value())
    }
    /// Returns typed reference to the map if the field is an object.
    /// Returns `None` if the field is null or not an object.
    pub fn as_metadata_dict(&self) -> Option<&serde_json::Map<String, serde_json::Value>> {
        self.metadata.as_object()
    }
    /// Returns typed `Vec<Resource>` by parsing the stored JSON value.
    /// Handles both array format `[{...}]` and dict format `{"name": {...}}`.
    /// Returns `None` if the field is null or cannot be parsed.
    pub fn as_resources(&self) -> Option<Vec<Resource>> {
        match &self.resources {
            serde_json::Value::Array(arr) => {
                Some(arr.iter().map(Resource::load_from_value).collect())
            }
            serde_json::Value::Object(obj) => {
                let result: Vec<Resource> = obj
                    .iter()
                    .map(|(name, value)| {
                        let mut v = if value.is_object() {
                            value.clone()
                        } else {
                            serde_json::json!({ "value": value })
                        };
                        if let serde_json::Value::Object(ref mut m) = v {
                            m.entry("name".to_string())
                                .or_insert_with(|| serde_json::Value::String(name.clone()));
                        }
                        Resource::load_from_value(&v)
                    })
                    .collect();
                Some(result)
            }
            _ => None,
        }
    }
}
