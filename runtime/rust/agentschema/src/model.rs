// Code generated by AgentSchema emitter; DO NOT EDIT.

use crate::context::{LoadContext, SaveContext};

use crate::connection::Connection;

use crate::model_options::ModelOptions;

/// Model for defining the structure and behavior of AI agents.
/// This model includes properties for specifying the model's provider, connection details, and various options.
/// It allows for flexible configuration of AI models to suit different use cases and requirements.
#[derive(Debug, Clone)]
pub struct Model {
    /// The unique identifier of the model - can be used as the single property shorthand
    pub id: String,
    /// The provider of the model (e.g., 'openai', 'azure', 'anthropic')
    pub provider: Option<String>,
    /// The type of API to use for the model (e.g., 'chat', 'response', etc.)
    pub api_type: Option<String>,
    /// The connection configuration for the model
    pub connection: serde_json::Value,
    /// Additional options for the model
    pub options: Option<ModelOptions>,
}

impl Default for Model {
    fn default() -> Self {
        Model {
            id: String::from(""),
            provider: None,
            api_type: None,
            connection: serde_json::Value::Null,
            options: None,
        }
    }
}

impl Model {
    /// Create a new Model with default values.
    pub fn new() -> Self {
        Self::default()
    }

    /// Load Model from a JSON string.
    pub fn from_json(json: &str) -> Result<Self, serde_json::Error> {
        let value: serde_json::Value = serde_json::from_str(json)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load Model from a YAML string.
    pub fn from_yaml(yaml: &str) -> Result<Self, serde_yaml::Error> {
        let value: serde_json::Value = serde_yaml::from_str(yaml)?;
        Ok(Self::load_from_value(&value))
    }

    /// Load Model from a `serde_json::Value`.
    pub fn load_from_value(value: &serde_json::Value) -> Self {
        let mut result = Self::default();
        if let Some(s) = value.as_str() {
            let value = s.to_string();
            let expansion = serde_json::json!({"id":value});
            return Self::load_from_value(&expansion);
        }
        // Load fields from JSON object
        result.id = value
            .get("id")
            .and_then(|v| v.as_str())
            .unwrap_or_default()
            .to_string();
        result.provider = value
            .get("provider")
            .and_then(|v| v.as_str())
            .map(|s| s.to_string());
        result.api_type = value
            .get("apiType")
            .and_then(|v| v.as_str())
            .map(|s| s.to_string());
        if let Some(val) = value.get("connection") {
            result.connection = val.clone();
        }
        if let Some(val) = value.get("options") {
            if val.is_object() || val.is_array() {
                result.options = Some(ModelOptions::load_from_value(val));
            }
        }
        result
    }

    /// Serialize Model to a `serde_json::Value`.
    pub fn to_value(&self) -> serde_json::Value {
        let mut result = serde_json::Map::new();
        if !self.id.is_empty() {
            result.insert("id".to_string(), serde_json::Value::String(self.id.clone()));
        }
        if let Some(ref val) = self.provider {
            result.insert(
                "provider".to_string(),
                serde_json::Value::String(val.clone()),
            );
        }
        if let Some(ref val) = self.api_type {
            result.insert(
                "apiType".to_string(),
                serde_json::Value::String(val.clone()),
            );
        }
        if !self.connection.is_null() {
            result.insert("connection".to_string(), self.connection.clone());
        }
        if let Some(ref val) = self.options {
            let nested = val.to_value();
            if !nested.is_null() {
                result.insert("options".to_string(), nested);
            }
        }
        serde_json::Value::Object(result)
    }

    /// Serialize Model to a JSON string.
    pub fn to_json(&self) -> Result<String, serde_json::Error> {
        serde_json::to_string_pretty(&self.to_value())
    }

    /// Serialize Model to a YAML string.
    pub fn to_yaml(&self) -> Result<String, serde_yaml::Error> {
        serde_yaml::to_string(&self.to_value())
    }
}
