// Code generated by AgentSchema emitter; DO NOT EDIT.

package agentschema

import (
	"encoding/json"

	"gopkg.in/yaml.v3"
)

// AgentDefinition represents The following is a specification for defining AI agents with structured metadata, inputs, outputs, tools, and templates.
// It provides a way to create reusable and composable AI agents that can be executed with specific configurations.
// The specification includes metadata about the agent, model configuration, input parameters, expected outputs,
// available tools, and template configurations for prompt rendering.

type AgentDefinition struct {
	Kind         string                 `json:"kind" yaml:"kind"`
	Name         string                 `json:"name" yaml:"name"`
	DisplayName  *string                `json:"displayName,omitempty" yaml:"displayName,omitempty"`
	Description  *string                `json:"description,omitempty" yaml:"description,omitempty"`
	Metadata     map[string]interface{} `json:"metadata,omitempty" yaml:"metadata,omitempty"`
	InputSchema  *PropertySchema        `json:"inputSchema,omitempty" yaml:"inputSchema,omitempty"`
	OutputSchema *PropertySchema        `json:"outputSchema,omitempty" yaml:"outputSchema,omitempty"`
}

// LoadAgentDefinition creates a AgentDefinition from a map[string]interface{}
// Returns interface{} because this is a polymorphic base type that can resolve to different child types
func LoadAgentDefinition(data interface{}, ctx *LoadContext) (interface{}, error) {
	result := AgentDefinition{}

	// Handle polymorphic types based on discriminator
	if m, ok := data.(map[string]interface{}); ok {
		if discriminator, ok := m["kind"]; ok {
			switch discriminator {
			case "prompt":
				return LoadPromptAgent(data, ctx)
			case "workflow":
				return LoadWorkflow(data, ctx)
			case "hosted":
				return LoadContainerAgent(data, ctx)
			}
		}
	}
	// Load from map
	if m, ok := data.(map[string]interface{}); ok {
		if val, ok := m["kind"]; ok && val != nil {
			result.Kind = val.(string)
		}
		if val, ok := m["name"]; ok && val != nil {
			result.Name = val.(string)
		}
		if val, ok := m["displayName"]; ok && val != nil {
			v := val.(string)
			result.DisplayName = &v
		}
		if val, ok := m["description"]; ok && val != nil {
			v := val.(string)
			result.Description = &v
		}
		if val, ok := m["metadata"]; ok && val != nil {
			if m, ok := val.(map[string]interface{}); ok {
				result.Metadata = m
			}
		}
		if val, ok := m["inputSchema"]; ok && val != nil {
			if m, ok := val.(map[string]interface{}); ok {
				loaded, _ := LoadPropertySchema(m, ctx)
				result.InputSchema = &loaded
			}
		}
		if val, ok := m["outputSchema"]; ok && val != nil {
			if m, ok := val.(map[string]interface{}); ok {
				loaded, _ := LoadPropertySchema(m, ctx)
				result.OutputSchema = &loaded
			}
		}
	}

	return result, nil
}

// Save serializes AgentDefinition to map[string]interface{}
func (obj *AgentDefinition) Save(ctx *SaveContext) map[string]interface{} {
	result := make(map[string]interface{})
	result["kind"] = obj.Kind
	result["name"] = obj.Name
	if obj.DisplayName != nil {
		result["displayName"] = *obj.DisplayName
	}
	if obj.Description != nil {
		result["description"] = *obj.Description
	}
	if obj.Metadata != nil {
		result["metadata"] = obj.Metadata
	}
	if obj.InputSchema != nil {
		result["inputSchema"] = obj.InputSchema.Save(ctx)
	}
	if obj.OutputSchema != nil {
		result["outputSchema"] = obj.OutputSchema.Save(ctx)
	}

	return result
}

// ToJSON serializes AgentDefinition to JSON string
func (obj *AgentDefinition) ToJSON() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := json.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// ToYAML serializes AgentDefinition to YAML string
func (obj *AgentDefinition) ToYAML() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := yaml.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// FromJSON creates AgentDefinition from JSON string
// Returns interface{} because this is a polymorphic base type that can resolve to different child types
func AgentDefinitionFromJSON(jsonStr string) (interface{}, error) {
	var data map[string]interface{}
	if err := json.Unmarshal([]byte(jsonStr), &data); err != nil {
		return nil, err
	}
	ctx := NewLoadContext()
	return LoadAgentDefinition(data, ctx)
}

// FromYAML creates AgentDefinition from YAML string
// Returns interface{} because this is a polymorphic base type that can resolve to different child types
func AgentDefinitionFromYAML(yamlStr string) (interface{}, error) {
	var data map[string]interface{}
	if err := yaml.Unmarshal([]byte(yamlStr), &data); err != nil {
		return nil, err
	}
	ctx := NewLoadContext()
	return LoadAgentDefinition(data, ctx)
}

// PromptAgent represents Prompt based agent definition. Used to create agents that can be executed directly.
// These agents can leverage tools, input parameters, and templates to generate responses.
// They are designed to be straightforward and easy to use for various applications.

type PromptAgent struct {
	Kind                   string        `json:"kind" yaml:"kind"`
	Model                  Model         `json:"model" yaml:"model"`
	Tools                  []interface{} `json:"tools,omitempty" yaml:"tools,omitempty"`
	Template               *Template     `json:"template,omitempty" yaml:"template,omitempty"`
	Instructions           *string       `json:"instructions,omitempty" yaml:"instructions,omitempty"`
	AdditionalInstructions *string       `json:"additionalInstructions,omitempty" yaml:"additionalInstructions,omitempty"`
}

// LoadPromptAgent creates a PromptAgent from a map[string]interface{}
func LoadPromptAgent(data interface{}, ctx *LoadContext) (PromptAgent, error) {
	result := PromptAgent{}

	// Load from map
	if m, ok := data.(map[string]interface{}); ok {
		if val, ok := m["kind"]; ok && val != nil {
			result.Kind = val.(string)
		}
		if val, ok := m["model"]; ok && val != nil {
			if m, ok := val.(map[string]interface{}); ok {
				loaded, _ := LoadModel(m, ctx)
				result.Model = loaded
			}
		}
		if val, ok := m["tools"]; ok && val != nil {
			if arr, ok := val.([]interface{}); ok {
				result.Tools = make([]interface{}, len(arr))
				for i, v := range arr {
					if item, ok := v.(map[string]interface{}); ok {
						loaded, _ := LoadTool(item, ctx)
						// Polymorphic type - store as interface{}
						result.Tools[i] = loaded
					}
				}
			}
		}
		if val, ok := m["template"]; ok && val != nil {
			if m, ok := val.(map[string]interface{}); ok {
				loaded, _ := LoadTemplate(m, ctx)
				result.Template = &loaded
			}
		}
		if val, ok := m["instructions"]; ok && val != nil {
			v := val.(string)
			result.Instructions = &v
		}
		if val, ok := m["additionalInstructions"]; ok && val != nil {
			v := val.(string)
			result.AdditionalInstructions = &v
		}
	}

	return result, nil
}

// Save serializes PromptAgent to map[string]interface{}
func (obj *PromptAgent) Save(ctx *SaveContext) map[string]interface{} {
	result := make(map[string]interface{})
	result["kind"] = obj.Kind

	result["model"] = obj.Model.Save(ctx)
	if obj.Tools != nil {
		arr := make([]interface{}, len(obj.Tools))
		for i, item := range obj.Tools {
			// Handle polymorphic type via type switch
			switch v := item.(type) {
			case interface {
				Save(*SaveContext) map[string]interface{}
			}:
				arr[i] = v.Save(ctx)
			default:
				arr[i] = item
			}
		}
		result["tools"] = arr
	}
	if obj.Template != nil {
		result["template"] = obj.Template.Save(ctx)
	}
	if obj.Instructions != nil {
		result["instructions"] = *obj.Instructions
	}
	if obj.AdditionalInstructions != nil {
		result["additionalInstructions"] = *obj.AdditionalInstructions
	}

	return result
}

// ToJSON serializes PromptAgent to JSON string
func (obj *PromptAgent) ToJSON() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := json.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// ToYAML serializes PromptAgent to YAML string
func (obj *PromptAgent) ToYAML() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := yaml.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// FromJSON creates PromptAgent from JSON string
func PromptAgentFromJSON(jsonStr string) (PromptAgent, error) {
	var data map[string]interface{}
	if err := json.Unmarshal([]byte(jsonStr), &data); err != nil {
		return PromptAgent{}, err
	}
	ctx := NewLoadContext()
	return LoadPromptAgent(data, ctx)
}

// FromYAML creates PromptAgent from YAML string
func PromptAgentFromYAML(yamlStr string) (PromptAgent, error) {
	var data map[string]interface{}
	if err := yaml.Unmarshal([]byte(yamlStr), &data); err != nil {
		return PromptAgent{}, err
	}
	ctx := NewLoadContext()
	return LoadPromptAgent(data, ctx)
}

// Workflow represents A workflow agent that can orchestrate multiple steps and actions.
// This agent type is designed to handle complex workflows that may involve
// multiple tools, models, and decision points.
//
// The workflow agent can be configured with a series of steps that define
// the flow of execution, including conditional logic and parallel processing.
// This allows for the creation of sophisticated AI-driven processes that can
// adapt to various scenarios and requirements.
//
// Note: The detailed structure of the workflow steps and actions is not defined here
// and would need to be implemented based on specific use cases and requirements.

type Workflow struct {
	Kind    string                 `json:"kind" yaml:"kind"`
	Trigger map[string]interface{} `json:"trigger,omitempty" yaml:"trigger,omitempty"`
}

// LoadWorkflow creates a Workflow from a map[string]interface{}
func LoadWorkflow(data interface{}, ctx *LoadContext) (Workflow, error) {
	result := Workflow{}

	// Load from map
	if m, ok := data.(map[string]interface{}); ok {
		if val, ok := m["kind"]; ok && val != nil {
			result.Kind = val.(string)
		}
		if val, ok := m["trigger"]; ok && val != nil {
			if m, ok := val.(map[string]interface{}); ok {
				result.Trigger = m
			}
		}
	}

	return result, nil
}

// Save serializes Workflow to map[string]interface{}
func (obj *Workflow) Save(ctx *SaveContext) map[string]interface{} {
	result := make(map[string]interface{})
	result["kind"] = obj.Kind
	if obj.Trigger != nil {
		result["trigger"] = obj.Trigger
	}

	return result
}

// ToJSON serializes Workflow to JSON string
func (obj *Workflow) ToJSON() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := json.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// ToYAML serializes Workflow to YAML string
func (obj *Workflow) ToYAML() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := yaml.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// FromJSON creates Workflow from JSON string
func WorkflowFromJSON(jsonStr string) (Workflow, error) {
	var data map[string]interface{}
	if err := json.Unmarshal([]byte(jsonStr), &data); err != nil {
		return Workflow{}, err
	}
	ctx := NewLoadContext()
	return LoadWorkflow(data, ctx)
}

// FromYAML creates Workflow from YAML string
func WorkflowFromYAML(yamlStr string) (Workflow, error) {
	var data map[string]interface{}
	if err := yaml.Unmarshal([]byte(yamlStr), &data); err != nil {
		return Workflow{}, err
	}
	ctx := NewLoadContext()
	return LoadWorkflow(data, ctx)
}

// ContainerAgent represents This represents a container based agent hosted by the provider/publisher.
// The intent is to represent a container application that the user wants to run
// in a hosted environment that the provider manages.

type ContainerAgent struct {
	Kind                 string                  `json:"kind" yaml:"kind"`
	Protocols            []ProtocolVersionRecord `json:"protocols" yaml:"protocols"`
	Image                string                  `json:"image" yaml:"image"`
	Resources            ContainerResources      `json:"resources" yaml:"resources"`
	EnvironmentVariables []EnvironmentVariable   `json:"environmentVariables,omitempty" yaml:"environmentVariables,omitempty"`
}

// LoadContainerAgent creates a ContainerAgent from a map[string]interface{}
func LoadContainerAgent(data interface{}, ctx *LoadContext) (ContainerAgent, error) {
	result := ContainerAgent{}

	// Load from map
	if m, ok := data.(map[string]interface{}); ok {
		if val, ok := m["kind"]; ok && val != nil {
			result.Kind = val.(string)
		}
		if val, ok := m["protocols"]; ok && val != nil {
			if arr, ok := val.([]interface{}); ok {
				result.Protocols = make([]ProtocolVersionRecord, len(arr))
				for i, v := range arr {
					if item, ok := v.(map[string]interface{}); ok {
						loaded, _ := LoadProtocolVersionRecord(item, ctx)
						result.Protocols[i] = loaded
					}
				}
			}
		}
		if val, ok := m["image"]; ok && val != nil {
			result.Image = val.(string)
		}
		if val, ok := m["resources"]; ok && val != nil {
			if m, ok := val.(map[string]interface{}); ok {
				loaded, _ := LoadContainerResources(m, ctx)
				result.Resources = loaded
			}
		}
		if val, ok := m["environmentVariables"]; ok && val != nil {
			if arr, ok := val.([]interface{}); ok {
				result.EnvironmentVariables = make([]EnvironmentVariable, len(arr))
				for i, v := range arr {
					if item, ok := v.(map[string]interface{}); ok {
						loaded, _ := LoadEnvironmentVariable(item, ctx)
						result.EnvironmentVariables[i] = loaded
					}
				}
			}
		}
	}

	return result, nil
}

// Save serializes ContainerAgent to map[string]interface{}
func (obj *ContainerAgent) Save(ctx *SaveContext) map[string]interface{} {
	result := make(map[string]interface{})
	result["kind"] = obj.Kind
	if obj.Protocols != nil {
		arr := make([]interface{}, len(obj.Protocols))
		for i, item := range obj.Protocols {
			arr[i] = item.Save(ctx)
		}
		result["protocols"] = arr
	}
	result["image"] = obj.Image

	result["resources"] = obj.Resources.Save(ctx)
	if obj.EnvironmentVariables != nil {
		arr := make([]interface{}, len(obj.EnvironmentVariables))
		for i, item := range obj.EnvironmentVariables {
			arr[i] = item.Save(ctx)
		}
		result["environmentVariables"] = arr
	}

	return result
}

// ToJSON serializes ContainerAgent to JSON string
func (obj *ContainerAgent) ToJSON() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := json.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// ToYAML serializes ContainerAgent to YAML string
func (obj *ContainerAgent) ToYAML() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := yaml.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// FromJSON creates ContainerAgent from JSON string
func ContainerAgentFromJSON(jsonStr string) (ContainerAgent, error) {
	var data map[string]interface{}
	if err := json.Unmarshal([]byte(jsonStr), &data); err != nil {
		return ContainerAgent{}, err
	}
	ctx := NewLoadContext()
	return LoadContainerAgent(data, ctx)
}

// FromYAML creates ContainerAgent from YAML string
func ContainerAgentFromYAML(yamlStr string) (ContainerAgent, error) {
	var data map[string]interface{}
	if err := yaml.Unmarshal([]byte(yamlStr), &data); err != nil {
		return ContainerAgent{}, err
	}
	ctx := NewLoadContext()
	return LoadContainerAgent(data, ctx)
}
