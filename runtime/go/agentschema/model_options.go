// Copyright (c) Microsoft. All rights reserved.
// WARNING: This is an auto-generated file. DO NOT EDIT THIS FILE DIRECTLY.

package agentschema

import (
	"encoding/json"

	"gopkg.in/yaml.v3"
)

// ModelOptions represents Options for configuring the behavior of the AI model.
// `kind` is a required property here, but this section can accept additional via options.

type ModelOptions struct {
	FrequencyPenalty       *float32               `json:"frequencyPenalty,omitempty" yaml:"frequencyPenalty,omitempty"`
	MaxOutputTokens        *int32                 `json:"maxOutputTokens,omitempty" yaml:"maxOutputTokens,omitempty"`
	PresencePenalty        *float32               `json:"presencePenalty,omitempty" yaml:"presencePenalty,omitempty"`
	Seed                   *int32                 `json:"seed,omitempty" yaml:"seed,omitempty"`
	Temperature            *float32               `json:"temperature,omitempty" yaml:"temperature,omitempty"`
	TopK                   *int32                 `json:"topK,omitempty" yaml:"topK,omitempty"`
	TopP                   *float32               `json:"topP,omitempty" yaml:"topP,omitempty"`
	StopSequences          []string               `json:"stopSequences,omitempty" yaml:"stopSequences,omitempty"`
	AllowMultipleToolCalls *bool                  `json:"allowMultipleToolCalls,omitempty" yaml:"allowMultipleToolCalls,omitempty"`
	AdditionalProperties   map[string]interface{} `json:"additionalProperties,omitempty" yaml:"additionalProperties,omitempty"`
}

// LoadModelOptions creates a ModelOptions from a map[string]interface{}
func LoadModelOptions(data interface{}, ctx *LoadContext) (ModelOptions, error) {
	result := ModelOptions{}

	// Load from map
	if m, ok := data.(map[string]interface{}); ok {
		if val, ok := m["frequencyPenalty"]; ok && val != nil { // Handle various numeric types from JSON/YAML/roundtrip
			var v float32
			switch n := val.(type) {
			case int:
				v = float32(n)
			case int32:
				v = float32(n)
			case int64:
				v = float32(n)
			case float32:
				v = n
			case float64:
				v = float32(n)
			}
			result.FrequencyPenalty = &v
		}
		if val, ok := m["maxOutputTokens"]; ok && val != nil { // Handle various numeric types from JSON/YAML/roundtrip
			var v int32
			switch n := val.(type) {
			case int:
				v = int32(n)
			case int32:
				v = int32(n)
			case int64:
				v = int32(n)
			case float64:
				v = int32(n)
			}
			result.MaxOutputTokens = &v
		}
		if val, ok := m["presencePenalty"]; ok && val != nil { // Handle various numeric types from JSON/YAML/roundtrip
			var v float32
			switch n := val.(type) {
			case int:
				v = float32(n)
			case int32:
				v = float32(n)
			case int64:
				v = float32(n)
			case float32:
				v = n
			case float64:
				v = float32(n)
			}
			result.PresencePenalty = &v
		}
		if val, ok := m["seed"]; ok && val != nil { // Handle various numeric types from JSON/YAML/roundtrip
			var v int32
			switch n := val.(type) {
			case int:
				v = int32(n)
			case int32:
				v = int32(n)
			case int64:
				v = int32(n)
			case float64:
				v = int32(n)
			}
			result.Seed = &v
		}
		if val, ok := m["temperature"]; ok && val != nil { // Handle various numeric types from JSON/YAML/roundtrip
			var v float32
			switch n := val.(type) {
			case int:
				v = float32(n)
			case int32:
				v = float32(n)
			case int64:
				v = float32(n)
			case float32:
				v = n
			case float64:
				v = float32(n)
			}
			result.Temperature = &v
		}
		if val, ok := m["topK"]; ok && val != nil { // Handle various numeric types from JSON/YAML/roundtrip
			var v int32
			switch n := val.(type) {
			case int:
				v = int32(n)
			case int32:
				v = int32(n)
			case int64:
				v = int32(n)
			case float64:
				v = int32(n)
			}
			result.TopK = &v
		}
		if val, ok := m["topP"]; ok && val != nil { // Handle various numeric types from JSON/YAML/roundtrip
			var v float32
			switch n := val.(type) {
			case int:
				v = float32(n)
			case int32:
				v = float32(n)
			case int64:
				v = float32(n)
			case float32:
				v = n
			case float64:
				v = float32(n)
			}
			result.TopP = &v
		}
		if val, ok := m["stopSequences"]; ok && val != nil {
			if arr, ok := val.([]interface{}); ok {
				result.StopSequences = make([]string, len(arr))
				for i, v := range arr {
					result.StopSequences[i] = v.(string)
				}
			}
		}
		if val, ok := m["allowMultipleToolCalls"]; ok && val != nil {
			v := val.(bool)
			result.AllowMultipleToolCalls = &v
		}
		if val, ok := m["additionalProperties"]; ok && val != nil {
			if m, ok := val.(map[string]interface{}); ok {
				result.AdditionalProperties = m
			}
		}
	}

	return result, nil
}

// Save serializes ModelOptions to map[string]interface{}
func (obj *ModelOptions) Save(ctx *SaveContext) map[string]interface{} {
	result := make(map[string]interface{})
	if obj.FrequencyPenalty != nil {
		result["frequencyPenalty"] = *obj.FrequencyPenalty
	}
	if obj.MaxOutputTokens != nil {
		result["maxOutputTokens"] = *obj.MaxOutputTokens
	}
	if obj.PresencePenalty != nil {
		result["presencePenalty"] = *obj.PresencePenalty
	}
	if obj.Seed != nil {
		result["seed"] = *obj.Seed
	}
	if obj.Temperature != nil {
		result["temperature"] = *obj.Temperature
	}
	if obj.TopK != nil {
		result["topK"] = *obj.TopK
	}
	if obj.TopP != nil {
		result["topP"] = *obj.TopP
	}
	result["stopSequences"] = obj.StopSequences
	if obj.AllowMultipleToolCalls != nil {
		result["allowMultipleToolCalls"] = *obj.AllowMultipleToolCalls
	}
	if obj.AdditionalProperties != nil {
		result["additionalProperties"] = obj.AdditionalProperties
	}

	return result
}

// ToJSON serializes ModelOptions to JSON string
func (obj *ModelOptions) ToJSON() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := json.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// ToYAML serializes ModelOptions to YAML string
func (obj *ModelOptions) ToYAML() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := yaml.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// FromJSON creates ModelOptions from JSON string
func ModelOptionsFromJSON(jsonStr string) (ModelOptions, error) {
	var data map[string]interface{}
	if err := json.Unmarshal([]byte(jsonStr), &data); err != nil {
		return ModelOptions{}, err
	}
	ctx := NewLoadContext()
	return LoadModelOptions(data, ctx)
}

// FromYAML creates ModelOptions from YAML string
func ModelOptionsFromYAML(yamlStr string) (ModelOptions, error) {
	var data map[string]interface{}
	if err := yaml.Unmarshal([]byte(yamlStr), &data); err != nil {
		return ModelOptions{}, err
	}
	ctx := NewLoadContext()
	return LoadModelOptions(data, ctx)
}
