

// Code generated by AgentSchema emitter; DO NOT EDIT.

package agentschema

import (
	"encoding/json"
	"fmt"
	
	"gopkg.in/yaml.v3"
)


// ModelOptions represents Options for configuring the behavior of the AI model.
`kind` is a required property here, but this section can accept additional via options.
type ModelOptions struct {
	Frequencypenalty *float32 `json:"frequencyPenalty,omitempty" yaml:"frequencyPenalty,omitempty"`
	Maxoutputtokens *int32 `json:"maxOutputTokens,omitempty" yaml:"maxOutputTokens,omitempty"`
	Presencepenalty *float32 `json:"presencePenalty,omitempty" yaml:"presencePenalty,omitempty"`
	Seed *int32 `json:"seed,omitempty" yaml:"seed,omitempty"`
	Temperature *float32 `json:"temperature,omitempty" yaml:"temperature,omitempty"`
	Topk *int32 `json:"topK,omitempty" yaml:"topK,omitempty"`
	Topp *float32 `json:"topP,omitempty" yaml:"topP,omitempty"`
	Stopsequences []string `json:"stopSequences,omitempty" yaml:"stopSequences,omitempty"`
	Allowmultipletoolcalls *bool `json:"allowMultipleToolCalls,omitempty" yaml:"allowMultipleToolCalls,omitempty"`
	Additionalproperties map[string]interface{} `json:"additionalProperties,omitempty" yaml:"additionalProperties,omitempty"`
}

// LoadModelOptions creates a ModelOptions from a map[string]interface{}
func LoadModelOptions(data interface{}, ctx *LoadContext) (ModelOptions, error) {
	result := ModelOptions{}
	
	// Load from map
	if m, ok := data.(map[string]interface{}); ok {
		if val, ok := m["frequencyPenalty"]; ok && val != nil {v := val.(float32)
			result.Frequencypenalty = &v}
		if val, ok := m["maxOutputTokens"]; ok && val != nil {v := val.(int32)
			result.Maxoutputtokens = &v}
		if val, ok := m["presencePenalty"]; ok && val != nil {v := val.(float32)
			result.Presencepenalty = &v}
		if val, ok := m["seed"]; ok && val != nil {v := val.(int32)
			result.Seed = &v}
		if val, ok := m["temperature"]; ok && val != nil {v := val.(float32)
			result.Temperature = &v}
		if val, ok := m["topK"]; ok && val != nil {v := val.(int32)
			result.Topk = &v}
		if val, ok := m["topP"]; ok && val != nil {v := val.(float32)
			result.Topp = &v}
		if val, ok := m["stopSequences"]; ok && val != nil {
			if arr, ok := val.([]interface{}); ok {
				result.Stopsequences = make([]string, len(arr))
				for i, v := range arr {
					result.Stopsequences[i] = v.(string)
				}
			}
		}
		if val, ok := m["allowMultipleToolCalls"]; ok && val != nil {v := val.(bool)
			result.Allowmultipletoolcalls = &v}
		if val, ok := m["additionalProperties"]; ok && val != nil {
			if m, ok := val.(map[string]interface{}); ok {
				result.Additionalproperties = m
			}
		}
	}
	
	return result, nil
}

// Save serializes ModelOptions to map[string]interface{}
func (obj *ModelOptions) Save(ctx *SaveContext) map[string]interface{} {
	result := make(map[string]interface{})
	if obj.Frequencypenalty != nil {result["frequencyPenalty"] = *obj.Frequencypenalty}
	if obj.Maxoutputtokens != nil {result["maxOutputTokens"] = *obj.Maxoutputtokens}
	if obj.Presencepenalty != nil {result["presencePenalty"] = *obj.Presencepenalty}
	if obj.Seed != nil {result["seed"] = *obj.Seed}
	if obj.Temperature != nil {result["temperature"] = *obj.Temperature}
	if obj.Topk != nil {result["topK"] = *obj.Topk}
	if obj.Topp != nil {result["topP"] = *obj.Topp}
	result["stopSequences"] = obj.Stopsequences
	if obj.Allowmultipletoolcalls != nil {result["allowMultipleToolCalls"] = *obj.Allowmultipletoolcalls}
	if obj.Additionalproperties != nil {
		result["additionalProperties"] = obj.Additionalproperties
	}
	
	return result
}

// ToJSON serializes ModelOptions to JSON string
func (obj *ModelOptions) ToJSON() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := json.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// ToYAML serializes ModelOptions to YAML string
func (obj *ModelOptions) ToYAML() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := yaml.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// FromJSON creates ModelOptions from JSON string
func ModelOptionsFromJSON(jsonStr string) (ModelOptions, error) {
	var data map[string]interface{}
	if err := json.Unmarshal([]byte(jsonStr), &data); err != nil {
		return ModelOptions{}, err
	}
	ctx := NewLoadContext()
	return LoadModelOptions(data, ctx)
}

// FromYAML creates ModelOptions from YAML string
func ModelOptionsFromYAML(yamlStr string) (ModelOptions, error) {
	var data map[string]interface{}
	if err := yaml.Unmarshal([]byte(yamlStr), &data); err != nil {
		return ModelOptions{}, err
	}
	ctx := NewLoadContext()
	return LoadModelOptions(data, ctx)
}


