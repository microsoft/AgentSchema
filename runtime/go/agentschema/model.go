// Code generated by AgentSchema emitter; DO NOT EDIT.

package agentschema

import (
	"encoding/json"
	"fmt"

	"gopkg.in/yaml.v3"
)

// Model represents Model for defining the structure and behavior of AI agents.
// This model includes properties for specifying the model's provider, connection details, and various options.
// It allows for flexible configuration of AI models to suit different use cases and requirements.

type Model struct {
	Id         string        `json:"id" yaml:"id"`
	Provider   *string       `json:"provider,omitempty" yaml:"provider,omitempty"`
	Apitype    *string       `json:"apiType,omitempty" yaml:"apiType,omitempty"`
	Connection *Connection   `json:"connection,omitempty" yaml:"connection,omitempty"`
	Options    *ModelOptions `json:"options,omitempty" yaml:"options,omitempty"`
}

// LoadModel creates a Model from a map[string]interface{}
func LoadModel(data interface{}, ctx *LoadContext) (Model, error) {
	result := Model{}

	// Handle alternate scalar representations
	switch v := data.(type) {
	case string:
		// Shorthand: string -> Model
		expansion := map[string]interface{}{"id": data}
		return LoadModel(expansion, ctx)
	}
	// Load from map
	if m, ok := data.(map[string]interface{}); ok {
		if val, ok := m["id"]; ok && val != nil {
			result.Id = val.(string)
		}
		if val, ok := m["provider"]; ok && val != nil {
			v := val.(string)
			result.Provider = &v
		}
		if val, ok := m["apiType"]; ok && val != nil {
			v := val.(string)
			result.Apitype = &v
		}
		if val, ok := m["connection"]; ok && val != nil {
			if m, ok := val.(map[string]interface{}); ok {
				loaded, _ := LoadConnection(m, ctx)
				result.Connection = &loaded
			}
		}
		if val, ok := m["options"]; ok && val != nil {
			if m, ok := val.(map[string]interface{}); ok {
				loaded, _ := LoadModelOptions(m, ctx)
				result.Options = &loaded
			}
		}
	}

	return result, nil
}

// Save serializes Model to map[string]interface{}
func (obj *Model) Save(ctx *SaveContext) map[string]interface{} {
	result := make(map[string]interface{})
	result["id"] = obj.Id
	if obj.Provider != nil {
		result["provider"] = *obj.Provider
	}
	if obj.Apitype != nil {
		result["apiType"] = *obj.Apitype
	}
	if obj.Connection != nil {
		result["connection"] = obj.Connection.Save(ctx)
	}
	if obj.Options != nil {
		result["options"] = obj.Options.Save(ctx)
	}

	return result
}

// ToJSON serializes Model to JSON string
func (obj *Model) ToJSON() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := json.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// ToYAML serializes Model to YAML string
func (obj *Model) ToYAML() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := yaml.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// FromJSON creates Model from JSON string
func ModelFromJSON(jsonStr string) (Model, error) {
	var data map[string]interface{}
	if err := json.Unmarshal([]byte(jsonStr), &data); err != nil {
		return Model{}, err
	}
	ctx := NewLoadContext()
	return LoadModel(data, ctx)
}

// FromYAML creates Model from YAML string
func ModelFromYAML(yamlStr string) (Model, error) {
	var data map[string]interface{}
	if err := yaml.Unmarshal([]byte(yamlStr), &data); err != nil {
		return Model{}, err
	}
	ctx := NewLoadContext()
	return LoadModel(data, ctx)
}
