// Code generated by AgentSchema emitter; DO NOT EDIT.

package agentschema

import (
	"encoding/json"

	"gopkg.in/yaml.v3"
)

// Tool represents Represents a tool that can be used in prompts.

type Tool struct {
	Name        string    `json:"name" yaml:"name"`
	Kind        string    `json:"kind" yaml:"kind"`
	Description *string   `json:"description,omitempty" yaml:"description,omitempty"`
	Bindings    []Binding `json:"bindings,omitempty" yaml:"bindings,omitempty"`
}

// LoadTool creates a Tool from a map[string]interface{}
// Returns interface{} because this is a polymorphic base type that can resolve to different child types
func LoadTool(data interface{}, ctx *LoadContext) (interface{}, error) {
	result := Tool{}

	// Handle polymorphic types based on discriminator
	if m, ok := data.(map[string]interface{}); ok {
		if discriminator, ok := m["kind"]; ok {
			switch discriminator {
			case "function":
				return LoadFunctionTool(data, ctx)
			case "bing_search":
				return LoadWebSearchTool(data, ctx)
			case "file_search":
				return LoadFileSearchTool(data, ctx)
			case "mcp":
				return LoadMcpTool(data, ctx)
			case "openapi":
				return LoadOpenApiTool(data, ctx)
			case "code_interpreter":
				return LoadCodeInterpreterTool(data, ctx)
			default:
				return LoadCustomTool(data, ctx)
			}
		}
	}
	// Load from map
	if m, ok := data.(map[string]interface{}); ok {
		if val, ok := m["name"]; ok && val != nil {
			result.Name = val.(string)
		}
		if val, ok := m["kind"]; ok && val != nil {
			result.Kind = val.(string)
		}
		if val, ok := m["description"]; ok && val != nil {
			v := val.(string)
			result.Description = &v
		}
		if val, ok := m["bindings"]; ok && val != nil {
			if arr, ok := val.([]interface{}); ok {
				result.Bindings = make([]Binding, len(arr))
				for i, v := range arr {
					if item, ok := v.(map[string]interface{}); ok {
						loaded, _ := LoadBinding(item, ctx)
						result.Bindings[i] = loaded
					}
				}
			}
		}
	}

	return result, nil
}

// Save serializes Tool to map[string]interface{}
func (obj *Tool) Save(ctx *SaveContext) map[string]interface{} {
	result := make(map[string]interface{})
	result["name"] = obj.Name
	result["kind"] = obj.Kind
	if obj.Description != nil {
		result["description"] = *obj.Description
	}
	if obj.Bindings != nil {
		arr := make([]interface{}, len(obj.Bindings))
		for i, item := range obj.Bindings {
			arr[i] = item.Save(ctx)
		}
		result["bindings"] = arr
	}

	return result
}

// ToJSON serializes Tool to JSON string
func (obj *Tool) ToJSON() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := json.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// ToYAML serializes Tool to YAML string
func (obj *Tool) ToYAML() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := yaml.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// FromJSON creates Tool from JSON string
// Returns interface{} because this is a polymorphic base type that can resolve to different child types
func ToolFromJSON(jsonStr string) (interface{}, error) {
	var data map[string]interface{}
	if err := json.Unmarshal([]byte(jsonStr), &data); err != nil {
		return nil, err
	}
	ctx := NewLoadContext()
	return LoadTool(data, ctx)
}

// FromYAML creates Tool from YAML string
// Returns interface{} because this is a polymorphic base type that can resolve to different child types
func ToolFromYAML(yamlStr string) (interface{}, error) {
	var data map[string]interface{}
	if err := yaml.Unmarshal([]byte(yamlStr), &data); err != nil {
		return nil, err
	}
	ctx := NewLoadContext()
	return LoadTool(data, ctx)
}

// FunctionTool represents Represents a local function tool.

type FunctionTool struct {
	Kind       string         `json:"kind" yaml:"kind"`
	Parameters PropertySchema `json:"parameters" yaml:"parameters"`
	Strict     *bool          `json:"strict,omitempty" yaml:"strict,omitempty"`
}

// LoadFunctionTool creates a FunctionTool from a map[string]interface{}
func LoadFunctionTool(data interface{}, ctx *LoadContext) (FunctionTool, error) {
	result := FunctionTool{}

	// Load from map
	if m, ok := data.(map[string]interface{}); ok {
		if val, ok := m["kind"]; ok && val != nil {
			result.Kind = val.(string)
		}
		if val, ok := m["parameters"]; ok && val != nil {
			if m, ok := val.(map[string]interface{}); ok {
				loaded, _ := LoadPropertySchema(m, ctx)
				result.Parameters = loaded
			}
		}
		if val, ok := m["strict"]; ok && val != nil {
			v := val.(bool)
			result.Strict = &v
		}
	}

	return result, nil
}

// Save serializes FunctionTool to map[string]interface{}
func (obj *FunctionTool) Save(ctx *SaveContext) map[string]interface{} {
	result := make(map[string]interface{})
	result["kind"] = obj.Kind
	result["parameters"] = obj.Parameters.Save(ctx)
	if obj.Strict != nil {
		result["strict"] = *obj.Strict
	}

	return result
}

// ToJSON serializes FunctionTool to JSON string
func (obj *FunctionTool) ToJSON() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := json.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// ToYAML serializes FunctionTool to YAML string
func (obj *FunctionTool) ToYAML() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := yaml.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// FromJSON creates FunctionTool from JSON string
func FunctionToolFromJSON(jsonStr string) (FunctionTool, error) {
	var data map[string]interface{}
	if err := json.Unmarshal([]byte(jsonStr), &data); err != nil {
		return FunctionTool{}, err
	}
	ctx := NewLoadContext()
	return LoadFunctionTool(data, ctx)
}

// FromYAML creates FunctionTool from YAML string
func FunctionToolFromYAML(yamlStr string) (FunctionTool, error) {
	var data map[string]interface{}
	if err := yaml.Unmarshal([]byte(yamlStr), &data); err != nil {
		return FunctionTool{}, err
	}
	ctx := NewLoadContext()
	return LoadFunctionTool(data, ctx)
}

// CustomTool represents Represents a generic server tool that runs on a server
// This tool kind is designed for operations that require server-side execution
// It may include features such as authentication, data storage, and long-running processes
// This tool kind is ideal for tasks that involve complex computations or access to secure resources
// Server tools can be used to offload heavy processing from client applications

type CustomTool struct {
	Kind       string                 `json:"kind" yaml:"kind"`
	Connection Connection             `json:"connection" yaml:"connection"`
	Options    map[string]interface{} `json:"options" yaml:"options"`
}

// LoadCustomTool creates a CustomTool from a map[string]interface{}
func LoadCustomTool(data interface{}, ctx *LoadContext) (CustomTool, error) {
	result := CustomTool{}

	// Load from map
	if m, ok := data.(map[string]interface{}); ok {
		if val, ok := m["kind"]; ok && val != nil {
			result.Kind = val.(string)
		}
		if val, ok := m["connection"]; ok && val != nil {
			if m, ok := val.(map[string]interface{}); ok {
				loaded, _ := LoadConnection(m, ctx)
				// Type assert from interface{} in case Load returns interface{} for polymorphic types
				result.Connection = loaded.(Connection)
			}
		}
		if val, ok := m["options"]; ok && val != nil {
			if m, ok := val.(map[string]interface{}); ok {
				result.Options = m
			}
		}
	}

	return result, nil
}

// Save serializes CustomTool to map[string]interface{}
func (obj *CustomTool) Save(ctx *SaveContext) map[string]interface{} {
	result := make(map[string]interface{})
	result["kind"] = obj.Kind
	result["connection"] = obj.Connection.Save(ctx)
	result["options"] = obj.Options

	return result
}

// ToJSON serializes CustomTool to JSON string
func (obj *CustomTool) ToJSON() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := json.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// ToYAML serializes CustomTool to YAML string
func (obj *CustomTool) ToYAML() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := yaml.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// FromJSON creates CustomTool from JSON string
func CustomToolFromJSON(jsonStr string) (CustomTool, error) {
	var data map[string]interface{}
	if err := json.Unmarshal([]byte(jsonStr), &data); err != nil {
		return CustomTool{}, err
	}
	ctx := NewLoadContext()
	return LoadCustomTool(data, ctx)
}

// FromYAML creates CustomTool from YAML string
func CustomToolFromYAML(yamlStr string) (CustomTool, error) {
	var data map[string]interface{}
	if err := yaml.Unmarshal([]byte(yamlStr), &data); err != nil {
		return CustomTool{}, err
	}
	ctx := NewLoadContext()
	return LoadCustomTool(data, ctx)
}

// WebSearchTool represents The Bing search tool.

type WebSearchTool struct {
	Kind       string                 `json:"kind" yaml:"kind"`
	Connection Connection             `json:"connection" yaml:"connection"`
	Options    map[string]interface{} `json:"options,omitempty" yaml:"options,omitempty"`
}

// LoadWebSearchTool creates a WebSearchTool from a map[string]interface{}
func LoadWebSearchTool(data interface{}, ctx *LoadContext) (WebSearchTool, error) {
	result := WebSearchTool{}

	// Load from map
	if m, ok := data.(map[string]interface{}); ok {
		if val, ok := m["kind"]; ok && val != nil {
			result.Kind = val.(string)
		}
		if val, ok := m["connection"]; ok && val != nil {
			if m, ok := val.(map[string]interface{}); ok {
				loaded, _ := LoadConnection(m, ctx)
				// Type assert from interface{} in case Load returns interface{} for polymorphic types
				result.Connection = loaded.(Connection)
			}
		}
		if val, ok := m["options"]; ok && val != nil {
			if m, ok := val.(map[string]interface{}); ok {
				result.Options = m
			}
		}
	}

	return result, nil
}

// Save serializes WebSearchTool to map[string]interface{}
func (obj *WebSearchTool) Save(ctx *SaveContext) map[string]interface{} {
	result := make(map[string]interface{})
	result["kind"] = obj.Kind
	result["connection"] = obj.Connection.Save(ctx)
	if obj.Options != nil {
		result["options"] = obj.Options
	}

	return result
}

// ToJSON serializes WebSearchTool to JSON string
func (obj *WebSearchTool) ToJSON() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := json.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// ToYAML serializes WebSearchTool to YAML string
func (obj *WebSearchTool) ToYAML() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := yaml.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// FromJSON creates WebSearchTool from JSON string
func WebSearchToolFromJSON(jsonStr string) (WebSearchTool, error) {
	var data map[string]interface{}
	if err := json.Unmarshal([]byte(jsonStr), &data); err != nil {
		return WebSearchTool{}, err
	}
	ctx := NewLoadContext()
	return LoadWebSearchTool(data, ctx)
}

// FromYAML creates WebSearchTool from YAML string
func WebSearchToolFromYAML(yamlStr string) (WebSearchTool, error) {
	var data map[string]interface{}
	if err := yaml.Unmarshal([]byte(yamlStr), &data); err != nil {
		return WebSearchTool{}, err
	}
	ctx := NewLoadContext()
	return LoadWebSearchTool(data, ctx)
}

// FileSearchTool represents A tool for searching files.
// This tool allows an AI agent to search for files based on a query.

type FileSearchTool struct {
	Kind               string                 `json:"kind" yaml:"kind"`
	Connection         Connection             `json:"connection" yaml:"connection"`
	VectorStoreIds     []string               `json:"vectorStoreIds" yaml:"vectorStoreIds"`
	MaximumResultCount *int32                 `json:"maximumResultCount,omitempty" yaml:"maximumResultCount,omitempty"`
	Ranker             *string                `json:"ranker,omitempty" yaml:"ranker,omitempty"`
	ScoreThreshold     *float32               `json:"scoreThreshold,omitempty" yaml:"scoreThreshold,omitempty"`
	Filters            map[string]interface{} `json:"filters,omitempty" yaml:"filters,omitempty"`
}

// LoadFileSearchTool creates a FileSearchTool from a map[string]interface{}
func LoadFileSearchTool(data interface{}, ctx *LoadContext) (FileSearchTool, error) {
	result := FileSearchTool{}

	// Load from map
	if m, ok := data.(map[string]interface{}); ok {
		if val, ok := m["kind"]; ok && val != nil {
			result.Kind = val.(string)
		}
		if val, ok := m["connection"]; ok && val != nil {
			if m, ok := val.(map[string]interface{}); ok {
				loaded, _ := LoadConnection(m, ctx)
				// Type assert from interface{} in case Load returns interface{} for polymorphic types
				result.Connection = loaded.(Connection)
			}
		}
		if val, ok := m["vectorStoreIds"]; ok && val != nil {
			if arr, ok := val.([]interface{}); ok {
				result.VectorStoreIds = make([]string, len(arr))
				for i, v := range arr {
					result.VectorStoreIds[i] = v.(string)
				}
			}
		}
		if val, ok := m["maximumResultCount"]; ok && val != nil {
			v := val.(int32)
			result.MaximumResultCount = &v
		}
		if val, ok := m["ranker"]; ok && val != nil {
			v := val.(string)
			result.Ranker = &v
		}
		if val, ok := m["scoreThreshold"]; ok && val != nil {
			v := val.(float32)
			result.ScoreThreshold = &v
		}
		if val, ok := m["filters"]; ok && val != nil {
			if m, ok := val.(map[string]interface{}); ok {
				result.Filters = m
			}
		}
	}

	return result, nil
}

// Save serializes FileSearchTool to map[string]interface{}
func (obj *FileSearchTool) Save(ctx *SaveContext) map[string]interface{} {
	result := make(map[string]interface{})
	result["kind"] = obj.Kind
	result["connection"] = obj.Connection.Save(ctx)
	result["vectorStoreIds"] = obj.VectorStoreIds
	if obj.MaximumResultCount != nil {
		result["maximumResultCount"] = *obj.MaximumResultCount
	}
	if obj.Ranker != nil {
		result["ranker"] = *obj.Ranker
	}
	if obj.ScoreThreshold != nil {
		result["scoreThreshold"] = *obj.ScoreThreshold
	}
	if obj.Filters != nil {
		result["filters"] = obj.Filters
	}

	return result
}

// ToJSON serializes FileSearchTool to JSON string
func (obj *FileSearchTool) ToJSON() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := json.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// ToYAML serializes FileSearchTool to YAML string
func (obj *FileSearchTool) ToYAML() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := yaml.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// FromJSON creates FileSearchTool from JSON string
func FileSearchToolFromJSON(jsonStr string) (FileSearchTool, error) {
	var data map[string]interface{}
	if err := json.Unmarshal([]byte(jsonStr), &data); err != nil {
		return FileSearchTool{}, err
	}
	ctx := NewLoadContext()
	return LoadFileSearchTool(data, ctx)
}

// FromYAML creates FileSearchTool from YAML string
func FileSearchToolFromYAML(yamlStr string) (FileSearchTool, error) {
	var data map[string]interface{}
	if err := yaml.Unmarshal([]byte(yamlStr), &data); err != nil {
		return FileSearchTool{}, err
	}
	ctx := NewLoadContext()
	return LoadFileSearchTool(data, ctx)
}

// McpTool represents The MCP Server tool.

type McpTool struct {
	Kind              string                `json:"kind" yaml:"kind"`
	Connection        Connection            `json:"connection" yaml:"connection"`
	ServerName        string                `json:"serverName" yaml:"serverName"`
	ServerDescription *string               `json:"serverDescription,omitempty" yaml:"serverDescription,omitempty"`
	ApprovalMode      McpServerApprovalMode `json:"approvalMode" yaml:"approvalMode"`
	AllowedTools      []string              `json:"allowedTools,omitempty" yaml:"allowedTools,omitempty"`
}

// LoadMcpTool creates a McpTool from a map[string]interface{}
func LoadMcpTool(data interface{}, ctx *LoadContext) (McpTool, error) {
	result := McpTool{}

	// Load from map
	if m, ok := data.(map[string]interface{}); ok {
		if val, ok := m["kind"]; ok && val != nil {
			result.Kind = val.(string)
		}
		if val, ok := m["connection"]; ok && val != nil {
			if m, ok := val.(map[string]interface{}); ok {
				loaded, _ := LoadConnection(m, ctx)
				// Type assert from interface{} in case Load returns interface{} for polymorphic types
				result.Connection = loaded.(Connection)
			}
		}
		if val, ok := m["serverName"]; ok && val != nil {
			result.ServerName = val.(string)
		}
		if val, ok := m["serverDescription"]; ok && val != nil {
			v := val.(string)
			result.ServerDescription = &v
		}
		if val, ok := m["approvalMode"]; ok && val != nil {
			if m, ok := val.(map[string]interface{}); ok {
				loaded, _ := LoadMcpServerApprovalMode(m, ctx)
				// Type assert from interface{} in case Load returns interface{} for polymorphic types
				result.ApprovalMode = loaded.(McpServerApprovalMode)
			}
		}
		if val, ok := m["allowedTools"]; ok && val != nil {
			if arr, ok := val.([]interface{}); ok {
				result.AllowedTools = make([]string, len(arr))
				for i, v := range arr {
					result.AllowedTools[i] = v.(string)
				}
			}
		}
	}

	return result, nil
}

// Save serializes McpTool to map[string]interface{}
func (obj *McpTool) Save(ctx *SaveContext) map[string]interface{} {
	result := make(map[string]interface{})
	result["kind"] = obj.Kind
	result["connection"] = obj.Connection.Save(ctx)
	result["serverName"] = obj.ServerName
	if obj.ServerDescription != nil {
		result["serverDescription"] = *obj.ServerDescription
	}
	result["approvalMode"] = obj.ApprovalMode.Save(ctx)
	result["allowedTools"] = obj.AllowedTools

	return result
}

// ToJSON serializes McpTool to JSON string
func (obj *McpTool) ToJSON() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := json.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// ToYAML serializes McpTool to YAML string
func (obj *McpTool) ToYAML() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := yaml.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// FromJSON creates McpTool from JSON string
func McpToolFromJSON(jsonStr string) (McpTool, error) {
	var data map[string]interface{}
	if err := json.Unmarshal([]byte(jsonStr), &data); err != nil {
		return McpTool{}, err
	}
	ctx := NewLoadContext()
	return LoadMcpTool(data, ctx)
}

// FromYAML creates McpTool from YAML string
func McpToolFromYAML(yamlStr string) (McpTool, error) {
	var data map[string]interface{}
	if err := yaml.Unmarshal([]byte(yamlStr), &data); err != nil {
		return McpTool{}, err
	}
	ctx := NewLoadContext()
	return LoadMcpTool(data, ctx)
}

// OpenApiTool represents a schema type
type OpenApiTool struct {
	Kind          string     `json:"kind" yaml:"kind"`
	Connection    Connection `json:"connection" yaml:"connection"`
	Specification string     `json:"specification" yaml:"specification"`
}

// LoadOpenApiTool creates a OpenApiTool from a map[string]interface{}
func LoadOpenApiTool(data interface{}, ctx *LoadContext) (OpenApiTool, error) {
	result := OpenApiTool{}

	// Load from map
	if m, ok := data.(map[string]interface{}); ok {
		if val, ok := m["kind"]; ok && val != nil {
			result.Kind = val.(string)
		}
		if val, ok := m["connection"]; ok && val != nil {
			if m, ok := val.(map[string]interface{}); ok {
				loaded, _ := LoadConnection(m, ctx)
				// Type assert from interface{} in case Load returns interface{} for polymorphic types
				result.Connection = loaded.(Connection)
			}
		}
		if val, ok := m["specification"]; ok && val != nil {
			result.Specification = val.(string)
		}
	}

	return result, nil
}

// Save serializes OpenApiTool to map[string]interface{}
func (obj *OpenApiTool) Save(ctx *SaveContext) map[string]interface{} {
	result := make(map[string]interface{})
	result["kind"] = obj.Kind
	result["connection"] = obj.Connection.Save(ctx)
	result["specification"] = obj.Specification

	return result
}

// ToJSON serializes OpenApiTool to JSON string
func (obj *OpenApiTool) ToJSON() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := json.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// ToYAML serializes OpenApiTool to YAML string
func (obj *OpenApiTool) ToYAML() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := yaml.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// FromJSON creates OpenApiTool from JSON string
func OpenApiToolFromJSON(jsonStr string) (OpenApiTool, error) {
	var data map[string]interface{}
	if err := json.Unmarshal([]byte(jsonStr), &data); err != nil {
		return OpenApiTool{}, err
	}
	ctx := NewLoadContext()
	return LoadOpenApiTool(data, ctx)
}

// FromYAML creates OpenApiTool from YAML string
func OpenApiToolFromYAML(yamlStr string) (OpenApiTool, error) {
	var data map[string]interface{}
	if err := yaml.Unmarshal([]byte(yamlStr), &data); err != nil {
		return OpenApiTool{}, err
	}
	ctx := NewLoadContext()
	return LoadOpenApiTool(data, ctx)
}

// CodeInterpreterTool represents A tool for interpreting and executing code.
// This tool allows an AI agent to run code snippets and analyze data files.

type CodeInterpreterTool struct {
	Kind    string   `json:"kind" yaml:"kind"`
	FileIds []string `json:"fileIds" yaml:"fileIds"`
}

// LoadCodeInterpreterTool creates a CodeInterpreterTool from a map[string]interface{}
func LoadCodeInterpreterTool(data interface{}, ctx *LoadContext) (CodeInterpreterTool, error) {
	result := CodeInterpreterTool{}

	// Load from map
	if m, ok := data.(map[string]interface{}); ok {
		if val, ok := m["kind"]; ok && val != nil {
			result.Kind = val.(string)
		}
		if val, ok := m["fileIds"]; ok && val != nil {
			if arr, ok := val.([]interface{}); ok {
				result.FileIds = make([]string, len(arr))
				for i, v := range arr {
					result.FileIds[i] = v.(string)
				}
			}
		}
	}

	return result, nil
}

// Save serializes CodeInterpreterTool to map[string]interface{}
func (obj *CodeInterpreterTool) Save(ctx *SaveContext) map[string]interface{} {
	result := make(map[string]interface{})
	result["kind"] = obj.Kind
	result["fileIds"] = obj.FileIds

	return result
}

// ToJSON serializes CodeInterpreterTool to JSON string
func (obj *CodeInterpreterTool) ToJSON() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := json.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// ToYAML serializes CodeInterpreterTool to YAML string
func (obj *CodeInterpreterTool) ToYAML() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := yaml.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// FromJSON creates CodeInterpreterTool from JSON string
func CodeInterpreterToolFromJSON(jsonStr string) (CodeInterpreterTool, error) {
	var data map[string]interface{}
	if err := json.Unmarshal([]byte(jsonStr), &data); err != nil {
		return CodeInterpreterTool{}, err
	}
	ctx := NewLoadContext()
	return LoadCodeInterpreterTool(data, ctx)
}

// FromYAML creates CodeInterpreterTool from YAML string
func CodeInterpreterToolFromYAML(yamlStr string) (CodeInterpreterTool, error) {
	var data map[string]interface{}
	if err := yaml.Unmarshal([]byte(yamlStr), &data); err != nil {
		return CodeInterpreterTool{}, err
	}
	ctx := NewLoadContext()
	return LoadCodeInterpreterTool(data, ctx)
}
