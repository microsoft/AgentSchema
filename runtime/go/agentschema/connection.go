// Code generated by AgentSchema emitter; DO NOT EDIT.

package agentschema

import (
	"encoding/json"
	"fmt"

	"gopkg.in/yaml.v3"
)

// Connection represents Connection configuration for AI agents.
// `provider`, `kind`, and `endpoint` are required properties here,
// but this section can accept additional via options.

type Connection struct {
	Kind               string  `json:"kind" yaml:"kind"`
	Authenticationmode string  `json:"authenticationMode" yaml:"authenticationMode"`
	Usagedescription   *string `json:"usageDescription,omitempty" yaml:"usageDescription,omitempty"`
}

// LoadConnection creates a Connection from a map[string]interface{}
func LoadConnection(data interface{}, ctx *LoadContext) (Connection, error) {
	result := Connection{}

	// Handle polymorphic types based on discriminator
	if m, ok := data.(map[string]interface{}); ok {
		if discriminator, ok := m["kind"]; ok {
			switch discriminator {
			case "reference":
				return LoadReferenceConnection(data, ctx)
			case "remote":
				return LoadRemoteConnection(data, ctx)
			case "key":
				return LoadApiKeyConnection(data, ctx)
			case "anonymous":
				return LoadAnonymousConnection(data, ctx)
			}
		}
	}
	// Load from map
	if m, ok := data.(map[string]interface{}); ok {
		if val, ok := m["kind"]; ok && val != nil {
			result.Kind = val.(string)
		}
		if val, ok := m["authenticationMode"]; ok && val != nil {
			result.Authenticationmode = val.(string)
		}
		if val, ok := m["usageDescription"]; ok && val != nil {
			v := val.(string)
			result.Usagedescription = &v
		}
	}

	return result, nil
}

// Save serializes Connection to map[string]interface{}
func (obj *Connection) Save(ctx *SaveContext) map[string]interface{} {
	result := make(map[string]interface{})
	result["kind"] = obj.Kind
	result["authenticationMode"] = obj.Authenticationmode
	if obj.Usagedescription != nil {
		result["usageDescription"] = *obj.Usagedescription
	}

	return result
}

// ToJSON serializes Connection to JSON string
func (obj *Connection) ToJSON() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := json.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// ToYAML serializes Connection to YAML string
func (obj *Connection) ToYAML() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := yaml.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// FromJSON creates Connection from JSON string
func ConnectionFromJSON(jsonStr string) (Connection, error) {
	var data map[string]interface{}
	if err := json.Unmarshal([]byte(jsonStr), &data); err != nil {
		return Connection{}, err
	}
	ctx := NewLoadContext()
	return LoadConnection(data, ctx)
}

// FromYAML creates Connection from YAML string
func ConnectionFromYAML(yamlStr string) (Connection, error) {
	var data map[string]interface{}
	if err := yaml.Unmarshal([]byte(yamlStr), &data); err != nil {
		return Connection{}, err
	}
	ctx := NewLoadContext()
	return LoadConnection(data, ctx)
}

// ReferenceConnection represents Connection configuration for AI services using named connections.

type ReferenceConnection struct {
	Kind   string  `json:"kind" yaml:"kind"`
	Name   string  `json:"name" yaml:"name"`
	Target *string `json:"target,omitempty" yaml:"target,omitempty"`
}

// LoadReferenceConnection creates a ReferenceConnection from a map[string]interface{}
func LoadReferenceConnection(data interface{}, ctx *LoadContext) (ReferenceConnection, error) {
	result := ReferenceConnection{}

	// Load from map
	if m, ok := data.(map[string]interface{}); ok {
		if val, ok := m["kind"]; ok && val != nil {
			result.Kind = val.(string)
		}
		if val, ok := m["name"]; ok && val != nil {
			result.Name = val.(string)
		}
		if val, ok := m["target"]; ok && val != nil {
			v := val.(string)
			result.Target = &v
		}
	}

	return result, nil
}

// Save serializes ReferenceConnection to map[string]interface{}
func (obj *ReferenceConnection) Save(ctx *SaveContext) map[string]interface{} {
	result := make(map[string]interface{})
	result["kind"] = obj.Kind
	result["name"] = obj.Name
	if obj.Target != nil {
		result["target"] = *obj.Target
	}

	return result
}

// ToJSON serializes ReferenceConnection to JSON string
func (obj *ReferenceConnection) ToJSON() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := json.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// ToYAML serializes ReferenceConnection to YAML string
func (obj *ReferenceConnection) ToYAML() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := yaml.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// FromJSON creates ReferenceConnection from JSON string
func ReferenceConnectionFromJSON(jsonStr string) (ReferenceConnection, error) {
	var data map[string]interface{}
	if err := json.Unmarshal([]byte(jsonStr), &data); err != nil {
		return ReferenceConnection{}, err
	}
	ctx := NewLoadContext()
	return LoadReferenceConnection(data, ctx)
}

// FromYAML creates ReferenceConnection from YAML string
func ReferenceConnectionFromYAML(yamlStr string) (ReferenceConnection, error) {
	var data map[string]interface{}
	if err := yaml.Unmarshal([]byte(yamlStr), &data); err != nil {
		return ReferenceConnection{}, err
	}
	ctx := NewLoadContext()
	return LoadReferenceConnection(data, ctx)
}

// RemoteConnection represents Connection configuration for AI services using named connections.

type RemoteConnection struct {
	Kind     string `json:"kind" yaml:"kind"`
	Name     string `json:"name" yaml:"name"`
	Endpoint string `json:"endpoint" yaml:"endpoint"`
}

// LoadRemoteConnection creates a RemoteConnection from a map[string]interface{}
func LoadRemoteConnection(data interface{}, ctx *LoadContext) (RemoteConnection, error) {
	result := RemoteConnection{}

	// Load from map
	if m, ok := data.(map[string]interface{}); ok {
		if val, ok := m["kind"]; ok && val != nil {
			result.Kind = val.(string)
		}
		if val, ok := m["name"]; ok && val != nil {
			result.Name = val.(string)
		}
		if val, ok := m["endpoint"]; ok && val != nil {
			result.Endpoint = val.(string)
		}
	}

	return result, nil
}

// Save serializes RemoteConnection to map[string]interface{}
func (obj *RemoteConnection) Save(ctx *SaveContext) map[string]interface{} {
	result := make(map[string]interface{})
	result["kind"] = obj.Kind
	result["name"] = obj.Name
	result["endpoint"] = obj.Endpoint

	return result
}

// ToJSON serializes RemoteConnection to JSON string
func (obj *RemoteConnection) ToJSON() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := json.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// ToYAML serializes RemoteConnection to YAML string
func (obj *RemoteConnection) ToYAML() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := yaml.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// FromJSON creates RemoteConnection from JSON string
func RemoteConnectionFromJSON(jsonStr string) (RemoteConnection, error) {
	var data map[string]interface{}
	if err := json.Unmarshal([]byte(jsonStr), &data); err != nil {
		return RemoteConnection{}, err
	}
	ctx := NewLoadContext()
	return LoadRemoteConnection(data, ctx)
}

// FromYAML creates RemoteConnection from YAML string
func RemoteConnectionFromYAML(yamlStr string) (RemoteConnection, error) {
	var data map[string]interface{}
	if err := yaml.Unmarshal([]byte(yamlStr), &data); err != nil {
		return RemoteConnection{}, err
	}
	ctx := NewLoadContext()
	return LoadRemoteConnection(data, ctx)
}

// ApiKeyConnection represents Connection configuration for AI services using API keys.

type ApiKeyConnection struct {
	Kind     string `json:"kind" yaml:"kind"`
	Endpoint string `json:"endpoint" yaml:"endpoint"`
	Apikey   string `json:"apiKey" yaml:"apiKey"`
}

// LoadApiKeyConnection creates a ApiKeyConnection from a map[string]interface{}
func LoadApiKeyConnection(data interface{}, ctx *LoadContext) (ApiKeyConnection, error) {
	result := ApiKeyConnection{}

	// Load from map
	if m, ok := data.(map[string]interface{}); ok {
		if val, ok := m["kind"]; ok && val != nil {
			result.Kind = val.(string)
		}
		if val, ok := m["endpoint"]; ok && val != nil {
			result.Endpoint = val.(string)
		}
		if val, ok := m["apiKey"]; ok && val != nil {
			result.Apikey = val.(string)
		}
	}

	return result, nil
}

// Save serializes ApiKeyConnection to map[string]interface{}
func (obj *ApiKeyConnection) Save(ctx *SaveContext) map[string]interface{} {
	result := make(map[string]interface{})
	result["kind"] = obj.Kind
	result["endpoint"] = obj.Endpoint
	result["apiKey"] = obj.Apikey

	return result
}

// ToJSON serializes ApiKeyConnection to JSON string
func (obj *ApiKeyConnection) ToJSON() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := json.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// ToYAML serializes ApiKeyConnection to YAML string
func (obj *ApiKeyConnection) ToYAML() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := yaml.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// FromJSON creates ApiKeyConnection from JSON string
func ApiKeyConnectionFromJSON(jsonStr string) (ApiKeyConnection, error) {
	var data map[string]interface{}
	if err := json.Unmarshal([]byte(jsonStr), &data); err != nil {
		return ApiKeyConnection{}, err
	}
	ctx := NewLoadContext()
	return LoadApiKeyConnection(data, ctx)
}

// FromYAML creates ApiKeyConnection from YAML string
func ApiKeyConnectionFromYAML(yamlStr string) (ApiKeyConnection, error) {
	var data map[string]interface{}
	if err := yaml.Unmarshal([]byte(yamlStr), &data); err != nil {
		return ApiKeyConnection{}, err
	}
	ctx := NewLoadContext()
	return LoadApiKeyConnection(data, ctx)
}

// AnonymousConnection represents a schema type
type AnonymousConnection struct {
	Kind     string `json:"kind" yaml:"kind"`
	Endpoint string `json:"endpoint" yaml:"endpoint"`
}

// LoadAnonymousConnection creates a AnonymousConnection from a map[string]interface{}
func LoadAnonymousConnection(data interface{}, ctx *LoadContext) (AnonymousConnection, error) {
	result := AnonymousConnection{}

	// Load from map
	if m, ok := data.(map[string]interface{}); ok {
		if val, ok := m["kind"]; ok && val != nil {
			result.Kind = val.(string)
		}
		if val, ok := m["endpoint"]; ok && val != nil {
			result.Endpoint = val.(string)
		}
	}

	return result, nil
}

// Save serializes AnonymousConnection to map[string]interface{}
func (obj *AnonymousConnection) Save(ctx *SaveContext) map[string]interface{} {
	result := make(map[string]interface{})
	result["kind"] = obj.Kind
	result["endpoint"] = obj.Endpoint

	return result
}

// ToJSON serializes AnonymousConnection to JSON string
func (obj *AnonymousConnection) ToJSON() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := json.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// ToYAML serializes AnonymousConnection to YAML string
func (obj *AnonymousConnection) ToYAML() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := yaml.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// FromJSON creates AnonymousConnection from JSON string
func AnonymousConnectionFromJSON(jsonStr string) (AnonymousConnection, error) {
	var data map[string]interface{}
	if err := json.Unmarshal([]byte(jsonStr), &data); err != nil {
		return AnonymousConnection{}, err
	}
	ctx := NewLoadContext()
	return LoadAnonymousConnection(data, ctx)
}

// FromYAML creates AnonymousConnection from YAML string
func AnonymousConnectionFromYAML(yamlStr string) (AnonymousConnection, error) {
	var data map[string]interface{}
	if err := yaml.Unmarshal([]byte(yamlStr), &data); err != nil {
		return AnonymousConnection{}, err
	}
	ctx := NewLoadContext()
	return LoadAnonymousConnection(data, ctx)
}
