// Code generated by AgentSchema emitter; DO NOT EDIT.

package agentschema

import (
	"encoding/json"

	"gopkg.in/yaml.v3"
)

// Property represents Represents a single property.
//
// - This model defines the structure of properties that can be used in prompts,
// including their type, description, whether they are required, and other attributes.
// - It allows for the definition of dynamic inputs that can be filled with data
// and processed to generate prompts for AI models.

type Property struct {
	Name        string        `json:"name" yaml:"name"`
	Kind        string        `json:"kind" yaml:"kind"`
	Description *string       `json:"description,omitempty" yaml:"description,omitempty"`
	Required    *bool         `json:"required,omitempty" yaml:"required,omitempty"`
	Default     *interface{}  `json:"default,omitempty" yaml:"default,omitempty"`
	Example     *interface{}  `json:"example,omitempty" yaml:"example,omitempty"`
	EnumValues  []interface{} `json:"enumValues,omitempty" yaml:"enumValues,omitempty"`
}

// LoadProperty creates a Property from a map[string]interface{}
// Returns interface{} because this is a polymorphic base type that can resolve to different child types
func LoadProperty(data interface{}, ctx *LoadContext) (interface{}, error) {
	result := Property{}

	// Handle polymorphic types based on discriminator
	if m, ok := data.(map[string]interface{}); ok {
		if discriminator, ok := m["kind"]; ok {
			switch discriminator {
			case "array":
				return LoadArrayProperty(data, ctx)
			case "object":
				return LoadObjectProperty(data, ctx)
			default:
				return LoadProperty(data, ctx)
			}
		}
	}
	// Handle alternate scalar representations
	switch v := data.(type) {
	case bool:
		// Shorthand: bool -> Property
		expansion := map[string]interface{}{"kind": "boolean", "example": v}
		return LoadProperty(expansion, ctx)
	case float32:
		// Shorthand: float32 -> Property
		expansion := map[string]interface{}{"kind": "float", "example": v}
		return LoadProperty(expansion, ctx)
	case int:
		// Shorthand: int -> Property
		expansion := map[string]interface{}{"kind": "integer", "example": v}
		return LoadProperty(expansion, ctx)
	case string:
		// Shorthand: string -> Property
		expansion := map[string]interface{}{"kind": "string", "example": v}
		return LoadProperty(expansion, ctx)
	}
	// Load from map
	if m, ok := data.(map[string]interface{}); ok {
		if val, ok := m["name"]; ok && val != nil {
			result.Name = val.(string)
		}
		if val, ok := m["kind"]; ok && val != nil {
			result.Kind = val.(string)
		}
		if val, ok := m["description"]; ok && val != nil {
			v := val.(string)
			result.Description = &v
		}
		if val, ok := m["required"]; ok && val != nil {
			v := val.(bool)
			result.Required = &v
		}
		if val, ok := m["default"]; ok && val != nil {
			result.Default = &val
		}
		if val, ok := m["example"]; ok && val != nil {
			result.Example = &val
		}
		if val, ok := m["enumValues"]; ok && val != nil {
			if arr, ok := val.([]interface{}); ok {
				result.EnumValues = arr
			}
		}
	}

	return result, nil
}

// Save serializes Property to map[string]interface{}
func (obj *Property) Save(ctx *SaveContext) map[string]interface{} {
	result := make(map[string]interface{})
	result["name"] = obj.Name
	result["kind"] = obj.Kind
	if obj.Description != nil {
		result["description"] = *obj.Description
	}
	if obj.Required != nil {
		result["required"] = *obj.Required
	}
	if obj.Default != nil {
		result["default"] = *obj.Default
	}
	if obj.Example != nil {
		result["example"] = *obj.Example
	}
	result["enumValues"] = obj.EnumValues

	return result
}

// ToJSON serializes Property to JSON string
func (obj *Property) ToJSON() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := json.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// ToYAML serializes Property to YAML string
func (obj *Property) ToYAML() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := yaml.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// FromJSON creates Property from JSON string
// Returns interface{} because this is a polymorphic base type that can resolve to different child types
func PropertyFromJSON(jsonStr string) (interface{}, error) {
	var data map[string]interface{}
	if err := json.Unmarshal([]byte(jsonStr), &data); err != nil {
		return nil, err
	}
	ctx := NewLoadContext()
	return LoadProperty(data, ctx)
}

// FromYAML creates Property from YAML string
// Returns interface{} because this is a polymorphic base type that can resolve to different child types
func PropertyFromYAML(yamlStr string) (interface{}, error) {
	var data map[string]interface{}
	if err := yaml.Unmarshal([]byte(yamlStr), &data); err != nil {
		return nil, err
	}
	ctx := NewLoadContext()
	return LoadProperty(data, ctx)
}

// ArrayProperty represents Represents an array property.
// This extends the base Property model to represent an array of items.

type ArrayProperty struct {
	Kind  string      `json:"kind" yaml:"kind"`
	Items interface{} `json:"items" yaml:"items"`
}

// LoadArrayProperty creates a ArrayProperty from a map[string]interface{}
func LoadArrayProperty(data interface{}, ctx *LoadContext) (ArrayProperty, error) {
	result := ArrayProperty{}

	// Load from map
	if m, ok := data.(map[string]interface{}); ok {
		if val, ok := m["kind"]; ok && val != nil {
			result.Kind = val.(string)
		}
		if val, ok := m["items"]; ok && val != nil {
			if m, ok := val.(map[string]interface{}); ok {
				loaded, _ := LoadProperty(m, ctx)
				// Polymorphic type - keep as interface{}
				result.Items = loaded
			}
		}
	}

	return result, nil
}

// Save serializes ArrayProperty to map[string]interface{}
func (obj *ArrayProperty) Save(ctx *SaveContext) map[string]interface{} {
	result := make(map[string]interface{})
	result["kind"] = obj.Kind

	// Handle polymorphic type via type switch
	switch v := obj.Items.(type) {
	case interface {
		Save(*SaveContext) map[string]interface{}
	}:
		result["items"] = v.Save(ctx)
	default:
		result["items"] = obj.Items
	}

	return result
}

// ToJSON serializes ArrayProperty to JSON string
func (obj *ArrayProperty) ToJSON() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := json.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// ToYAML serializes ArrayProperty to YAML string
func (obj *ArrayProperty) ToYAML() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := yaml.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// FromJSON creates ArrayProperty from JSON string
func ArrayPropertyFromJSON(jsonStr string) (ArrayProperty, error) {
	var data map[string]interface{}
	if err := json.Unmarshal([]byte(jsonStr), &data); err != nil {
		return ArrayProperty{}, err
	}
	ctx := NewLoadContext()
	return LoadArrayProperty(data, ctx)
}

// FromYAML creates ArrayProperty from YAML string
func ArrayPropertyFromYAML(yamlStr string) (ArrayProperty, error) {
	var data map[string]interface{}
	if err := yaml.Unmarshal([]byte(yamlStr), &data); err != nil {
		return ArrayProperty{}, err
	}
	ctx := NewLoadContext()
	return LoadArrayProperty(data, ctx)
}

// ObjectProperty represents Represents an object property.
// This extends the base Property model to represent a structured object.

type ObjectProperty struct {
	Kind       string     `json:"kind" yaml:"kind"`
	Properties []Property `json:"properties" yaml:"properties"`
}

// LoadObjectProperty creates a ObjectProperty from a map[string]interface{}
func LoadObjectProperty(data interface{}, ctx *LoadContext) (ObjectProperty, error) {
	result := ObjectProperty{}

	// Load from map
	if m, ok := data.(map[string]interface{}); ok {
		if val, ok := m["kind"]; ok && val != nil {
			result.Kind = val.(string)
		}
		if val, ok := m["properties"]; ok && val != nil {
			if arr, ok := val.([]interface{}); ok {
				result.Properties = make([]Property, len(arr))
				for i, v := range arr {
					if item, ok := v.(map[string]interface{}); ok {
						loaded, _ := LoadProperty(item, ctx)
						// Type assert from interface{} in case Load returns interface{} for polymorphic types
						result.Properties[i] = loaded.(Property)
					}
				}
			}
		}
	}

	return result, nil
}

// Save serializes ObjectProperty to map[string]interface{}
func (obj *ObjectProperty) Save(ctx *SaveContext) map[string]interface{} {
	result := make(map[string]interface{})
	result["kind"] = obj.Kind
	if obj.Properties != nil {
		arr := make([]interface{}, len(obj.Properties))
		for i, item := range obj.Properties {
			arr[i] = item.Save(ctx)
		}
		result["properties"] = arr
	}

	return result
}

// ToJSON serializes ObjectProperty to JSON string
func (obj *ObjectProperty) ToJSON() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := json.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// ToYAML serializes ObjectProperty to YAML string
func (obj *ObjectProperty) ToYAML() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := yaml.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// FromJSON creates ObjectProperty from JSON string
func ObjectPropertyFromJSON(jsonStr string) (ObjectProperty, error) {
	var data map[string]interface{}
	if err := json.Unmarshal([]byte(jsonStr), &data); err != nil {
		return ObjectProperty{}, err
	}
	ctx := NewLoadContext()
	return LoadObjectProperty(data, ctx)
}

// FromYAML creates ObjectProperty from YAML string
func ObjectPropertyFromYAML(yamlStr string) (ObjectProperty, error) {
	var data map[string]interface{}
	if err := yaml.Unmarshal([]byte(yamlStr), &data); err != nil {
		return ObjectProperty{}, err
	}
	ctx := NewLoadContext()
	return LoadObjectProperty(data, ctx)
}
