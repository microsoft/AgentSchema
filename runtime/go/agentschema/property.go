

// Code generated by AgentSchema emitter; DO NOT EDIT.

package agentschema

import (
	"encoding/json"
	"fmt"
	
	"gopkg.in/yaml.v3"
)


// Property represents Represents a single property.

- This model defines the structure of properties that can be used in prompts,
including their type, description, whether they are required, and other attributes.
- It allows for the definition of dynamic inputs that can be filled with data
and processed to generate prompts for AI models.
type Property struct {
	Name string `json:"name" yaml:"name"`
	Kind string `json:"kind" yaml:"kind"`
	Description *string `json:"description,omitempty" yaml:"description,omitempty"`
	Required *bool `json:"required,omitempty" yaml:"required,omitempty"`
	Default *interface{} `json:"default,omitempty" yaml:"default,omitempty"`
	Example *interface{} `json:"example,omitempty" yaml:"example,omitempty"`
	Enumvalues []interface{} `json:"enumValues,omitempty" yaml:"enumValues,omitempty"`
}

// LoadProperty creates a Property from a map[string]interface{}
func LoadProperty(data interface{}, ctx *LoadContext) (Property, error) {
	result := Property{}
	
	// Handle polymorphic types based on discriminator
	if m, ok := data.(map[string]interface{}); ok {
		if discriminator, ok := m["kind"]; ok {
			switch discriminator {
			case "array":
				return LoadArrayProperty(data, ctx)
			case "object":
				return LoadObjectProperty(data, ctx)
			default:
				return LoadProperty(data, ctx)
			}
		}
	}
	// Handle alternate scalar representations
	switch v := data.(type) {
	case bool:
		// Shorthand: bool -> Property
		expansion := map[string]interface{}{"kind":"boolean","example":data}
		return LoadProperty(expansion, ctx)
	case float32:
		// Shorthand: float32 -> Property
		expansion := map[string]interface{}{"kind":"float","example":data}
		return LoadProperty(expansion, ctx)
	case int:
		// Shorthand: int -> Property
		expansion := map[string]interface{}{"kind":"integer","example":data}
		return LoadProperty(expansion, ctx)
	case string:
		// Shorthand: string -> Property
		expansion := map[string]interface{}{"kind":"string","example":data}
		return LoadProperty(expansion, ctx)
	}
	// Load from map
	if m, ok := data.(map[string]interface{}); ok {
		if val, ok := m["name"]; ok && val != nil {result.Name = val.(string)}
		if val, ok := m["kind"]; ok && val != nil {result.Kind = val.(string)}
		if val, ok := m["description"]; ok && val != nil {v := val.(string)
			result.Description = &v}
		if val, ok := m["required"]; ok && val != nil {v := val.(bool)
			result.Required = &v}
		if val, ok := m["default"]; ok && val != nil {v := val.()
			result.Default = &v}
		if val, ok := m["example"]; ok && val != nil {v := val.()
			result.Example = &v}
		if val, ok := m["enumValues"]; ok && val != nil {
			if arr, ok := val.([]interface{}); ok {
				result.Enumvalues = make([], len(arr))
				for i, v := range arr {
					result.Enumvalues[i] = v.()
				}
			}
		}
	}
	
	return result, nil
}

// Save serializes Property to map[string]interface{}
func (obj *Property) Save(ctx *SaveContext) map[string]interface{} {
	result := make(map[string]interface{})
	result["name"] = obj.Name
	result["kind"] = obj.Kind
	if obj.Description != nil {result["description"] = *obj.Description}
	if obj.Required != nil {result["required"] = *obj.Required}
	if obj.Default != nil {result["default"] = *obj.Default}
	if obj.Example != nil {result["example"] = *obj.Example}
	result["enumValues"] = obj.Enumvalues
	
	return result
}

// ToJSON serializes Property to JSON string
func (obj *Property) ToJSON() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := json.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// ToYAML serializes Property to YAML string
func (obj *Property) ToYAML() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := yaml.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// FromJSON creates Property from JSON string
func PropertyFromJSON(jsonStr string) (Property, error) {
	var data map[string]interface{}
	if err := json.Unmarshal([]byte(jsonStr), &data); err != nil {
		return Property{}, err
	}
	ctx := NewLoadContext()
	return LoadProperty(data, ctx)
}

// FromYAML creates Property from YAML string
func PropertyFromYAML(yamlStr string) (Property, error) {
	var data map[string]interface{}
	if err := yaml.Unmarshal([]byte(yamlStr), &data); err != nil {
		return Property{}, err
	}
	ctx := NewLoadContext()
	return LoadProperty(data, ctx)
}


// ArrayProperty represents Represents an array property.
This extends the base Property model to represent an array of items.
type ArrayProperty struct {
	Kind string `json:"kind" yaml:"kind"`
	Items Property `json:"items" yaml:"items"`
}

// LoadArrayProperty creates a ArrayProperty from a map[string]interface{}
func LoadArrayProperty(data interface{}, ctx *LoadContext) (ArrayProperty, error) {
	result := ArrayProperty{}
	
	// Load from map
	if m, ok := data.(map[string]interface{}); ok {
		if val, ok := m["kind"]; ok && val != nil {result.Kind = val.(string)}
		if val, ok := m["items"]; ok && val != nil {
			if m, ok := val.(map[string]interface{}); ok {
				loaded, _ := LoadProperty(m, ctx)result.Items = loaded}
		}
	}
	
	return result, nil
}

// Save serializes ArrayProperty to map[string]interface{}
func (obj *ArrayProperty) Save(ctx *SaveContext) map[string]interface{} {
	result := make(map[string]interface{})
	result["kind"] = obj.Kind
	result["items"] = obj.Items.Save(ctx)
	
	return result
}

// ToJSON serializes ArrayProperty to JSON string
func (obj *ArrayProperty) ToJSON() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := json.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// ToYAML serializes ArrayProperty to YAML string
func (obj *ArrayProperty) ToYAML() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := yaml.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// FromJSON creates ArrayProperty from JSON string
func ArrayPropertyFromJSON(jsonStr string) (ArrayProperty, error) {
	var data map[string]interface{}
	if err := json.Unmarshal([]byte(jsonStr), &data); err != nil {
		return ArrayProperty{}, err
	}
	ctx := NewLoadContext()
	return LoadArrayProperty(data, ctx)
}

// FromYAML creates ArrayProperty from YAML string
func ArrayPropertyFromYAML(yamlStr string) (ArrayProperty, error) {
	var data map[string]interface{}
	if err := yaml.Unmarshal([]byte(yamlStr), &data); err != nil {
		return ArrayProperty{}, err
	}
	ctx := NewLoadContext()
	return LoadArrayProperty(data, ctx)
}


// ObjectProperty represents Represents an object property.
This extends the base Property model to represent a structured object.
type ObjectProperty struct {
	Kind string `json:"kind" yaml:"kind"`
	Properties []Property `json:"properties" yaml:"properties"`
}

// LoadObjectProperty creates a ObjectProperty from a map[string]interface{}
func LoadObjectProperty(data interface{}, ctx *LoadContext) (ObjectProperty, error) {
	result := ObjectProperty{}
	
	// Load from map
	if m, ok := data.(map[string]interface{}); ok {
		if val, ok := m["kind"]; ok && val != nil {result.Kind = val.(string)}
		if val, ok := m["properties"]; ok && val != nil {
			if arr, ok := val.([]interface{}); ok {
				result.Properties = make([]Property, len(arr))
				for i, v := range arr {
					if item, ok := v.(map[string]interface{}); ok {
						loaded, _ := LoadProperty(item, ctx)
						result.Properties[i] = loaded
					}
				}
			}
		}
	}
	
	return result, nil
}

// Save serializes ObjectProperty to map[string]interface{}
func (obj *ObjectProperty) Save(ctx *SaveContext) map[string]interface{} {
	result := make(map[string]interface{})
	result["kind"] = obj.Kind
	if obj.Properties != nil {
		arr := make([]interface{}, len(obj.Properties))
		for i, item := range obj.Properties {
			arr[i] = item.Save(ctx)
		}
		result["properties"] = arr
	}
	
	return result
}

// ToJSON serializes ObjectProperty to JSON string
func (obj *ObjectProperty) ToJSON() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := json.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// ToYAML serializes ObjectProperty to YAML string
func (obj *ObjectProperty) ToYAML() (string, error) {
	ctx := NewSaveContext()
	data := obj.Save(ctx)
	bytes, err := yaml.Marshal(data)
	if err != nil {
		return "", err
	}
	return string(bytes), nil
}

// FromJSON creates ObjectProperty from JSON string
func ObjectPropertyFromJSON(jsonStr string) (ObjectProperty, error) {
	var data map[string]interface{}
	if err := json.Unmarshal([]byte(jsonStr), &data); err != nil {
		return ObjectProperty{}, err
	}
	ctx := NewLoadContext()
	return LoadObjectProperty(data, ctx)
}

// FromYAML creates ObjectProperty from YAML string
func ObjectPropertyFromYAML(yamlStr string) (ObjectProperty, error) {
	var data map[string]interface{}
	if err := yaml.Unmarshal([]byte(yamlStr), &data); err != nil {
		return ObjectProperty{}, err
	}
	ctx := NewLoadContext()
	return LoadObjectProperty(data, ctx)
}


